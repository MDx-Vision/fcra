Got you, Rafael. Iâ€™ll give you **all three patches** cleanly so you can drop them straight into your Replit project and later migrate to WordPress with zero surprises.

Below is what Iâ€™ll deliver:

1. âœ… **Backend patch for PDF section splitting**
2. âœ… **Replit-ready file structure (exact folders + files you should create)**
3. âœ… **JWT API authentication (works now in Replit, future-proof for WordPress)**

Everything will stay fully compatible with your existing Claude workflow and your `/webhook` endpoint.

---

# âœ… 1. BACKEND PATCH â€” PDF SECTION SPLITTING

You want each major section of the credit report (tradelines, inquiries, public records, collections) turned into **separate PDFs** so they aren't 50-page monsters.

Add this inside `pdf_generator.py`:

```python
from fpdf import FPDF
import os

class SectionPDFGenerator:
    def __init__(self):
        pass

    def create_pdf(self, title, content, output_path):
        pdf = FPDF()
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)

        pdf.set_font("Arial", "B", 16)
        pdf.cell(0, 10, title, ln=True)

        pdf.ln(5)
        pdf.set_font("Arial", "", 12)

        for line in content.split("\n"):
            pdf.multi_cell(0, 8, line)

        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        pdf.output(output_path)
        return output_path
```

Now, in your main backend file (`app.py`):

Add under your imports:

```python
from pdf_generator import SectionPDFGenerator
section_pdf = SectionPDFGenerator()
```

Inside the `run_stage1_for_all_sections()` result handler, add this right before returning the analysis:

```python
# Generate PDF for each section
generated_pdfs = []
for section_name, section_text in sections.items():
    filename = f"{client_name.replace(' ', '_')}_{section_name}.pdf"
    path = os.path.join("static", "section_pdfs", filename)
    output_path = section_pdf.create_pdf(
        f"{section_name.upper()} SECTION",
        section_text,
        path
    )
    generated_pdfs.append(output_path)

analysis_result['section_pdfs'] = generated_pdfs
```

Each section will now automatically generate a clean, readable PDF stored in:

```
static/section_pdfs/
```

---

# âœ… 2. FULL REPLIT FILE TREE

This is the clean, professional layout I recommend for your FCRA automation backend.

```
/ (project root)
â”‚
â”œâ”€â”€ app.py                         # your main backend
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ database.py
â”œâ”€â”€ litigation_tools.py
â”œâ”€â”€ pdf_generator.py               # existing
â”œâ”€â”€ jwt_utils.py                   # new file added below
â”‚
â”œâ”€â”€ static/
â”‚   â”œâ”€â”€ generated_letters/
â”‚   â”œâ”€â”€ section_pdfs/
â”‚   â””â”€â”€ logs/
â”‚
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ admin.html
â”‚   â””â”€â”€ litigation_review.html
â”‚
â””â”€â”€ utils/
    â”œâ”€â”€ splitter.py                # optional helper module
    â”œâ”€â”€ sanitizers.py
    â””â”€â”€ html_cleaner.py
```

You donâ€™t **need** the utils folder, but itâ€™s good housekeeping as this grows.

---

# âœ… 3. JWT AUTHENTICATION (FULL IMPLEMENTATION)

This protects your backend from:

* spam
* bots
* unauthorized WordPress forms
* people hitting `/webhook` directly

### â¤ Step 1 â€” Create `jwt_utils.py`

```python
import jwt
import datetime
from flask import request, jsonify

SECRET_KEY = "CHANGE_THIS_TO_A_LONG_RANDOM_SECRET"

def create_token():
    """Used for issuing tokens to trusted apps (WordPress later)."""
    payload = {
        "exp": datetime.datetime.utcnow() + datetime.timedelta(days=7),
        "iat": datetime.datetime.utcnow(),
        "scope": "fcra_access"
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")

def require_jwt(f):
    """Decorator to protect any Flask route."""
    def wrapper(*args, **kwargs):
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            return jsonify({"error": "Missing or invalid token"}), 401

        token = auth_header.split(" ")[1]

        try:
            jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        except jwt.ExpiredSignatureError:
            return jsonify({"error": "Token expired"}), 401
        except Exception:
            return jsonify({"error": "Invalid token"}), 401

        return f(*args, **kwargs)
    return wrapper
```

---

### â¤ Step 2 â€” Protect your webhook endpoints

Inside `app.py`, add:

```python
from jwt_utils import require_jwt
```

Then modify each API route you want protected:

```python
@app.route('/webhook', methods=['POST'])
@require_jwt
def webhook():
```

You can protect:

* `/webhook`
* `/api/analyze`
* `/webhook/batch`
* `/api/approve/<id>`

WordPress will send the token in the header.

---

# â­ Step 3 â€” Generate an API token (manually)

Open Replit console:

```
python3
```

Then inside Python:

```python
from jwt_utils import create_token
print(create_token())
```

Copy your token.

This token is what your WordPress form will send:

```
Authorization: Bearer YOUR_TOKEN_HERE
```

---

# â­ Step 4 â€” Modify frontend JS (very small change)

Add the token at the top:

```js
const API_TOKEN = "Bearer YOUR_JWT_TOKEN";
```

Update your fetch:

```js
const response = await fetch(`${backendURL}/webhook`, {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': API_TOKEN
    },
    body: JSON.stringify(payload)
});
```

Now ONLY your approved sites can submit reports.

---

# ğŸ‰ You now have:

âœ” Section-based PDF generation
âœ” Clean full Replit file structure
âœ” Hardened JWT security
âœ” WordPress-ready backend
âœ” Full compatibility with your Claude automation

---

If you want, I can now:

ğŸ“Œ Build the WordPress plugin for your credit-report uploader
ğŸ“Œ Add an admin-only dashboard inside WordPress
ğŸ“Œ Host your backend on Render or Fly.io for production

Just tell me the next step.
