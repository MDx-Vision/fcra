# FCRA v2.6 + RLPP Integration Guide for Your Working App.py

Since your working app.py (the one you pasted with ~2000 lines) is different from what's saved in the file, here's how to integrate the comprehensive prompt system:

## Step 1: Add Import (Top of File)

Find this section near the top of your app.py:

```python
from anthropic import Anthropic

try:
    client = Anthropic(api_key=ANTHROPIC_API_KEY)
```

**Add this line RIGHT AFTER the anthropic import:**

```python
from prompt_loader import get_prompt_loader
```

## Step 2: Update Stage 2 Prompt Generation

Find the `analyze_with_claude()` function and locate the Stage 2 prompt section (around line 350-450).

Look for this code:

```python
        else:
            # STAGE 2: Full prompt for client documents generation (uses Stage 1 results)
            prompt = f"""You are an elite consumer protection attorney. ANALYZE the Stage 1 findings below and generate comprehensive, forensic-quality litigation documents with SPECIFIC ACCOUNT DATA.

**STAGE 1 ANALYSIS DATA (EXTRACT ALL VIOLATION DETAILS FROM THIS):**
{stage_1_results}

**CRITICAL INSTRUCTIONS - MUST FOLLOW:**
```

**Replace the ENTIRE `prompt = f"""..."""` assignment with:**

```python
        else:
            # STAGE 2: Use comprehensive FCRA v2.6 + RLPP prompt
            print("\nüî® Loading comprehensive FCRA v2.6 + RLPP prompt...")
            loader = get_prompt_loader()
            comprehensive_prompt = loader.build_comprehensive_stage2_prompt(dispute_round=dispute_round)
            
            if not comprehensive_prompt:
                return {'success': False, 'error': 'Failed to load comprehensive prompt templates'}
            
            # Use the comprehensive prompt as the base system prompt
            prompt = comprehensive_prompt
```

## Step 3: Update Stage 2 User Message

Still in the same function, find where the user_message is set for Stage 2:

```python
        else:
            # Stage 2: Use previous Stage 1 results
            user_message = f"""
üö® STAGE 2: CLIENT DOCUMENTS GENERATION

Previous Stage 1 Analysis:
{stage_1_results}

CLIENT: {client_name} (CMM ID: {cmm_id})
Provider: {provider}
Dispute Round: {round_names.get(dispute_round, 'Round ' + str(dispute_round))}

TASK: Generate client-facing documents using Stage 1 results:
```

**Replace with:**

```python
        else:
            # Stage 2: Generate comprehensive 107-page litigation package
            user_message = f"""
üö® STAGE 2: GENERATE COMPREHENSIVE 107-PAGE LITIGATION PACKAGE

**CLIENT INFORMATION:**
- Name: {client_name}
- CMM ID: {cmm_id}
- Provider: {provider}
- Dispute Round: {dispute_round}

**STAGE 1 ANALYSIS RESULTS (USE THIS DATA):**
{stage_1_results}

**YOUR TASK:**
Generate complete client-facing litigation package with ALL PARTS (0-7):
- Part 0-4: Forensic analysis (use Stage 1 data from above)
- Part 5: 40-50 page client report with executive summary, violations, damages
- Part 6: Bureau-specific dispute letters (Equifax, Experian, TransUnion)
- Part 7: MOV requests (where applicable)

Use RLPP aggressive language appropriate for Round {dispute_round}.
Include scissor markers (‚úÇÔ∏è) around each letter for easy extraction.
Total output: 80-120 pages, litigation-ready format.

CRITICAL: Use ACTUAL violations and account data from Stage 1 results above.
NO templates or placeholders. Extract real account names, bureaus, violations.
"""
```

## Step 4: Update Letter Extraction (in `/api/approve` endpoint)

Find the letter extraction section in the `/api/approve/<int:analysis_id>` endpoint:

```python
        # Extract letters - Claude may format differently, so handle multiple patterns
        # Try pattern 1: [Bureau: Account]\nLetter content...
        letter_pattern = r'\[([^:]+):\s*([^\]]+)\]\s*\n(.*?)(?=\[|$)'
```

**Replace the entire letter extraction block with:**

```python
        # Extract letters using scissor markers (from FCRA v2.6 prompt)
        print(f"üìù Extracting letters from Stage 2 output...")
        
        stage_2_text = result.get('analysis', '')
        bureau_letters = {}
        
        # Pattern 1: Scissor marker format (‚úÇÔ∏è markers)
        scissor_pattern = r'‚úÇÔ∏è.*?START OF (?:DISPUTE LETTER|MOV REQUEST):\s*([A-Za-z\s]+).*?‚úÇÔ∏è\n(.*?)\n‚úÇÔ∏è.*?END OF'
        matches = re.findall(scissor_pattern, stage_2_text, re.DOTALL | re.IGNORECASE)
        
        if matches:
            print(f"   ‚úÖ Found {len(matches)} letters using scissor markers")
            for bureau_name, letter_content in matches:
                bureau_name = bureau_name.strip().title()
                # Normalize bureau names
                if 'equifax' in bureau_name.lower():
                    bureau_name = 'Equifax'
                elif 'experian' in bureau_name.lower():
                    bureau_name = 'Experian'
                elif 'transunion' in bureau_name.lower() or 'trans union' in bureau_name.lower():
                    bureau_name = 'TransUnion'
                elif 'comprehensive' in bureau_name.lower():
                    bureau_name = 'Comprehensive Analysis'
                
                bureau_letters.setdefault(bureau_name, []).append({
                    'account': 'Multiple Accounts',
                    'content': letter_content.strip()[:10000]  # Cap at 10k chars
                })
        
        # Fallback: Original pattern
        if not matches:
            print(f"   ‚ö†Ô∏è  No scissor markers found, trying fallback pattern...")
            letter_pattern = r'\[([^:]+):\s*([^\]]+)\]\s*\n(.*?)(?=\[|$)'
            fallback_matches = re.findall(letter_pattern, stage_2_text, re.DOTALL)
            
            for bureau_name, account_name, letter_content in fallback_matches:
                bureau_name = bureau_name.strip().title()
                if bureau_name in ['Equifax', 'Experian', 'TransUnion', 'Comprehensive Analysis']:
                    bureau_letters.setdefault(bureau_name, []).append({
                        'account': account_name.strip()[:50],
                        'content': letter_content.strip()[:10000]
                    })
            
            if fallback_matches:
                print(f"   ‚úÖ Found {len(fallback_matches)} letters using fallback pattern")
        
        # Final fallback: Create comprehensive letter if nothing found
        if not bureau_letters:
            print(f"   ‚ö†Ô∏è  No letters extracted. Creating fallback comprehensive letter...")
            bureau_letters['Comprehensive Analysis'] = [{
                'account': 'All Bureaus',
                'content': stage_2_text[:10000]
            }]
```

## Step 5: Test the Integration

After making these changes:

1. Save your app.py
2. Restart the Flask server
3. Test Stage 2 generation:
   - Submit a credit report (Stage 1)
   - Click "Accept Case & Generate Letters" (Stage 2)
   - Check console for "Loading comprehensive FCRA v2.6 + RLPP prompt..."
   - Verify the output is 80-120 pages with Parts 0-7

## What This Does

‚úÖ Loads FCRA Framework v2.6 SUPER_PROMPT (107-page structure)
‚úÖ Integrates RLPP aggressive language based on dispute round
‚úÖ Generates comprehensive forensic analysis (Parts 0-4)
‚úÖ Generates 40-50 page client report (Part 5)
‚úÖ Generates bureau-specific dispute letters (Part 6)
‚úÖ Generates MOV requests (Part 7)
‚úÖ Uses scissor markers for easy letter extraction
‚úÖ Properly separates PDFs (full report vs individual letters)

---

## Need Help?

If you encounter any issues, check:

1. `prompt_loader.py` exists in same directory as app.py
2. `prompts/fcra_framework/` directory has the MD files
3. `prompts/rlpp/` directory has the RLPP materials
4. Console shows "Loading comprehensive FCRA v2.6..." when running Stage 2

The integration is complete once you make these 4 changes!
