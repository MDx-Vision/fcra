import io
import os
import re
import time
import zipfile
from typing import Any

from sqlalchemy.exc import OperationalError
from sqlalchemy.orm.attributes import flag_modified

# Initialize logging first
from services.logging_config import (
    ai_logger,
    api_logger,
    app_logger,
    audit_logger,
    db_logger,
    init_request_logging,
    log_ai_request,
    log_audit,
    log_error,
    log_performance,
    setup_logging,
    timed,
)

setup_logging()
app_logger.info("Starting FCRA Litigation Platform...")

# Human-readable activity logging
from services.activity_logger import (
    log_activity,
    log_client_created,
    log_login,
    log_login_failed,
)

# API authentication and authorization (require_api_key defined below in this file)
from services.api_auth import AVAILABLE_SCOPES, create_jwt_token, require_auth

# Centralized configuration management
from services.config import config

# Input validation and sanitization
from services.input_validator import (
    detect_sql_injection,
    detect_xss,
    sanitize_credit_report_html,
    sanitize_dict,
    sanitize_string,
    validate_email,
    validate_phone,
    validate_request_data,
)

# Rate limiting
from services.rate_limiter import RATE_LIMITS, init_rate_limiter

# API Configuration (using centralized config)
ANTHROPIC_API_KEY = config.ANTHROPIC_API_KEY
if (
    not ANTHROPIC_API_KEY
    or ANTHROPIC_API_KEY.startswith("INVALID")
    or len(ANTHROPIC_API_KEY) < 20
):
    print(f"‚ö†Ô∏è  WARNING: Invalid or missing Anthropic API key!")
    print(f"   Expected: Secret 'FCRA Automation Secure' with valid sk-ant-... key")
    print(
        f"   Got: {'<empty>' if not ANTHROPIC_API_KEY else f'<too short: {len(ANTHROPIC_API_KEY)} chars>'}"
    )
    ANTHROPIC_API_KEY = "sk-ant-invalid-placeholder-key"

from anthropic import Anthropic

from services.prompt_loader import get_prompt_loader

client: Anthropic | None = None
try:
    client = Anthropic(api_key=ANTHROPIC_API_KEY)
    if "invalid" in ANTHROPIC_API_KEY.lower():
        print("‚ö†Ô∏è  Using placeholder API key - Stage 1 & Stage 2 will fail!")
    else:
        print("‚úÖ Anthropic API client initialized")
except Exception as e:
    print(f"‚ùå Failed to initialize Anthropic client: {e}")
    # client remains None to prevent crashes
import json
import os
import secrets
import uuid
from datetime import datetime, timedelta
from functools import wraps

# Initialize Sentry for error tracking (if configured)
import sentry_sdk
from flask import (
    Flask,
    g,
    jsonify,
    make_response,
    redirect,
    render_template,
    request,
    send_file,
    session,
    url_for,
)
from flask_cors import CORS
from sentry_sdk.integrations.flask import FlaskIntegration
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
from werkzeug.security import check_password_hash, generate_password_hash
from werkzeug.utils import secure_filename

from database import (
    API_SCOPES,
    AUDIT_EVENT_TYPES,
    AUDIT_RESOURCE_TYPES,
    CREDIT_MONITORING_SERVICES,
    FONT_FAMILIES,
    FRANCHISE_MEMBER_ROLES,
    FRANCHISE_ORG_TYPES,
    SOP,
    SPECIALTY_BUREAUS,
    SPECIALTY_DISPUTE_TYPES,
    SPECIALTY_LETTER_TYPES,
    SPECIALTY_RESPONSE_OUTCOMES,
    STAFF_ROLES,
    SUBSCRIPTION_TIERS,
    WEBHOOK_EVENTS,
    Affiliate,
    Analysis,
    AnalysisQueue,
    APIKey,
    APIRequest,
    APIWebhook,
    AuditLog,
    AutomationMetrics,
    CacheEntry,
    Case,
    CaseDeadline,
    CaseEvent,
    CaseLawCitation,
    CaseScore,
    CaseTriage,
    CFPBComplaint,
    ChexSystemsDispute,
    Client,
    ClientDocument,
    ClientNote,
    ClientReferral,
    ClientTag,
    ClientTagAssignment,
    ClientUpload,
    Commission,
    CRAResponse,
    CreditMonitoringCredential,
    CreditPullRequest,
    CreditReport,
    CreditScoreProjection,
    CreditScoreSnapshot,
    Damages,
    DisputeItem,
    DisputeLetter,
    Document,
    EmailLog,
    EmailTemplate,
    EscalationRecommendation,
    FranchiseOrganization,
    FrivolousDefense,
    FrivolousDefenseEvidence,
    Furnisher,
    FurnisherStats,
    InterOrgTransfer,
    KnowledgeContent,
    LetterBatch,
    LetterQueue,
    Metro2Code,
    MortgagePaymentLedger,
    NotarizeTransaction,
    Notification,
    OrganizationClient,
    OrganizationMembership,
    PatternInstance,
    PerformanceMetric,
    SecondaryBureauFreeze,
    Settlement,
    SignupDraft,
    SignupSettings,
    SMSLog,
    SpecialtyBureauDispute,
    Staff,
    Standing,
    SuspenseAccountFinding,
    Task,
    TenantClient,
    TenantUser,
    TradelineStatus,
    UserQuickLink,
    Violation,
    ViolationPattern,
    WhiteLabelConfig,
    WhiteLabelTenant,
    check_staff_permission,
    get_db,
    init_db,
)
from services import (
    affiliate_service,
    case_law_service,
    credit_pull_service,
    escalation_service,
    letter_queue_service,
    triage_service,
)
from services.api_access_service import APIAccessService, get_api_access_service
from services.attorney_analytics_service import attorney_analytics_service
from services.audit_service import AuditService, get_audit_service
from services.document_generators import (
    generate_client_email_html,
    generate_client_report_html,
    generate_internal_analysis_html,
    html_to_pdf,
)
from services.encryption import (
    decrypt_value,
    encrypt_value,
    is_encrypted,
    migrate_plaintext_to_encrypted,
)
from services.franchise_service import (
    FranchiseService,
    get_clients_for_org,
    get_org_filter,
)
from services.jwt_utils import create_token, require_jwt
from services.litigation_tools import (
    assess_willfulness,
    calculate_case_score,
    calculate_damages,
)
from services.pdf_generator import (
    CreditAnalysisPDFGenerator,
    LetterPDFGenerator,
    SectionPDFGenerator,
)
from services.performance_service import (
    PerformanceService,
    app_cache,
    cached,
    get_performance_service,
    invalidate_cache,
    request_timing_middleware,
)
from services.predictive_analytics_service import predictive_analytics_service
from services.scheduler_service import (
    COMMON_CRON_EXPRESSIONS,
    CronParser,
    SchedulerService,
)
from services.task_queue_service import TaskQueueService
from services.white_label_service import WhiteLabelService, get_white_label_service
from services.whitelabel_service import (
    WhiteLabelConfigService,
    get_whitelabel_config_service,
)
from services.workflow_triggers_service import (
    ACTION_TYPES,
    TRIGGER_TYPES,
    WorkflowTriggersService,
)

SENTRY_DSN = os.environ.get("SENTRY_DSN")
if SENTRY_DSN:
    sentry_sdk.init(
        dsn=SENTRY_DSN,
        integrations=[
            FlaskIntegration(),
            SqlalchemyIntegration(),
        ],
        traces_sample_rate=0.1,  # 10% of requests for performance monitoring
        profiles_sample_rate=0.1,  # 10% for profiling
        environment=os.environ.get("ENVIRONMENT", "development"),
        release=os.environ.get("APP_VERSION", "1.0.0"),
        send_default_pii=False,  # Don't send personally identifiable info
    )
    app_logger.info("Sentry error tracking initialized")
else:
    app_logger.info("Sentry not configured (set SENTRY_DSN to enable)")

app = Flask(__name__)

# Initialize request/response logging
init_request_logging(app)
app_logger.info("Flask app initialized")

# Initialize rate limiting
limiter = init_rate_limiter(app)
app_logger.info("Rate limiting initialized")

# Initialize security headers and HTTPS enforcement
from services.security_headers import init_security_headers

init_security_headers(app)
app_logger.info("Security headers initialized")

# Initialize graceful shutdown handling
from services.graceful_shutdown_service import init_graceful_shutdown

shutdown_manager = init_graceful_shutdown(app)
app_logger.info("Graceful shutdown handling initialized")

# Initialize database pool monitoring
try:
    from database import engine
    from services.database_pool_service import init_pool_monitoring
    pool_monitor = init_pool_monitoring(engine, start_background=True)
    app_logger.info("Database pool monitoring initialized")
except Exception as e:
    app_logger.warning(f"Could not initialize pool monitoring: {e}")

# Initialize rate limit monitoring
from services.rate_limit_monitor_service import init_rate_limit_monitoring

try:
    rate_limit_monitor = init_rate_limit_monitoring()
    app_logger.info("Rate limit monitoring initialized")
except Exception as e:
    app_logger.warning(f"Could not initialize rate limit monitoring: {e}")

# Initialize memory cleanup service (prevents memory leaks)
from services.memory_cleanup_service import register_cleanup_hook

# Secret key for session management (using centralized config)
app.secret_key = config.SECRET_KEY

from routes.affiliate_portal import affiliate_portal
from routes.partner import partner_bp

# Register blueprints
from routes.portal import portal

app.register_blueprint(portal)
print("‚úÖ Portal blueprint registered")

app.register_blueprint(affiliate_portal)
print("‚úÖ Affiliate portal blueprint registered")

app.register_blueprint(partner_bp)
print("‚úÖ Partner portal blueprint registered")

# Initialize Swagger/OpenAPI documentation
from flasgger import Swagger

swagger_config = {
    "headers": [],
    "specs": [
        {
            "endpoint": "apispec",
            "route": "/api/docs/apispec.json",
            "rule_filter": lambda rule: rule.rule.startswith("/api")
            or rule.rule.startswith("/health"),
            "model_filter": lambda tag: True,
        }
    ],
    "static_url_path": "/api/docs/static",
    "swagger_ui": True,
    "specs_route": "/api/docs/",
}

swagger_template = {
    "openapi": "3.0.3",
    "info": {
        "title": "FCRA Credit Repair Platform API",
        "description": "API documentation for the FCRA Credit Repair Management Platform",
        "version": "1.0.0",
    },
    "servers": [{"url": "/", "description": "Current server"}],
}

swagger = Swagger(app, config=swagger_config, template=swagger_template)
app_logger.info("Swagger API documentation initialized at /api/docs/")

# CI/CD Authentication Bypass (ONLY activates with CI=true AND not in production)
if config.IS_CI and not config.IS_PRODUCTION:
    print("‚úÖ CI auth bypass enabled")

    @app.before_request
    def ci_mock_auth():
        # Skip for login page so Cypress can test the login form
        if request.path == "/staff/login":
            return
        # Skip for static files
        if request.path.startswith("/static/"):
            return
        if "staff_id" not in session:
            # Query for a valid admin user on each request (handles DB changes)
            try:
                from database import SessionLocal

                _db = SessionLocal()
                _ci_staff = (
                    _db.query(Staff).filter_by(role="admin", is_active=True).first()
                )
                if _ci_staff:
                    session["staff_id"] = _ci_staff.id
                    session["staff_email"] = _ci_staff.email
                    session["staff_role"] = "admin"
                    session["staff_name"] = _ci_staff.full_name or "CI Admin"
                _db.close()
            except Exception as e:
                print(f"CI auth error: {e}")


# Session configuration for secure cookies
app.config["SESSION_COOKIE_SECURE"] = not config.IS_CI  # HTTPS only (disabled in CI)
app.config["SESSION_COOKIE_HTTPONLY"] = True  # Prevent JS access
app.config["SESSION_COOKIE_SAMESITE"] = "Lax"  # CSRF protection
app.config["PERMANENT_SESSION_LIFETIME"] = timedelta(days=7)  # Session expiry


# CORS Configuration - Secure origins list
def get_allowed_origins():
    """Get allowed CORS origins based on environment."""
    origins = [
        "http://localhost:5000",
        "http://localhost:5001",
        "http://127.0.0.1:5000",
        "http://127.0.0.1:5001",
    ]
    # Add Replit domains if configured
    if config.REPLIT_DEV_DOMAIN:
        origins.append(f"https://{config.REPLIT_DEV_DOMAIN}")
    # In CI, allow broader testing
    if config.IS_CI:
        origins.append("*")
    return origins


CORS(
    app,
    resources={
        r"/api/*": {
            "origins": get_allowed_origins(),
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
            "allow_headers": ["Content-Type", "Authorization", "X-API-Key"],
            "supports_credentials": True,
        }
    },
)

# Allow large credit report uploads (up to 20MB)
app.config["MAX_CONTENT_LENGTH"] = 20 * 1024 * 1024

# Track app start time for uptime reporting
app.config["START_TIME"] = datetime.now()

# Initialize performance monitoring middleware
request_timing_middleware(app)
print("‚úÖ Performance monitoring middleware initialized")

# Portal blueprint already registered above (line 76)

# Register staff portal blueprint for redesigned employee interface
from routes.staff import staff_portal as staff_portal_blueprint

app.register_blueprint(staff_portal_blueprint)
print("‚úÖ Staff portal blueprint registered")

# Simple in-memory rate limiting for login attempts
login_attempts: dict[str, dict[str, int | datetime]] = (
    {}
)  # {email: {'count': int, 'last_attempt': datetime}}

# Store received credit reports
credit_reports = []

# Track which analyses have been marked as delivered (in-memory flag)
delivered_cases = set()

# Register memory cleanup hook to prevent memory leaks
# Cleans up: login_attempts (1hr TTL), credit_reports (24hr TTL),
# delivered_cases (7day TTL), scan_sessions (24hr TTL)
register_cleanup_hook(app, login_attempts, credit_reports, delivered_cases)
app_logger.info("Memory cleanup hook registered")

# Initialize PDF generators
pdf_gen = LetterPDFGenerator()
section_pdf_gen = SectionPDFGenerator()

# Create required directories
os.makedirs("static/section_pdfs", exist_ok=True)
os.makedirs("static/generated_letters", exist_ok=True)
os.makedirs("static/logs", exist_ok=True)
os.makedirs("static/client_uploads", exist_ok=True)

# Initialize database
try:
    init_db()
    print("‚úÖ Database initialized successfully")

    # Migrate any existing plaintext passwords to encrypted format
    try:
        db = get_db()
        migrated = migrate_plaintext_to_encrypted(db, Client)
        if migrated > 0:
            print(f"‚úÖ Migrated {migrated} passwords to encrypted format")
        db.close()
    except Exception as me:
        print(f"‚ö†Ô∏è  Password migration check: {me}")
except Exception as e:
    print(f"‚ö†Ô∏è  Database initialization error: {e}")


def seed_ci_test_data():
    """Seed test data for CI/CD testing"""
    if os.getenv("CI") != "true":
        return
    db = get_db()
    try:
        existing = db.query(Staff).filter_by(email="test@example.com").first()
        if existing:
            db.close()
            return
        admin = Staff(
            email="test@example.com",
            password_hash=generate_password_hash("testpass123"),
            first_name="CI Test",
            last_name="Admin",
            role="admin",
            is_active=True,
        )
        db.add(admin)
        db.commit()
        client = Client(
            name="John Doe",
            first_name="John",
            last_name="Doe",
            email="johndoe@test.com",
            phone="555-123-4567",
        )
        db.add(client)
        db.commit()
        print("‚úÖ CI test data seeded")
    except Exception as e:
        print(f"‚ö†Ô∏è  CI test data seeding: {e}")
    finally:
        db.close()


try:
    seed_ci_test_data()
except Exception as e:
    print(f"‚ö†Ô∏è  CI seeding error: {e}")


def create_initial_admin():
    """Create initial admin account if no staff exists"""
    db = get_db()
    try:
        staff_count = db.query(Staff).count()
        if staff_count == 0:
            initial_password = "ChangeMe123!"
            admin = Staff(
                email="admin@brightpathascend.com",
                password_hash=generate_password_hash(initial_password),
                first_name="Admin",
                last_name="User",
                role="admin",
                is_active=True,
                force_password_change=True,
            )
            db.add(admin)
            db.commit()
            print("\n" + "=" * 60)
            print("üîê INITIAL ADMIN ACCOUNT CREATED")
            print("=" * 60)
            print(f"   Email:    admin@brightpathascend.com")
            print(f"   Password: {initial_password}")
            print("   ‚ö†Ô∏è  Please change this password immediately!")
            print("=" * 60 + "\n")
    except Exception as e:
        print(f"‚ö†Ô∏è  Admin account setup: {e}")
    finally:
        db.close()


try:
    create_initial_admin()
except Exception as e:
    print(f"‚ö†Ô∏è  Initial admin setup: {e}")


def require_staff(roles=None):
    """Decorator to require staff authentication and optional role check"""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if "staff_id" not in session:
                if request.is_json or request.path.startswith("/api/"):
                    return (
                        jsonify(
                            {
                                "success": False,
                                "error": "Session expired. Please log in again.",
                            }
                        ),
                        401,
                    )
                return redirect("/staff/login")

            if roles and session.get("staff_role") not in roles:
                if "admin" not in roles and session.get("staff_role") != "admin":
                    if request.is_json:
                        return jsonify({"error": "Insufficient permissions"}), 403
                    return (
                        render_template(
                            "error.html",
                            error="Access Denied",
                            message="You do not have permission to access this page.",
                        ),
                        403,
                    )

            db = get_db()
            try:
                staff = db.query(Staff).filter_by(id=session["staff_id"]).first()
                if staff:
                    g.staff_user = staff
                else:
                    session.clear()
                    if request.is_json:
                        return jsonify({"error": "Session expired"}), 401
                    return redirect("/staff/login")
            except:
                pass
            finally:
                db.close()

            return f(*args, **kwargs)

        return decorated_function

    return decorator


def require_api_key(scopes=None):
    """Decorator to require API key authentication for public API endpoints"""

    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            start_time = time.time()

            auth_header = request.headers.get("Authorization", "")
            if not auth_header:
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "API key required. Use Authorization: Bearer <your-api-key>",
                        }
                    ),
                    401,
                )

            service = get_api_access_service()
            api_key, error = service.validate_api_key(auth_header)

            if error:
                return jsonify({"success": False, "error": error}), 401

            if scopes:
                missing_scopes = [s for s in scopes if not api_key.has_scope(s)]
                if missing_scopes:
                    response_time = int((time.time() - start_time) * 1000)
                    service.log_request(
                        key_id=api_key.id,
                        endpoint=request.path,
                        method=request.method,
                        request_ip=request.remote_addr,
                        response_status=403,
                        response_time_ms=response_time,
                        error_message=f"Missing scopes: {missing_scopes}",
                    )
                    return (
                        jsonify(
                            {
                                "success": False,
                                "error": f"Insufficient permissions. Required scopes: {scopes}",
                            }
                        ),
                        403,
                    )

            allowed, rate_info = service.check_rate_limit(
                api_key.id, api_key.rate_limit_per_minute, api_key.rate_limit_per_day
            )

            if not allowed:
                response_time = int((time.time() - start_time) * 1000)
                service.log_request(
                    key_id=api_key.id,
                    endpoint=request.path,
                    method=request.method,
                    request_ip=request.remote_addr,
                    response_status=429,
                    response_time_ms=response_time,
                    error_message=rate_info.get("error", "Rate limit exceeded"),
                )
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": rate_info.get("error", "Rate limit exceeded"),
                            "rate_limit": rate_info,
                        }
                    ),
                    429,
                )

            g.api_key = api_key
            g.api_key_id = api_key.id
            g.rate_limit_info = rate_info

            try:
                response = f(*args, **kwargs)
                response_time = int((time.time() - start_time) * 1000)

                status_code = response[1] if isinstance(response, tuple) else 200

                service.log_request(
                    key_id=api_key.id,
                    endpoint=request.path,
                    method=request.method,
                    request_ip=request.remote_addr,
                    response_status=status_code,
                    response_time_ms=response_time,
                )

                return response
            except Exception as e:
                response_time = int((time.time() - start_time) * 1000)
                service.log_request(
                    key_id=api_key.id,
                    endpoint=request.path,
                    method=request.method,
                    request_ip=request.remote_addr,
                    response_status=500,
                    response_time_ms=response_time,
                    error_message=str(e),
                )
                raise

        return decorated_function

    return decorator


_whitelabel_config_cache: dict[str, Any] = {}
_whitelabel_cache_timestamps: dict[str, datetime] = {}
_WHITELABEL_CACHE_TTL = 300


def with_branding(f):
    """
    Decorator that injects white-label branding into template context.
    Detects subdomain/domain from request and loads appropriate config.
    Falls back to default Brightpath Ascend branding if no config found.
    Caches config lookups for performance.
    """

    @wraps(f)
    def decorated_function(*args, **kwargs):
        branding = None
        config = None

        try:
            host = request.host
            if host:
                host = host.lower().split(":")[0]

                cache_key = f"wl_host:{host}"
                cached_config = _get_whitelabel_cache(cache_key)

                if cached_config is not None:
                    if cached_config == "default":
                        branding = _get_default_whitelabel_branding()
                    else:
                        branding = (
                            cached_config.get_branding_dict()
                            if hasattr(cached_config, "get_branding_dict")
                            else cached_config
                        )
                        config = cached_config
                else:
                    db = get_db()
                    try:
                        service = get_whitelabel_config_service(db)
                        config = service.detect_config_from_host(host)

                        if config and config.is_active:
                            branding = config.get_branding_dict()
                            _set_whitelabel_cache(cache_key, config)
                        else:
                            branding = _get_default_whitelabel_branding()
                            _set_whitelabel_cache(cache_key, "default")
                    finally:
                        db.close()
        except Exception as e:
            print(f"Branding lookup error: {e}")
            branding = _get_default_whitelabel_branding()

        if branding is None:
            branding = _get_default_whitelabel_branding()

        g.whitelabel_config = config
        g.whitelabel_branding = branding

        return f(*args, **kwargs)

    return decorated_function


def _get_whitelabel_cache(key):
    """Get value from white-label cache if not expired"""
    if key not in _whitelabel_config_cache:
        return None

    timestamp = _whitelabel_cache_timestamps.get(key)
    if (
        timestamp
        and (datetime.utcnow() - timestamp).total_seconds() > _WHITELABEL_CACHE_TTL
    ):
        del _whitelabel_config_cache[key]
        del _whitelabel_cache_timestamps[key]
        return None

    return _whitelabel_config_cache.get(key)


def _set_whitelabel_cache(key, value):
    """Set value in white-label cache"""
    _whitelabel_config_cache[key] = value
    _whitelabel_cache_timestamps[key] = datetime.utcnow()


def _get_default_whitelabel_branding():
    """Return default Brightpath Ascend Group branding"""
    return {
        "organization_name": "Brightpath Ascend Group",
        "subdomain": None,
        "custom_domain": None,
        "logo_url": "/static/images/logo.png",
        "favicon_url": None,
        "primary_color": "#319795",
        "secondary_color": "#1a1a2e",
        "accent_color": "#84cc16",
        "header_bg_color": "#1a1a2e",
        "sidebar_bg_color": "#1a1a2e",
        "font_family": "'Inter', -apple-system, BlinkMacSystemFont, sans-serif",
        "font_family_key": "inter",
        "custom_css": None,
        "email_from_name": "Brightpath Ascend Group",
        "email_from_address": None,
        "company_address": None,
        "company_phone": None,
        "company_email": None,
        "footer_text": "¬© 2024 Brightpath Ascend Group. All rights reserved.",
        "terms_url": None,
        "privacy_url": None,
        "is_active": True,
    }


@app.context_processor
def inject_whitelabel_branding():
    """Inject white-label branding into all templates"""
    return {
        "whitelabel_config": getattr(g, "whitelabel_config", None),
        "whitelabel_branding": getattr(
            g, "whitelabel_branding", _get_default_whitelabel_branding()
        ),
    }


@app.before_request
def detect_tenant():
    """Middleware to detect tenant from subdomain or custom domain"""
    g.tenant = None
    g.tenant_branding = None

    try:
        host = request.host
        if not host:
            return

        db = get_db()
        try:
            service = get_white_label_service(db)
            tenant = service.detect_tenant_from_host(host)

            if tenant and tenant.is_active:
                g.tenant = tenant
                g.tenant_branding = tenant.get_branding_config()
            else:
                g.tenant_branding = service.get_default_branding()
        except Exception as e:
            print(f"Tenant detection error: {e}")
            g.tenant_branding = {
                "primary_color": "#319795",
                "secondary_color": "#1a1a2e",
                "accent_color": "#84cc16",
                "logo_url": "/static/images/logo.png",
                "favicon_url": None,
                "company_name": "Brightpath Ascend Group",
                "company_address": None,
                "company_phone": None,
                "company_email": None,
                "support_email": None,
                "terms_url": None,
                "privacy_url": None,
                "custom_css": None,
                "custom_js": None,
            }
        finally:
            db.close()
    except Exception as e:
        pass


@app.context_processor
def inject_tenant_branding():
    """Inject tenant branding into all templates"""
    return {
        "tenant": getattr(g, "tenant", None),
        "tenant_branding": getattr(
            g,
            "tenant_branding",
            {
                "primary_color": "#319795",
                "secondary_color": "#1a1a2e",
                "accent_color": "#84cc16",
                "logo_url": "/static/images/logo.png",
                "company_name": "Brightpath Ascend Group",
            },
        ),
    }


@app.context_processor
def inject_affirm_config():
    """Inject Affirm BNPL config into all templates"""
    from services.config import config

    return {
        "affirm_configured": config.is_configured("affirm"),
        "affirm_public_key": (
            config.AFFIRM_PUBLIC_KEY if config.is_configured("affirm") else None
        ),
    }


@app.route("/auth")
def auth_redirect():
    """Redirect to staff login page"""
    return redirect(url_for("staff_login"))


@app.route("/staff/login", methods=["GET", "POST"])
@limiter.limit(RATE_LIMITS["login"])  # Prevent brute force attacks
def staff_login():
    """Staff login page"""
    if request.method == "POST":
        email = request.form.get("email", "").strip().lower()
        password = request.form.get("password", "")
        user_ip = request.headers.get("X-Forwarded-For", request.remote_addr)

        if not email or not password:
            return render_template(
                "staff_login.html", error="Please enter email and password"
            )

        db = get_db()
        try:
            staff = db.query(Staff).filter_by(email=email).first()
            audit_service = get_audit_service(db)

            if not staff:
                audit_service.log_login(
                    user_id=None,
                    user_type="staff",
                    success=False,
                    ip=user_ip,
                    email=email,
                    failure_reason="User not found",
                )
                return render_template(
                    "staff_login.html", error="Invalid email or password", email=email
                )

            if not staff.is_active:
                audit_service.log_login(
                    user_id=staff.id,
                    user_type="staff",
                    success=False,
                    ip=user_ip,
                    email=email,
                    name=staff.full_name,
                    failure_reason="Account disabled",
                )
                return render_template(
                    "staff_login.html",
                    error="Account is disabled. Contact administrator.",
                    email=email,
                )

            if not check_password_hash(staff.password_hash, password):
                audit_service.log_login(
                    user_id=staff.id,
                    user_type="staff",
                    success=False,
                    ip=user_ip,
                    email=email,
                    name=staff.full_name,
                    failure_reason="Invalid password",
                )
                return render_template(
                    "staff_login.html", error="Invalid email or password", email=email
                )

            staff.last_login = datetime.utcnow()
            db.commit()

            session.permanent = True
            session["staff_id"] = staff.id
            session["staff_role"] = staff.role
            session["staff_name"] = staff.full_name
            session["staff_email"] = staff.email
            session["staff_initials"] = staff.initials

            audit_service.log_login(
                user_id=staff.id,
                user_type="staff",
                success=True,
                ip=user_ip,
                email=staff.email,
                name=staff.full_name,
            )

            if staff.force_password_change:
                return render_template("staff_login.html", force_change=True)

            return redirect("/dashboard")

        except Exception as e:
            print(f"Login error: {e}")
            return render_template(
                "staff_login.html", error="Login error. Please try again."
            )
        finally:
            db.close()

    if "staff_id" in session:
        return redirect("/dashboard")

    return render_template("staff_login.html")


@app.route("/staff/change-password", methods=["POST"])
def staff_change_password():
    """Handle forced password change"""
    if "staff_id" not in session:
        return redirect("/staff/login")

    new_password = request.form.get("new_password", "")
    confirm_password = request.form.get("confirm_password", "")

    if len(new_password) < 8:
        return render_template(
            "staff_login.html",
            force_change=True,
            error="Password must be at least 8 characters",
        )

    if new_password != confirm_password:
        return render_template(
            "staff_login.html", force_change=True, error="Passwords do not match"
        )

    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session["staff_id"]).first()
        if staff:
            staff.password_hash = generate_password_hash(new_password)
            staff.force_password_change = False
            staff.updated_at = datetime.utcnow()
            db.commit()
            return redirect("/dashboard")
    except Exception as e:
        print(f"Password change error: {e}")
        return render_template(
            "staff_login.html", force_change=True, error="Error updating password"
        )
    finally:
        db.close()

    return redirect("/staff/login")


@app.route("/staff/logout")
def staff_logout():
    """Staff logout"""
    staff_id = session.get("staff_id")
    staff_email = session.get("staff_email")
    staff_name = session.get("staff_name")

    if staff_id:
        try:
            audit_service = get_audit_service()
            audit_service.log_logout(
                user_id=staff_id, user_type="staff", email=staff_email, name=staff_name
            )
        except Exception as e:
            print(f"Logout audit error: {e}")

    session.pop("staff_id", None)
    session.pop("staff_role", None)
    session.pop("staff_name", None)
    session.pop("staff_email", None)
    session.pop("staff_initials", None)
    return redirect("/staff/login")


@app.route("/api/staff/login", methods=["POST"])
@limiter.limit(RATE_LIMITS["login"])  # Prevent brute force attacks
def api_staff_login():
    """API endpoint for staff login"""
    data = request.get_json() or {}
    email = sanitize_string(data.get("email", "")).strip().lower()
    password = data.get(
        "password", ""
    )  # Don't sanitize password - it needs to match hash
    user_ip = request.headers.get("X-Forwarded-For", request.remote_addr)

    if not email or not password:
        return jsonify({"success": False, "error": "Email and password required"}), 400

    db = get_db()
    try:
        staff = db.query(Staff).filter_by(email=email).first()
        audit_service = get_audit_service(db)

        if not staff:
            audit_service.log_login(
                user_id=None,
                user_type="staff",
                success=False,
                ip=user_ip,
                email=email,
                failure_reason="User not found",
            )
            log_login_failed(email, "User not found")
            return jsonify({"success": False, "error": "Invalid credentials"}), 401

        if not staff.is_active:
            audit_service.log_login(
                user_id=staff.id,
                user_type="staff",
                success=False,
                ip=user_ip,
                email=email,
                name=staff.full_name,
                failure_reason="Account disabled",
            )
            log_login_failed(email, "Account disabled")
            return jsonify({"success": False, "error": "Account disabled"}), 403

        if not check_password_hash(staff.password_hash, password):
            audit_service.log_login(
                user_id=staff.id,
                user_type="staff",
                success=False,
                ip=user_ip,
                email=email,
                name=staff.full_name,
                failure_reason="Invalid password",
            )
            log_login_failed(email, "Invalid password")
            return jsonify({"success": False, "error": "Invalid credentials"}), 401

        # Check if 2FA is enabled
        if staff.two_factor_enabled:
            two_fa_code = data.get("two_factor_code", "")
            device_token = request.cookies.get("2fa_device_token")
            trust_device = data.get("trust_device", False)

            # Import 2FA service
            from services.two_factor_service import get_two_factor_service

            two_fa_service = get_two_factor_service(db)

            # If no code provided, indicate 2FA is required
            if not two_fa_code:
                # Check if device is trusted
                if device_token and two_fa_service.is_device_trusted(
                    device_token, staff.trusted_devices or []
                ):
                    pass  # Device is trusted, proceed without code
                else:
                    return (
                        jsonify(
                            {
                                "success": False,
                                "requires_2fa": True,
                                "error": "Two-factor authentication required",
                                "staff_id": staff.id,  # For 2FA challenge endpoint
                            }
                        ),
                        200,
                    )  # Return 200 so frontend can handle gracefully

            # Verify 2FA code
            if two_fa_code:
                success, message, new_token = two_fa_service.verify_2fa_login(
                    staff,
                    two_fa_code,
                    device_token,
                    request.headers.get("User-Agent"),
                    user_ip,
                    trust_device,
                )
                if not success:
                    audit_service.log_login(
                        user_id=staff.id,
                        user_type="staff",
                        success=False,
                        ip=user_ip,
                        email=email,
                        name=staff.full_name,
                        failure_reason="Invalid 2FA code",
                    )
                    log_login_failed(email, "Invalid 2FA code")
                    return jsonify({"success": False, "error": message}), 401

        staff.last_login = datetime.utcnow()
        db.commit()

        session.permanent = True
        session["staff_id"] = staff.id
        session["staff_role"] = staff.role
        session["staff_name"] = staff.full_name
        session["staff_email"] = staff.email
        session["staff_initials"] = staff.initials

        audit_service.log_login(
            user_id=staff.id,
            user_type="staff",
            success=True,
            ip=user_ip,
            email=staff.email,
            name=staff.full_name,
        )
        log_login(staff.email, "staff")

        response_data = {
            "success": True,
            "staff": {
                "id": staff.id,
                "name": staff.full_name,
                "email": staff.email,
                "role": staff.role,
            },
            "force_password_change": staff.force_password_change,
        }

        response = jsonify(response_data)

        # Set trusted device cookie if 2FA was used with trust option
        if staff.two_factor_enabled and data.get("trust_device"):
            from services.two_factor_service import get_two_factor_service

            two_fa_service = get_two_factor_service(db)
            trusted_devices = staff.trusted_devices or []
            if trusted_devices:
                latest_device = trusted_devices[-1]
                if latest_device.get("token"):
                    response.set_cookie(
                        "2fa_device_token",
                        latest_device["token"],
                        max_age=30 * 24 * 60 * 60,  # 30 days
                        httponly=True,
                        secure=True,
                        samesite="Lax",
                    )

        return response
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# =============================================================================
# Two-Factor Authentication (2FA) API Endpoints
# =============================================================================


@app.route("/api/2fa/status", methods=["GET"])
@require_staff()
def api_2fa_status():
    """Get 2FA status for current staff member"""
    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session.get("staff_id")).first()
        if not staff:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        from services.two_factor_service import get_two_factor_service

        service = get_two_factor_service(db)
        status = service.get_2fa_status(staff)

        return jsonify({"success": True, **status})
    finally:
        db.close()


@app.route("/api/2fa/setup", methods=["POST"])
@require_staff()
def api_2fa_setup():
    """Start 2FA setup - generates secret and QR code"""
    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session.get("staff_id")).first()
        if not staff:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        if staff.two_factor_enabled:
            return jsonify({"success": False, "error": "2FA is already enabled"}), 400

        data = request.get_json() or {}
        method = data.get("method", "totp")

        from services.two_factor_service import get_two_factor_service

        service = get_two_factor_service(db)
        setup_data = service.setup_2fa_for_staff(staff, method)

        return jsonify(
            {
                "success": True,
                "secret": setup_data["secret"],
                "qr_code": setup_data["qr_code"],
                "backup_codes": setup_data["backup_codes"],
                "method": setup_data["method"],
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/2fa/verify", methods=["POST"])
@require_staff()
def api_2fa_verify():
    """Verify TOTP code and enable 2FA"""
    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session.get("staff_id")).first()
        if not staff:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        data = request.get_json() or {}
        code = data.get("code", "")

        if not code:
            return (
                jsonify({"success": False, "error": "Verification code required"}),
                400,
            )

        from services.two_factor_service import get_two_factor_service

        service = get_two_factor_service(db)
        success, message = service.verify_and_enable_2fa(staff, code)

        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "error": message}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/2fa/disable", methods=["POST"])
@require_staff()
def api_2fa_disable():
    """Disable 2FA (requires current code)"""
    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session.get("staff_id")).first()
        if not staff:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        data = request.get_json() or {}
        code = data.get("code", "")
        use_backup = data.get("use_backup", False)

        if not code:
            return (
                jsonify({"success": False, "error": "Verification code required"}),
                400,
            )

        from services.two_factor_service import get_two_factor_service

        service = get_two_factor_service(db)
        success, message = service.disable_2fa(staff, code, use_backup)

        if success:
            # Clear device cookie
            response = jsonify({"success": True, "message": message})
            response.delete_cookie("2fa_device_token")
            return response
        else:
            return jsonify({"success": False, "error": message}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/2fa/backup-codes", methods=["POST"])
@require_staff()
def api_2fa_regenerate_backup_codes():
    """Regenerate backup codes (requires current TOTP code)"""
    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session.get("staff_id")).first()
        if not staff:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        data = request.get_json() or {}
        code = data.get("code", "")

        if not code:
            return (
                jsonify({"success": False, "error": "Verification code required"}),
                400,
            )

        from services.two_factor_service import get_two_factor_service

        service = get_two_factor_service(db)
        success, new_codes, message = service.regenerate_backup_codes(staff, code)

        if success:
            return jsonify(
                {"success": True, "backup_codes": new_codes, "message": message}
            )
        else:
            return jsonify({"success": False, "error": message}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/2fa/devices", methods=["GET"])
@require_staff()
def api_2fa_list_devices():
    """List trusted devices"""
    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session.get("staff_id")).first()
        if not staff:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        from services.two_factor_service import get_two_factor_service

        service = get_two_factor_service(db)

        # Remove expired devices and return
        devices = service.remove_expired_devices(staff.trusted_devices or [])

        # Sanitize output (don't expose full token)
        sanitized = []
        for d in devices:
            sanitized.append(
                {
                    "token_prefix": d.get("token", "")[:8] + "...",
                    "user_agent": d.get("user_agent", "")[:100],
                    "ip_address": d.get("ip_address"),
                    "created_at": d.get("created_at"),
                    "expires_at": d.get("expires_at"),
                    "last_used": d.get("last_used"),
                }
            )

        return jsonify({"success": True, "devices": sanitized})
    finally:
        db.close()


@app.route("/api/2fa/devices/revoke-all", methods=["POST"])
@require_staff()
def api_2fa_revoke_all_devices():
    """Revoke all trusted devices"""
    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=session.get("staff_id")).first()
        if not staff:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        staff.trusted_devices = []
        db.commit()

        response = jsonify({"success": True, "message": "All devices revoked"})
        response.delete_cookie("2fa_device_token")
        return response
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/staff")
@require_staff(roles=["admin"])
def dashboard_staff():
    """Staff management page in old dashboard style"""
    db = get_db()
    try:
        staff_members = db.query(Staff).order_by(Staff.created_at.desc()).all()

        # Calculate stats
        stats = {
            "total": len(staff_members),
            "admins": sum(1 for s in staff_members if s.role == "admin"),
            "attorneys": sum(1 for s in staff_members if s.role == "attorney"),
            "paralegals": sum(1 for s in staff_members if s.role == "paralegal"),
        }

        return render_template(
            "staff_management.html",
            staff_members=staff_members,
            stats=stats,
            active_page="staff",
        )
    finally:
        db.close()


@app.route("/api/staff/add", methods=["POST"])
@require_staff(roles=["admin"])
def api_staff_add():
    """Add a new staff member"""
    email = request.form.get("email", "").strip().lower()
    first_name = request.form.get("first_name", "").strip()
    last_name = request.form.get("last_name", "").strip()
    role = request.form.get("role", "viewer")
    password = request.form.get("password", "")

    if not email or not password:
        return redirect(
            "/staff/admin?section=team&error=Email and password are required"
        )

    if role not in STAFF_ROLES:
        return redirect("/staff/admin?section=team&error=Invalid role selected")

    db = get_db()
    try:
        existing = db.query(Staff).filter_by(email=email).first()
        if existing:
            return redirect("/staff/admin?section=team&error=Email already exists")

        new_staff = Staff(
            email=email,
            password_hash=generate_password_hash(password),
            first_name=first_name,
            last_name=last_name,
            role=role,
            is_active=True,
            force_password_change=True,
            created_by_id=session.get("staff_id"),
        )
        db.add(new_staff)
        db.commit()

        return redirect(
            f"/staff/admin?section=team&message=Staff member {first_name} {last_name} added successfully"
        )
    except Exception as e:
        db.rollback()
        return redirect(f"/staff/admin?section=team&error=Error adding staff: {str(e)}")
    finally:
        db.close()


@app.route("/api/staff/update", methods=["POST"])
@require_staff(roles=["admin"])
def api_staff_update():
    """Update a staff member"""
    staff_id = request.form.get("staff_id")
    email = request.form.get("email", "").strip().lower()
    first_name = request.form.get("first_name", "").strip()
    last_name = request.form.get("last_name", "").strip()
    role = request.form.get("role", "viewer")
    is_active = request.form.get("is_active", "true") == "true"

    if not staff_id or not email:
        return redirect("/staff/admin?section=team&error=Missing required fields")

    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=int(staff_id)).first()
        if not staff:
            return redirect("/staff/admin?section=team&error=Staff member not found")

        existing = (
            db.query(Staff)
            .filter(Staff.email == email, Staff.id != int(staff_id))
            .first()
        )
        if existing:
            return redirect("/staff/admin?section=team&error=Email already in use")

        staff.email = email
        staff.first_name = first_name
        staff.last_name = last_name
        staff.role = role
        staff.is_active = is_active
        staff.updated_at = datetime.utcnow()
        db.commit()

        return redirect(
            f"/staff/admin?section=team&message=Staff member updated successfully"
        )
    except Exception as e:
        db.rollback()
        return redirect(
            f"/staff/admin?section=team&error=Error updating staff: {str(e)}"
        )
    finally:
        db.close()


@app.route("/api/staff/reset-password", methods=["POST"])
@require_staff(roles=["admin"])
def api_staff_reset_password():
    """Reset a staff member's password"""
    data = request.get_json() or {}
    staff_id = data.get("staff_id")

    if not staff_id:
        return jsonify({"success": False, "error": "Staff ID required"}), 400

    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=int(staff_id)).first()
        if not staff:
            return jsonify({"success": False, "error": "Staff member not found"}), 404

        temp_password = secrets.token_urlsafe(12)
        staff.password_hash = generate_password_hash(temp_password)
        staff.force_password_change = True
        staff.updated_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "temp_password": temp_password,
                "message": "Password reset successfully",
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/staff/toggle-status", methods=["POST"])
@require_staff(roles=["admin"])
def api_staff_toggle_status():
    """Toggle a staff member's active status"""
    data = request.get_json() or {}
    staff_id = data.get("staff_id")

    if not staff_id:
        return jsonify({"success": False, "error": "Staff ID required"}), 400

    if int(staff_id) == session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Cannot disable your own account"}),
            400,
        )

    db = get_db()
    try:
        staff = db.query(Staff).filter_by(id=int(staff_id)).first()
        if not staff:
            return jsonify({"success": False, "error": "Staff member not found"}), 404

        staff.is_active = not staff.is_active
        staff.updated_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "is_active": staff.is_active,
                "message": f'Staff member {"enabled" if staff.is_active else "disabled"}',
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/mockups/")
@app.route("/mockups/<path:filename>")
def serve_mockups(filename=None):
    """Serve portal mockup files for demos"""
    import os

    from flask import send_from_directory

    mockups_dir = os.path.join(os.path.dirname(__file__), "docs", "mockups")
    if filename is None:
        # List available mockups
        return """<!DOCTYPE html>
<html><head><title>Portal Mockups</title>
<style>body{font-family:system-ui;max-width:600px;margin:50px auto;padding:20px}
a{display:block;padding:15px;margin:10px 0;background:#7c3aed;color:white;text-decoration:none;border-radius:8px;text-align:center}
a:hover{background:#5b21b6}h1{color:#1f2937}</style></head>
<body><h1>Portal Mockups</h1>
<a href="/mockups/portal_login.html">Login Page</a>
<a href="/mockups/portal_dashboard.html">Dashboard</a>
<a href="/mockups/portal_documents.html">Documents Upload</a>
<p style="margin-top:30px;color:#6b7280;text-align:center">These are interactive HTML mockups for client onboarding</p>
</body></html>"""
    return send_from_directory(mockups_dir, filename)


# =============================================================================
# HEALTH CHECK ENDPOINTS (for monitoring and container orchestration)
# =============================================================================


@app.route("/health")
def health_check():
    """
    Application health check
    Returns application health status with memory and CPU metrics
    ---
    tags:
      - Health
    responses:
      200:
        description: Application is healthy
        content:
          application/json:
            schema:
              type: object
              properties:
                status:
                  type: string
                  example: healthy
                timestamp:
                  type: string
                version:
                  type: string
                uptime_seconds:
                  type: number
                memory:
                  type: object
                cpu_percent:
                  type: number
    """
    import os

    import psutil

    process = psutil.Process(os.getpid())
    memory_info = process.memory_info()

    return jsonify(
        {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "version": os.environ.get("APP_VERSION", "1.0.0"),
            "uptime_seconds": (
                datetime.now() - app.config.get("START_TIME", datetime.now())
            ).total_seconds(),
            "memory": {
                "rss_mb": round(memory_info.rss / 1024 / 1024, 2),
                "vms_mb": round(memory_info.vms / 1024 / 1024, 2),
            },
            "cpu_percent": process.cpu_percent(),
        }
    )


@app.route("/ready")
def readiness_check():
    """
    Readiness check
    Verifies database and cache connectivity for load balancer routing
    ---
    tags:
      - Health
    responses:
      200:
        description: All dependencies are ready
      503:
        description: One or more dependencies are not ready
    """
    checks = {
        "database": {"status": "unknown", "latency_ms": None},
    }
    all_ready = True

    # Database check
    try:
        import time

        from sqlalchemy import text

        start = time.time()
        db = get_db()
        db.execute(text("SELECT 1"))
        db.close()
        latency = (time.time() - start) * 1000
        checks["database"] = {"status": "connected", "latency_ms": round(latency, 2)}
    except Exception as e:
        checks["database"] = {"status": "disconnected", "error": str(e)}
        all_ready = False

    # Cache check (if available)
    try:
        from services.performance_service import app_cache

        cache_stats = app_cache.get_stats()
        checks["cache"] = {
            "status": "available",
            "entries": cache_stats.get("total_entries", 0),
            "hit_rate": cache_stats.get("hit_rate", 0),
        }
    except Exception:
        checks["cache"] = {"status": "not_configured"}

    status_code = 200 if all_ready else 503
    return (
        jsonify(
            {
                "status": "ready" if all_ready else "not_ready",
                "timestamp": datetime.now().isoformat(),
                "checks": checks,
            }
        ),
        status_code,
    )


@app.route("/health/live")
def liveness_check():
    """
    Liveness probe
    Minimal check for Kubernetes/container orchestration
    ---
    tags:
      - Health
    responses:
      200:
        description: Application is alive
        content:
          text/plain:
            schema:
              type: string
              example: OK
    """
    return "OK", 200


@app.route("/health/shutdown")
def shutdown_status():
    """
    Shutdown status check
    Returns current shutdown manager status for monitoring
    ---
    tags:
      - Health
    responses:
      200:
        description: Shutdown status information
        content:
          application/json:
            schema:
              type: object
              properties:
                shutdown_in_progress:
                  type: boolean
                active_requests:
                  type: integer
                registered_handlers:
                  type: array
    """
    from services.graceful_shutdown_service import get_shutdown_manager

    manager = get_shutdown_manager()
    status = manager.get_status()

    # Return 503 if shutdown is in progress
    status_code = 503 if status["shutdown_in_progress"] else 200
    return jsonify(status), status_code


@app.route("/health/pool")
def health_pool():
    """
    Database connection pool health and metrics
    Returns detailed pool statistics for monitoring
    ---
    tags:
      - Health
    responses:
      200:
        description: Pool health status
        content:
          application/json:
            schema:
              type: object
              properties:
                pool_size:
                  type: integer
                checked_out:
                  type: integer
                usage_percent:
                  type: number
    """
    from services.database_pool_service import get_pool_monitor

    monitor = get_pool_monitor()
    if monitor is None:
        return jsonify({
            "status": "unavailable",
            "error": "Pool monitoring not initialized"
        }), 503

    metrics = monitor.get_metrics()
    history = monitor.get_history(limit=10)

    # Determine health status
    if metrics.usage_percent >= 90:
        status = "critical"
        status_code = 503
    elif metrics.usage_percent >= 80:
        status = "warning"
        status_code = 200
    else:
        status = "healthy"
        status_code = 200

    return jsonify({
        "status": status,
        "metrics": metrics.to_dict(),
        "history": history,
        "thresholds": {
            "warning": 80,
            "critical": 90
        }
    }), status_code


@app.route("/metrics")
def prometheus_metrics():
    """
    Prometheus-compatible metrics endpoint
    Returns metrics in Prometheus text format for monitoring systems
    ---
    tags:
      - Health
    responses:
      200:
        description: Prometheus metrics
        content:
          text/plain:
            schema:
              type: string
    """
    import os

    import psutil

    process = psutil.Process(os.getpid())
    memory_info = process.memory_info()

    # Get database connection pool stats if available
    db_pool_size = 0
    db_pool_checked_out = 0
    try:
        from database import engine

        if hasattr(engine, "pool"):
            db_pool_size = engine.pool.size()
            db_pool_checked_out = engine.pool.checkedout()
    except Exception:
        pass

    # Get request count from app if tracked
    request_count = app.config.get("REQUEST_COUNT", 0)
    error_count = app.config.get("ERROR_COUNT", 0)

    # Calculate uptime
    start_time = app.config.get("START_TIME", datetime.now())
    uptime_seconds = (datetime.now() - start_time).total_seconds()

    # Build Prometheus format output
    metrics = []

    # Process metrics
    metrics.append("# HELP process_resident_memory_bytes Resident memory size in bytes")
    metrics.append("# TYPE process_resident_memory_bytes gauge")
    metrics.append(f"process_resident_memory_bytes {memory_info.rss}")

    metrics.append("# HELP process_virtual_memory_bytes Virtual memory size in bytes")
    metrics.append("# TYPE process_virtual_memory_bytes gauge")
    metrics.append(f"process_virtual_memory_bytes {memory_info.vms}")

    metrics.append("# HELP process_cpu_percent CPU usage percentage")
    metrics.append("# TYPE process_cpu_percent gauge")
    metrics.append(f"process_cpu_percent {process.cpu_percent()}")

    metrics.append("# HELP process_open_fds Number of open file descriptors")
    metrics.append("# TYPE process_open_fds gauge")
    try:
        metrics.append(f"process_open_fds {process.num_fds()}")
    except Exception:
        metrics.append("process_open_fds 0")

    # Application metrics
    metrics.append("# HELP app_uptime_seconds Application uptime in seconds")
    metrics.append("# TYPE app_uptime_seconds counter")
    metrics.append(f"app_uptime_seconds {uptime_seconds:.2f}")

    metrics.append("# HELP app_requests_total Total number of requests")
    metrics.append("# TYPE app_requests_total counter")
    metrics.append(f"app_requests_total {request_count}")

    metrics.append("# HELP app_errors_total Total number of errors")
    metrics.append("# TYPE app_errors_total counter")
    metrics.append(f"app_errors_total {error_count}")

    # Database pool metrics (enhanced)
    try:
        from services.database_pool_service import get_pool_monitor
        pool_monitor = get_pool_monitor()
        if pool_monitor:
            pool_metrics = pool_monitor.get_metrics()
            metrics.append("# HELP db_pool_size Database connection pool size")
            metrics.append("# TYPE db_pool_size gauge")
            metrics.append(f"db_pool_size {pool_metrics.pool_size}")

            metrics.append("# HELP db_pool_checked_out Database connections currently in use")
            metrics.append("# TYPE db_pool_checked_out gauge")
            metrics.append(f"db_pool_checked_out {pool_metrics.checked_out}")

            metrics.append("# HELP db_pool_overflow Database overflow connections")
            metrics.append("# TYPE db_pool_overflow gauge")
            metrics.append(f"db_pool_overflow {pool_metrics.overflow}")

            metrics.append("# HELP db_pool_usage_percent Database pool usage percentage")
            metrics.append("# TYPE db_pool_usage_percent gauge")
            metrics.append(f"db_pool_usage_percent {pool_metrics.usage_percent:.2f}")

            metrics.append("# HELP db_pool_checkouts_total Total connection checkouts")
            metrics.append("# TYPE db_pool_checkouts_total counter")
            metrics.append(f"db_pool_checkouts_total {pool_metrics.total_checkouts}")

            metrics.append("# HELP db_pool_invalidations_total Total connection invalidations")
            metrics.append("# TYPE db_pool_invalidations_total counter")
            metrics.append(f"db_pool_invalidations_total {pool_metrics.total_invalidations}")

            metrics.append("# HELP db_pool_timeouts_total Total pool timeout errors")
            metrics.append("# TYPE db_pool_timeouts_total counter")
            metrics.append(f"db_pool_timeouts_total {pool_metrics.total_timeouts}")
        else:
            # Fallback to basic metrics
            metrics.append("# HELP db_pool_size Database connection pool size")
            metrics.append("# TYPE db_pool_size gauge")
            metrics.append(f"db_pool_size {db_pool_size}")

            metrics.append("# HELP db_pool_checked_out Database connections currently in use")
            metrics.append("# TYPE db_pool_checked_out gauge")
            metrics.append(f"db_pool_checked_out {db_pool_checked_out}")
    except Exception:
        # Fallback to basic metrics
        metrics.append("# HELP db_pool_size Database connection pool size")
        metrics.append("# TYPE db_pool_size gauge")
        metrics.append(f"db_pool_size {db_pool_size}")

        metrics.append("# HELP db_pool_checked_out Database connections currently in use")
        metrics.append("# TYPE db_pool_checked_out gauge")
        metrics.append(f"db_pool_checked_out {db_pool_checked_out}")

    # Rate limit monitoring metrics
    try:
        from services.rate_limit_monitor_service import get_rate_limit_monitor

        rl_monitor = get_rate_limit_monitor()
        if rl_monitor:
            rl_stats = rl_monitor.get_stats()
            metrics.append("# HELP rate_limit_violations_total Total rate limit violations")
            metrics.append("# TYPE rate_limit_violations_total counter")
            metrics.append(f"rate_limit_violations_total {rl_stats['total_violations']}")

            metrics.append("# HELP rate_limit_violations_window Violations in current window")
            metrics.append("# TYPE rate_limit_violations_window gauge")
            metrics.append(f"rate_limit_violations_window {rl_stats['violations_in_window']}")

            metrics.append("# HELP rate_limit_blocked_ips Currently blocked IPs")
            metrics.append("# TYPE rate_limit_blocked_ips gauge")
            metrics.append(f"rate_limit_blocked_ips {rl_stats['active_blocks']}")

            metrics.append("# HELP rate_limit_blocks_total Total IPs blocked")
            metrics.append("# TYPE rate_limit_blocks_total counter")
            metrics.append(f"rate_limit_blocks_total {rl_stats['total_blocks']}")

            metrics.append("# HELP rate_limit_alerts_total Total alerts triggered")
            metrics.append("# TYPE rate_limit_alerts_total counter")
            metrics.append(f"rate_limit_alerts_total {rl_stats['total_alerts']}")

            metrics.append("# HELP rate_limit_unique_ips Unique IPs with violations")
            metrics.append("# TYPE rate_limit_unique_ips gauge")
            metrics.append(f"rate_limit_unique_ips {rl_stats['unique_ips']}")
    except Exception:
        pass

    # Cache metrics
    try:
        from services.performance_service import app_cache

        cache_stats = app_cache.get_stats()
        metrics.append("# HELP cache_entries_total Total entries in application cache")
        metrics.append("# TYPE cache_entries_total gauge")
        metrics.append(f"cache_entries_total {cache_stats.get('total_entries', 0)}")

        metrics.append("# HELP cache_hits_total Total cache hits")
        metrics.append("# TYPE cache_hits_total counter")
        metrics.append(f"cache_hits_total {cache_stats.get('hit_count', 0)}")

        metrics.append("# HELP cache_misses_total Total cache misses")
        metrics.append("# TYPE cache_misses_total counter")
        metrics.append(f"cache_misses_total {cache_stats.get('miss_count', 0)}")

        metrics.append("# HELP cache_expired_total Total expired entries cleaned up")
        metrics.append("# TYPE cache_expired_total counter")
        metrics.append(f"cache_expired_total {cache_stats.get('expired_count', 0)}")

        metrics.append("# HELP cache_memory_bytes Estimated cache memory usage in bytes")
        metrics.append("# TYPE cache_memory_bytes gauge")
        metrics.append(f"cache_memory_bytes {int(cache_stats.get('memory_estimate_kb', 0) * 1024)}")
    except Exception:
        pass

    # Build response
    response = make_response("\n".join(metrics) + "\n")
    response.headers["Content-Type"] = "text/plain; version=0.0.4; charset=utf-8"
    return response


@app.route("/health/ratelimit")
def health_ratelimit():
    """
    Rate limit monitoring health and metrics
    Returns violation statistics, blocked IPs, and alert status
    ---
    tags:
      - Health
    responses:
      200:
        description: Rate limit health status
        content:
          application/json:
            schema:
              type: object
              properties:
                status:
                  type: string
                total_violations:
                  type: integer
                active_blocks:
                  type: integer
    """
    from services.rate_limit_monitor_service import get_rate_limit_monitor

    monitor = get_rate_limit_monitor()
    if monitor is None:
        return jsonify({
            "status": "unavailable",
            "error": "Rate limit monitoring not initialized"
        }), 503

    stats = monitor.get_stats()
    blocked_ips = monitor.get_blocked_ips()
    top_offenders = monitor.get_top_offenders(limit=5)
    recent_violations = monitor.get_recent_violations(limit=10)

    # Determine health status based on violation rate
    if stats["active_blocks"] >= 10:
        status = "critical"
        status_code = 503
    elif stats["violations_in_window"] >= stats["alert_threshold"]:
        status = "warning"
        status_code = 200
    else:
        status = "healthy"
        status_code = 200

    return jsonify({
        "status": status,
        "stats": stats,
        "blocked_ips": blocked_ips,
        "top_offenders": top_offenders,
        "recent_violations": recent_violations,
    }), status_code


# =============================================================================
# LEGAL PAGES (Privacy Policy, Terms of Service)
# =============================================================================


@app.route("/legal/privacy")
@app.route("/privacy-policy")
@app.route("/privacy")
def privacy_policy():
    """Privacy Policy page."""
    return render_template("legal/privacy_policy.html")


@app.route("/legal/terms")
@app.route("/terms-of-service")
@app.route("/terms")
@app.route("/tos")
def terms_of_service():
    """Terms of Service page."""
    return render_template("legal/terms_of_service.html")


@app.route("/")
def home():
    """Home page - shows form or status"""
    return """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCRA Analysis - Brightpath Ascend</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 600px;
            margin: 40px auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 { color: #2c3e50; text-align: center; margin-bottom: 10px; }
        .subtitle { color: #7f8c8d; text-align: center; margin-bottom: 30px; font-size: 14px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; color: #34495e; font-weight: 600; margin-bottom: 8px; font-size: 14px; }
        .required { color: #e74c3c; }
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 14px;
        }
        textarea { min-height: 120px; font-family: monospace; }
        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        button:disabled { background: #95a5a6; }
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            display: none;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ FCRA Analysis System</h1>
        <p class="subtitle">Brightpath Ascend Group</p>

        <form id="form">
            <div class="form-group">
                <label for="clientName">CLIENT NAME <span class="required">*</span></label>
                <input type="text" id="clientName" required>
            </div>

            <div class="form-group">
                <label for="cmmContactId">CMM CONTACT ID <span class="required">*</span></label>
                <input type="text" id="cmmContactId" required>
            </div>

            <div class="form-group">
                <label>CREDIT PROVIDER <span class="required">*</span></label>
                <select id="creditProvider" required>
                    <option value="">-- Select Provider --</option>
                    <option value="IdentityIQ.com">IdentityIQ.com</option>
                    <option value="MyScoreIQ.com">MyScoreIQ.com</option>
                    <option value="SmartCredit.com">SmartCredit.com</option>
                    <option value="MyFreeScoreNow.com">MyFreeScoreNow.com</option>
                    <option value="HighScoreNow.com">HighScoreNow.com</option>
                    <option value="IdentityClub.com">IdentityClub.com</option>
                    <option value="PrivacyGuard.com">PrivacyGuard.com</option>
                    <option value="IDClub.com">IDClub.com</option>
                    <option value="MyThreeScores.com">MyThreeScores.com</option>
                    <option value="MyScore750.com">MyScore750.com</option>
                    <option value="CreditHeroScore.com">CreditHeroScore.com</option>
                    <option value="CFILifePlan.com">CFILifePlan.com</option>
                </select>
            </div>

            <div class="form-group">
                <label>DISPUTE ROUND <span class="required">*</span></label>
                <select id="disputeRound" required>
                    <option value="1">Round 1 - Initial Dispute (New Client)</option>
                    <option value="2">Round 2 - MOV Request / Follow-up</option>
                    <option value="3">Round 3 - Pre-Litigation Warning</option>
                    <option value="4">Round 4 - Final Demand / Intent to Sue</option>
                </select>
                <small style="color: #7f8c8d; display: block; margin-top: 5px;">
                    <strong>Round 1:</strong> New client - full analysis + initial strong RLPP letters<br>
                    <strong>Round 2+:</strong> Existing client - escalated letters based on bureau responses
                </small>
            </div>

            <div id="existingClientFields" style="display: none;">
                <div class="form-group">
                    <label>PREVIOUS DISPUTE LETTER(S)</label>
                    <textarea id="previousLetters" placeholder="Paste the dispute letters you previously sent to the bureaus..."></textarea>
                    <small style="color: #7f8c8d; display: block; margin-top: 5px;">
                        Copy/paste the actual letters you sent in previous rounds
                    </small>
                </div>

                <div class="form-group">
                    <label>BUREAU RESPONSE(S)</label>
                    <textarea id="bureauResponses" placeholder="Paste bureau responses here, or type 'NO RESPONSE' if they ignored you..."></textarea>
                    <small style="color: #7f8c8d; display: block; margin-top: 5px;">
                        Include all responses from Experian, TransUnion, and Equifax
                    </small>
                </div>

                <div class="form-group">
                    <label>DISPUTE TIMELINE</label>
                    <input type="text" id="disputeTimeline" placeholder="e.g., Sent 10/15/25, Response 11/1/25">
                    <small style="color: #7f8c8d; display: block; margin-top: 5px;">
                        Dates sent and received for violation tracking
                    </small>
                </div>
            </div>

<div class="form-group">
    <label>ANALYSIS MODE <span class="required">*</span></label>
    <select id="analysisMode" required>
        <option value="manual">Manual Review (Stop at verification checkpoint)</option>
        <option value="auto">Automatic (Generate complete report immediately)</option>
    </select>
    <small style="color: #7f8c8d; display: block; margin-top: 5px;">
        <strong>Manual:</strong> Review violations before client report (recommended for new cases)<br>
        <strong>Automatic:</strong> Generate everything in one pass (faster, for clear cases)
    </small>
</div>
            <div class="form-group">
                <label>CREDIT REPORT HTML <span class="required">*</span></label>
                <textarea id="creditReportHTML" required></textarea>
            </div>

            <button type="submit">üöÄ ANALYZE</button>
            <div id="status" class="status"></div>
        </form>
    </div>

    <script>
        // Show/hide existing client fields based on dispute round
        document.getElementById('disputeRound').addEventListener('change', function() {
            const round = parseInt(this.value);
            const existingFields = document.getElementById('existingClientFields');
            
            if (round > 1) {
                existingFields.style.display = 'block';
            } else {
                existingFields.style.display = 'none';
            }
        });

        document.getElementById('form').addEventListener('submit', async function(e) {
            e.preventDefault();
            const btn = e.target.querySelector('button');
            const status = document.getElementById('status');

            btn.disabled = true;
            btn.textContent = '‚è≥ Sending...';

            try {
                const disputeRound = parseInt(document.getElementById('disputeRound').value);
                const payload = {
                    clientName: document.getElementById('clientName').value,
                    cmmContactId: document.getElementById('cmmContactId').value,
                    creditProvider: document.getElementById('creditProvider').value,
                    disputeRound: disputeRound,
                    analysisMode: document.getElementById('analysisMode').value,
                    creditReportHTML: document.getElementById('creditReportHTML').value
                };

                // Add existing client data for Round 2+
                if (disputeRound > 1) {
                    payload.previousLetters = document.getElementById('previousLetters').value;
                    payload.bureauResponses = document.getElementById('bureauResponses').value;
                    payload.disputeTimeline = document.getElementById('disputeTimeline').value;
                }

                const response = await fetch('/webhook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.success) {
                    status.className = 'status success';
                    status.innerHTML = '‚úÖ Success! Report received for ' + result.client;
                    status.style.display = 'block';
                    document.getElementById('form').reset();
                    document.getElementById('existingClientFields').style.display = 'none';
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                status.className = 'status error';
                status.innerHTML = '‚ùå Error: ' + error.message;
                status.style.display = 'block';
            } finally {
                btn.disabled = false;
                btn.textContent = 'üöÄ ANALYZE';
            }
        });
    </script>
</body>
</html>"""


def clean_credit_report_html(html):
    """Strip unnecessary HTML to reduce size - but keep content intact"""
    import re

    from bs4 import BeautifulSoup

    print(f"üìä Original size: {len(html):,} characters")

    # Remove inline styles
    html = re.sub(r'style="[^"]*"', "", html)
    # Remove script tags
    html = re.sub(r"<script[^>]*>.*?</script>", "", html, flags=re.DOTALL)
    # Remove comments
    html = re.sub(r"<!--.*?-->", "", html, flags=re.DOTALL)
    # Remove base64 images
    html = re.sub(r'data:image/[^;]+;base64,[^"\']+', "", html)

    # Extract just the text content
    soup = BeautifulSoup(html, "html.parser")
    text = soup.get_text(separator="\n", strip=True)

    # If cleaning destroys everything (>99% reduction), return original HTML instead
    if len(text) < len(html) * 0.01:
        print(
            f"‚ö†Ô∏è  Aggressive cleaning destroyed content! Using original HTML instead."
        )
        text = html

    print(f"‚úÇÔ∏è Cleaned size: {len(text):,} characters")
    print(
        f"üí∞ Saved: {max(0, len(html) - len(text)):,} characters ({max(0, 100 - (len(text)/len(html)*100)):.1f}% reduction)"
    )

    return text


# Section markers for splitting credit reports (enhanced patterns)
SECTION_MARKERS = {
    "tradelines": [
        "ACCOUNTS",
        "TRADELINES",
        "REVOLVING ACCOUNTS",
        "INSTALLMENT ACCOUNTS",
        "OPEN ACCOUNTS",
        "CLOSED ACCOUNTS",
    ],
    "collections": ["COLLECTION", "COLLECTIONS"],
    "public_records": [
        "PUBLIC RECORD",
        "PUBLIC RECORDS",
        "BANKRUPTCIES",
        "JUDGMENTS",
        "TAX LIENS",
    ],
    "inquiries": [
        "INQUIRIES",
        "CREDIT INQUIRIES",
        "REGULAR INQUIRIES",
        "HARD INQUIRIES",
    ],
}


def split_report_into_sections(text: str) -> dict[str, str]:
    """Split cleaned report text into logical sections based on common headings"""
    sections: dict[str, list[str]] = {k: [] for k in SECTION_MARKERS.keys()}
    current_key = None

    if not text:
        return {}

    lines = text.splitlines()
    for line in lines:
        upper = line.strip().upper()

        # Check if this line looks like a section heading
        new_key = None
        for key, markers in SECTION_MARKERS.items():
            if any(m in upper for m in markers):
                new_key = key
                break

        if new_key:
            current_key = new_key
            sections[current_key].append(line)
        elif current_key:
            sections[current_key].append(line)

    # Join and drop empty sections
    finalized = {}
    for key, lines_list in sections.items():
        joined = "\n".join(lines_list).strip()
        if joined:
            finalized[key] = joined

    print("üìö split_report_into_sections:", {k: len(v) for k, v in finalized.items()})
    return finalized


def merge_standing(standings: list[Any]) -> dict[str, Any]:
    """Merge multiple standing blocks (OR booleans, SUM counts, concatenate strings)"""
    if not standings:
        return {
            "has_concrete_harm": False,
            "concrete_harm_type": "",
            "harm_details": "",
            "has_dissemination": False,
            "dissemination_details": "",
            "has_causation": False,
            "causation_details": "",
            "denial_letters_count": 0,
            "adverse_action_notices_count": 0,
        }

    has_concrete_harm = False
    concrete_harm_type: list[str] = []
    harm_details: list[str] = []
    has_dissemination = False
    dissemination_details: list[str] = []
    has_causation = False
    causation_details: list[str] = []
    denial_letters_count = 0
    adverse_action_notices_count = 0

    for s in standings:
        if not s:
            continue
        has_concrete_harm = has_concrete_harm or s.get("has_concrete_harm", False)
        has_dissemination = has_dissemination or s.get("has_dissemination", False)
        has_causation = has_causation or s.get("has_causation", False)
        if s.get("concrete_harm_type"):
            concrete_harm_type.append(str(s.get("concrete_harm_type")))
        if s.get("harm_details"):
            harm_details.append(str(s.get("harm_details")))
        if s.get("dissemination_details"):
            dissemination_details.append(str(s.get("dissemination_details")))
        if s.get("causation_details"):
            causation_details.append(str(s.get("causation_details")))
        denial_letters_count += int(s.get("denial_letters_count", 0) or 0)
        adverse_action_notices_count += int(
            s.get("adverse_action_notices_count", 0) or 0
        )

    return {
        "has_concrete_harm": has_concrete_harm,
        "concrete_harm_type": " | ".join(concrete_harm_type),
        "harm_details": "\n\n".join(harm_details),
        "has_dissemination": has_dissemination,
        "dissemination_details": "\n\n".join(dissemination_details),
        "has_causation": has_causation,
        "causation_details": "\n\n".join(causation_details),
        "denial_letters_count": denial_letters_count,
        "adverse_action_notices_count": adverse_action_notices_count,
    }


def merge_actual_damages(damages_list: list[Any]) -> dict[str, Any]:
    """Merge multiple actual_damages blocks by summing numeric fields"""
    credit_denials_amount: float = 0
    higher_interest_amount: float = 0
    credit_monitoring_amount: float = 0
    time_stress_amount: float = 0
    other_actual_amount: float = 0
    notes: list[str] = []
    for d in damages_list:
        if not d:
            continue
        credit_denials_amount += float(d.get("credit_denials_amount", 0) or 0)
        higher_interest_amount += float(d.get("higher_interest_amount", 0) or 0)
        credit_monitoring_amount += float(d.get("credit_monitoring_amount", 0) or 0)
        time_stress_amount += float(d.get("time_stress_amount", 0) or 0)
        other_actual_amount += float(d.get("other_actual_amount", 0) or 0)
        if d.get("notes"):
            notes.append(str(d["notes"]))
    return {
        "credit_denials_amount": credit_denials_amount,
        "higher_interest_amount": higher_interest_amount,
        "credit_monitoring_amount": credit_monitoring_amount,
        "time_stress_amount": time_stress_amount,
        "other_actual_amount": other_actual_amount,
        "notes": "\n\n".join(notes),
    }


def merge_litigation_data(section_results: list[Any]) -> dict[str, Any]:
    """Merge litigation_data from multiple sections into one"""
    all_violations: list[Any] = []
    standings: list[Any] = []
    damages_blocks: list[Any] = []
    for r in section_results:
        if not r:
            continue
        all_violations.extend(r.get("violations", []) or [])
        standings.append(r.get("standing", {}) or {})
        damages_blocks.append(r.get("actual_damages", {}) or {})
    merged = {
        "violations": all_violations,
        "standing": merge_standing(standings),
        "actual_damages": merge_actual_damages(damages_blocks),
    }
    print(f"üß© merge_litigation_data: {len(all_violations)} total violations merged")
    return merged


def run_stage1_for_all_sections(
    client_name,
    cmm_id,
    provider,
    credit_report_text,
    analysis_mode="manual",
    dispute_round=1,
    previous_letters="",
    bureau_responses="",
    dispute_timeline="",
):
    """Split report into sections and run Stage 1 analysis per section, merge results"""
    import time

    sections = split_report_into_sections(credit_report_text)
    if not sections:
        return {
            "success": False,
            "error": "Could not detect any recognizable sections in report",
        }

    all_section_results = []
    combined_analysis_parts = []
    total_tokens = 0
    total_cost = 0.0
    any_cache_read = False

    for section_name, section_text in sections.items():
        print(
            f"\nüîç Stage 1 analysis for section: {section_name} ({len(section_text):,} chars)"
        )
        result = analyze_with_claude(
            client_name=client_name,
            cmm_id=cmm_id,
            provider=provider,
            credit_report_html=section_text,
            analysis_mode=analysis_mode,
            dispute_round=dispute_round,
            previous_letters=previous_letters,
            bureau_responses=bureau_responses,
            dispute_timeline=dispute_timeline,
            stage=1,
        )

        if not result.get("success"):
            print(f"‚ùå Section {section_name} failed: {result.get('error')}")
            all_section_results.append(
                {
                    "section_name": section_name,
                    "analysis": "",
                    "raw_litigation_data": None,
                    "error": result.get("error"),
                }
            )
            continue

        analysis_text = result.get("analysis", "") or ""
        litigation_data = extract_litigation_data(analysis_text)
        combined_analysis_parts.append(
            f"\n\n{'='*80}\nSECTION: {section_name.upper()}\n{'='*80}\n\n{analysis_text}"
        )
        all_section_results.append(
            {
                "section_name": section_name,
                "analysis": analysis_text,
                "raw_litigation_data": litigation_data,
            }
        )
        total_tokens += int(result.get("tokens_used", 0) or 0)
        total_cost += float(result.get("cost", 0.0) or 0.0)
        any_cache_read = any_cache_read or bool(result.get("cache_read", False))
        time.sleep(1)  # Rate limit protection

    parsed_litigation_blocks = [
        r["raw_litigation_data"]
        for r in all_section_results
        if r.get("raw_litigation_data")
    ]
    if not parsed_litigation_blocks:
        return {
            "success": False,
            "error": "No valid litigation_data extracted from any section",
            "combined_analysis": "\n\n".join(combined_analysis_parts),
            "per_section": all_section_results,
            "tokens_used": total_tokens,
            "cost": total_cost,
            "cache_read": any_cache_read,
        }

    merged_litigation = merge_litigation_data(parsed_litigation_blocks)
    return {
        "success": True,
        "combined_analysis": "\n\n".join(combined_analysis_parts),
        "litigation_data": merged_litigation,
        "per_section": all_section_results,
        "tokens_used": total_tokens,
        "cost": total_cost,
        "cache_read": any_cache_read,
    }


def truncate_for_token_limit(text, max_tokens_for_report=140_000):
    """
    Hard cap the report size so the full prompt stays under Anthropic's 200k token limit.
    Rough approximation: ~4 characters per token for English text.
    """
    if not text:
        return text

    approx_tokens = len(text) / 4.0
    if approx_tokens <= max_tokens_for_report:
        return text

    ratio = max_tokens_for_report / approx_tokens
    new_len = int(len(text) * ratio)
    truncated = text[:new_len]

    print(
        f"‚ö†Ô∏è truncate_for_token_limit: report truncated for token limit: "
        f"{len(text):,} chars (~{approx_tokens:,.0f} tokens) -> "
        f"{len(truncated):,} chars (~{len(truncated)/4.0:,.0f} tokens)"
    )

    return truncated


def analyze_with_claude(
    client_name,
    cmm_id,
    provider,
    credit_report_html,
    analysis_mode="manual",
    dispute_round=1,
    previous_letters="",
    bureau_responses="",
    dispute_timeline="",
    stage=1,
    stage_1_results="",
):
    """Send credit report to Claude for FCRA analysis - TWO STAGE WORKFLOW

    Stage 1: Violations/Standing/Damages analysis only (small prompt, fits token limit)
    Stage 2: Client documents/letters generation (uses Stage 1 results)
    """
    try:
        # CRITICAL: Clean & truncate HTML for Stage 1 to stay under 200k token limit
        if stage == 1:
            print(f"\nüßπ Cleaning credit report HTML to fit token limits...")
            credit_report_html = clean_credit_report_html(credit_report_html)
            print(f"üîí Truncating to token limit...")
            credit_report_html = truncate_for_token_limit(
                credit_report_html, max_tokens_for_report=140_000
            )

        # Define round_names globally for both stages
        round_names = {
            1: "Round 1 - Initial Dispute (RLPP Strong Language)",
            2: "Round 2 - MOV Request / Follow-up",
            3: "Round 3 - Pre-Litigation Warning",
            4: "Round 4 - Final Demand / Intent to Sue",
        }

        if stage == 1:
            # STAGE 1: COMPREHENSIVE violation detection prompt - finds ALL substantiated violations
            prompt = """You are an elite FCRA litigation attorney. Your task is COMPREHENSIVE violation detection.

**CRITICAL: Find EVERY substantiated violation - be thorough and aggressive in searching but only report REAL violations you can prove from the data. DO NOT fabricate or invent violations.**

===========================================================================
MATERIALITY STANDARD - CRITICAL FOR ALL VIOLATION TYPES
===========================================================================

**A difference is a violation ONLY IF it is MATERIAL (affects credit decisions):**
- Minor formatting differences are NOT violations (e.g., "10/2024" vs "10/01/2024")
- Trailing zeros or equivalent representations are NOT violations (e.g., "$1,500" vs "$1500.00")
- Date differences within the same month due to reporting cycles are NOT violations
- Only report violations where the contradiction is SUBSTANTIVE and PROVABLE

**SUBSTANTIVE means:**
- Balance difference of $100+ OR 10%+ of the balance amount
- Date difference of 30+ days that affects FCRA timeline calculations
- Status contradiction (e.g., "Open" vs "Closed", "Paid" vs "Charge-off")
- Missing required data element (DOLP on derogatory, account number, etc.)

===========================================================================
PARSING THE CLEANED CREDIT REPORT - HOW TO EXTRACT DATA
===========================================================================

The credit report has been cleaned to plain text. Look for these patterns:

**BUREAU SECTIONS:** Look for lines containing "TransUnion", "Experian", or "Equifax" as section headers.
The same account will appear in each bureau's section with potentially different data.

**COMMON FIELD PATTERNS (use these to extract data):**
- Date Last Active: Look for "Date Last Active:" or "Last Activity:" followed by MM/DD/YYYY or MM/YYYY
- Last Reported: Look for "Last Reported:" or "Reported:" followed by date
- Balance: Look for "Balance:" or "Current Balance:" followed by dollar amount (may have $ or commas)
- Payment Status: Look for "Payment Status:" or "Status:" followed by text like "Current", "Charge-off", "Paid"
- Date Opened: Look for "Date Opened:" or "Opened:" followed by date
- Date of Last Payment (DOLP): Look for "Date of Last Payment:" or "Last Payment:" followed by date or blank
- Account Number: Look for "Account #:" or "Account Number:" followed by partial/masked number

**MATCHING ACCOUNTS ACROSS BUREAUS:**
1. Find the account name/creditor (e.g., "CAPITAL ONE", "MIDLAND CREDIT")
2. Locate that creditor in each bureau section (TransUnion, Experian, Equifax)
3. Extract the same fields from each bureau's version
4. Compare values - only MATERIAL differences are violations

===========================================================================
VIOLATION TYPE CHECKLIST - CHECK EVERY SINGLE ONE WITH EXPLICIT DETECTION STEPS:
===========================================================================

**TYPE 1: BUREAU CONTRADICTIONS** (MOST VALUABLE - Check EVERY account across all 3 bureaus)
MATERIALITY THRESHOLD: Only report if difference is SUBSTANTIVE (affects credit decisions)
DETECTION STEPS:
1. For EACH account, extract: Date Last Active, Last Reported, Balance, Payment Status from TU/EX/EQ
2. Compare Date Last Active between TU vs EX vs EQ - MATERIAL difference (30+ days) = violation
3. Compare Last Reported dates - MATERIAL difference (30+ days) = violation  
4. Compare Balance amounts - MATERIAL difference ($100+ or 10%+) = violation
5. Compare Payment Status text - CONTRADICTORY status = violation (not just wording differences)
6. Check if account appears on some bureaus but NOT others = ghost account violation

Each MATERIAL difference found = separate violation entry with bureau_violations array showing each bureau's data

**TYPE 2: FUTURE DATE REPORTING** (PER SE UNREASONABLE - Check EVERY date field)
DETECTION STEPS:
1. Today's date is the analysis date - any date AFTER today is a future date
2. Scan ALL Date Last Active fields - is any date in the future?
3. Scan ALL Last Reported fields - is any date in the future?
4. Scan ALL Date Opened fields - is any date in the future?
5. Future dates are IMPOSSIBLE and constitute automatic willful violation

**TYPE 3: DUPLICATE ACCOUNTS**
DETECTION STEPS:
1. List all account numbers in the report
2. Check for exact duplicates (same account number twice)
3. Check for near-duplicates (same creditor, similar amounts, same dates)
4. Each duplicate = Metro 2 violation + ¬ß1681e(b)

**TYPE 4: MISSING DATE OF LAST PAYMENT (CUSHMAN VIOLATIONS)**
DETECTION STEPS:
1. Find ALL accounts with negative status (charge-off, collection, delinquent)
2. For each, check: Is "Date of Last Payment:" or "Last Payment:" present with an actual date?
3. If DOLP is blank/missing/"Not Reported" on derogatory account = Cushman violation
4. Per Cushman v. TransUnion, 115 F.3d 220: furnishers must maintain tangible proof

**TYPE 5: DISPUTE NOTATION WITHOUT RESOLUTION**
DETECTION STEPS:
1. Search for "Consumer disputes" or "Item disputed" or "Disputed" notations
2. For each disputed account, check: Is negative information still present?
3. If disputed AND still negative = failed reinvestigation under ¬ß1681i(a)(1)(A)

**TYPE 6: PAYMENT HISTORY CONTRADICTIONS**
MATERIALITY THRESHOLD: Status and history must actually contradict (not just incomplete data)
DETECTION STEPS:
1. Read Payment Status field (e.g., "Past due 30 days", "Current")
2. Read Payment History pattern (e.g., "CCCCC111CC" or grid with late markers)
3. Does status match pattern? "Current" status + recent late markers (1,2,3) = contradiction
4. Does pattern match status? All "C" pattern + "Past due" status = contradiction

**TYPE 7: STALE/RE-AGED ACCOUNTS**
DETECTION STEPS:
1. Find Date Opened and Date Last Active for each account
2. Calculate: Is Date Last Active implausibly recent for old accounts?
3. Check: Has the 7-year reporting period from Date of First Delinquency passed?
4. Re-aging (making old debt appear new) = violation

**TYPE 8: BALANCE DISCREPANCIES**
MATERIALITY THRESHOLD: Non-zero balance on closed/paid account is always material
DETECTION STEPS:
1. Check Account Status - is it "Closed" or "Paid" or "Paid/Closed"?
2. If closed/paid, check Balance - is it $0 or blank?
3. Closed/paid account with non-zero balance = violation
4. Compare balance across bureaus - MATERIAL difference ($100+ or 10%+) = violation

**TYPE 9: ACCOUNT STATUS CONTRADICTIONS**
DETECTION STEPS:
1. For each account, extract Status from TU/EX/EQ
2. Compare: "Open" vs "Closed" across bureaus = violation
3. Compare: "Paid" vs "Charge-off" across bureaus = violation
4. Note: "Current" vs "Pays as Agreed" are equivalent - NOT a violation

**TYPE 10: INQUIRY VIOLATIONS**
DETECTION STEPS:
1. List all hard inquiries with dates and creditor names
2. Check for same creditor pulling multiple times within 14 days (shopping exception exists for auto/mortgage)
3. Check for inquiries without apparent authorization (no new account opened)
4. Check for inquiry date anomalies (future dates, impossible dates)

**TYPE 11: MIXED FILE VIOLATIONS**
DETECTION STEPS:
1. Look for accounts with unfamiliar creditor names
2. Check for accounts with addresses not matching consumer's known addresses
3. Check for accounts with different name variations that suggest wrong person
4. Any account not belonging to consumer = mixed file violation

**TYPE 12: FURNISHER REPORTING FAILURES**
MATERIALITY THRESHOLD: Only SUBSTANTIVE differences in furnisher data
DETECTION STEPS:
1. Same creditor, same account number - compare data across all 3 bureaus
2. MATERIAL difference in what the furnisher reported to different bureaus = ¬ß1681s-2(a) violation
3. Document exactly what was reported to each bureau

===========================================================================
METRO 2¬Æ FORMAT VIOLATIONS (2025 CRRG Compliance)
===========================================================================

**TYPE 13: METRO 2¬Æ ACCOUNT STATUS CODE VIOLATIONS**
DETECTION STEPS:
1. Check for invalid status codes not in valid range (05, 11, 13, 61-65, 71, 78, 80, 82-89, 93-97)
2. Check status vs payment history consistency:
   - Status "Current" (11) cannot have delinquent payment pattern (1,2,3,4,5,6)
   - Status "Charge-off" (82) requires delinquent history, not all current (0/C)
   - Status "Collection" (80) must show derogatory history
3. Check for impossible status transitions (e.g., 11‚Üí82 without payment deterioration)
4. Each inconsistency = Metro 2¬Æ format violation + ¬ß1681e(b) + ¬ß1681s-2(a)

**TYPE 14: METRO 2¬Æ PAYMENT HISTORY PATTERN VIOLATIONS**
DETECTION STEPS:
1. Valid payment codes: 0/blank (current), 1-6 (late), B, D, E only
2. Check for invalid characters in payment pattern (X, ?, -, etc.)
3. Payment pattern length should match account age (1 character per month)
4. Pattern must be chronologically consistent (can't have late‚Üícurrent‚Üílate‚Üícurrent cycling)
5. "E" (zero balance current) only valid if account shows zero balance
6. Pattern showing late after charge-off date = improper continued reporting

**TYPE 15: METRO 2¬Æ SPECIAL COMMENT CODE VIOLATIONS**
DETECTION STEPS:
1. Check for REQUIRED but MISSING special comments:
   - Bankruptcy accounts MUST have appropriate bankruptcy code (DA, DB, DC, DD, etc.)
   - Disputed accounts MUST have "Consumer disputes" or code "XB" notation
   - Fraud/ID theft MUST have ID theft block notation
   - Paid collections should have "Paid collection" notation
2. Check for CONFLICTING special comments:
   - Cannot have "Paid in full" AND derogatory status simultaneously without "was" qualifier
   - Cannot have "Current" notation with collection/charge-off status
3. Check for OUTDATED special comments:
   - Disaster codes (XA-XH) have expiration requirements per 2025 rules
   - SCRA codes (XJ-XL) must match active duty dates

**TYPE 16: METRO 2¬Æ DOFD (DATE OF FIRST DELINQUENCY) VIOLATIONS**
DETECTION STEPS (per CRRG 2025 DOFD Hierarchy):
1. DOFD must be preserved when account transfers to collection:
   - Original creditor's DOFD must carry forward to debt buyer/collector
   - New DOFD = re-aging violation (federal offense)
2. DOFD cannot be later than first 30-day delinquency in payment history
3. DOFD triggers 7-year reporting limit (7.5 years for some states)
4. Check: Current date - DOFD > 7 years = obsolete item still reporting
5. Collection/charge-off without any DOFD = Metro 2¬Æ format violation
6. DOFD that changes/resets between reports = willful re-aging

**TYPE 17: METRO 2¬Æ 2025 COMPLIANCE REQUIREMENT VIOLATIONS**
2025-SPECIFIC DETECTION STEPS:
1. **Enhanced Bankruptcy Notation**: Bankruptcy accounts must include:
   - Correct status code (83-87)
   - Discharge date when applicable
   - Proper disposition notation
2. **Disaster Code Updates (COVID/Natural Disasters)**:
   - XA (Natural disaster) / XB (Declared disaster) codes
   - Must include start/end dates per 2025 requirements
   - Cannot report delinquency during active accommodation
3. **SCRA Military Protections**:
   - XJ (Military duty) must include deployment dates
   - Interest rate caps enforced (6% max)
   - Cannot report negative during active duty
4. **Forbearance/Deferral Reporting (Post-COVID)**:
   - XR (Forbearance) code required
   - Account cannot show delinquent during approved forbearance
   - End of forbearance date must be documented
5. **Medical Debt Reporting (2025 Updates)**:
   - Medical collections under $500 should not be reported (2024+ rule)
   - Paid medical debt must be removed within 7 days
   - Medical debt in payment plan cannot be reported to collections

===========================================================================
STANDING ANALYSIS (TransUnion LLC v. Ramirez, 141 S. Ct. 2190)
===========================================================================

**ELEMENT 1: DISSEMINATION (Score 1-3)**
- List EVERY hard inquiry with date and creditor name
- Each inquiry during inaccurate reporting = dissemination evidence
- 3+ inquiries with inaccurate info = STRONG dissemination

**ELEMENT 2: CONCRETE HARM (Score 1-4)**
- Credit scores in FAIR/POOR range (below 680) = suppression harm
- Calculate: Estimated score WITHOUT violations vs actual score
- Interest rate differential: Each 20 points = 0.5% rate increase
- Annual harm = rate differential √ó total balances √ó years
- 4 = Documented denial or >$2K harm; 3 = Score suppression <680; 2 = Minor harm; 1 = Speculative

**ELEMENT 3: CAUSATION (Score 1-3)**
- "But for" the inaccuracy, would harm have occurred?
- Temporal proximity: Did inquiries happen during inaccurate reporting?
- Direct link between specific violation and specific harm

**STANDING SCORE = Element1 + Element2 + Element3 (max 10)**
- Circuit adjustment: 2nd Circuit -2, 9th Circuit -1
- 8-10 = STRONG; 5-7 = MODERATE; 1-4 = WEAK

===========================================================================
WILLFULNESS ASSESSMENT (Safeco Insurance Co. v. Burr)
===========================================================================

Score each category:
1. Direct Knowledge (0-4): Major bureaus/banks have compliance programs
2. Pattern (0-5): Same violation on multiple accounts or consumers
3. Awareness (0-4): Prior complaints, settlements, consent orders
4. Recklessness (0-3): Automated responses, no real investigation

TOTAL: ___/16 (13+ = definite willful; 9-12 = likely willful; 5-8 = mixed)

===========================================================================
OUTPUT FORMAT (REQUIRED):
===========================================================================

After your analysis, output this JSON block. Use bureau_violations array to track each bureau separately:

<LITIGATION_DATA>
{
  "violations": [
    {
      "account_name": "OPENSKY CBNK",
      "violation_type": "Bureau Contradiction - Different Dates",
      "bureau_violations": [
        {"bureau": "TransUnion", "data_reported": "Date Last Active: 10/06/2025", "fcra_section": "¬ß1681e(b)"},
        {"bureau": "Experian", "data_reported": "Date Last Active: 11/30/2022", "fcra_section": "¬ß1681e(b)"}
      ],
      "description": "3-year date discrepancy between bureaus",
      "is_willful": true,
      "willfulness_indicators": "Future date is per se unreasonable"
    },
    {
      "account_name": "CAPITAL ONE",
      "violation_type": "Future Date Reporting",
      "bureau_violations": [
        {"bureau": "TransUnion", "data_reported": "Date Last Active: 12/15/2025", "fcra_section": "¬ß1681e(b)"}
      ],
      "description": "Future date reporting - date after today is impossible",
      "is_willful": true,
      "willfulness_indicators": "Future dates cannot be verified and are per se unreasonable"
    },
    {
      "account_name": "MIDLAND CREDIT",
      "violation_type": "Missing Date of Last Payment (Cushman)",
      "bureau_violations": [
        {"bureau": "Equifax", "data_reported": "DOLP: Not Reported, Status: Charge-off", "fcra_section": "¬ß1681s-2(a)"}
      ],
      "description": "Charge-off account lacks required Date of Last Payment",
      "is_willful": false,
      "willfulness_indicators": "Negligent failure to maintain records per Cushman v. TransUnion"
    },
    {
      "account_name": "PORTFOLIO RECOVERY",
      "violation_type": "Metro 2¬Æ Account Status/Payment Mismatch",
      "bureau_violations": [
        {"bureau": "TransUnion", "data_reported": "Status: 80 (Collection), Payment History: 000000000000 (all current)", "fcra_section": "¬ß1681s-2(a)", "metro2_violation": true, "crrg_reference": "CRRG 4.2.11"}
      ],
      "description": "Collection status (80) conflicts with all-current payment history - Metro 2¬Æ format violation per CRRG 2025",
      "is_willful": true,
      "willfulness_indicators": "Metro 2¬Æ compliance is mandatory for all furnishers; format violations indicate systemic reporting failures"
    },
    {
      "account_name": "LVNV FUNDING",
      "violation_type": "Metro 2¬Æ DOFD Re-aging Violation",
      "bureau_violations": [
        {"bureau": "Experian", "data_reported": "DOFD: 03/2023 (collection opened 06/2024), Original Account DOFD: 09/2019", "fcra_section": "¬ß1681s-2(a)", "metro2_violation": true, "crrg_reference": "CRRG 6.1 DOFD Hierarchy"}
      ],
      "description": "Debt collector reset DOFD from original 09/2019 to 03/2023 - willful re-aging extends 7-year reporting beyond legal limit",
      "is_willful": true,
      "willfulness_indicators": "DOFD re-aging is per se willful violation; extends consumer harm beyond statutory limit"
    }
  ],
  "standing": {
    "has_concrete_harm": true,
    "concrete_harm_type": "Credit Score Suppression / Higher Interest",
    "harm_details": "Scores 592-617 (Fair range) suppressed 80-120 points. 5 creditor inquiries during inaccurate reporting. Estimated $2,400-3,600 annual harm from rate differential.",
    "has_dissemination": true,
    "dissemination_details": "ACURA OF DEN 04/05/2024, CITIBANK 01/03/2025, CONTINENTAL FINANCE 06/24/2024, MACYS 01/26/2024, TBOM 11/30/2023 - all accessed during violation period",
    "has_causation": true,
    "causation_details": "But for violations, scores would be 686-726 (Good range). Client would qualify for prime lending. Automotive inquiry without new account suggests denial.",
    "denial_letters_count": 0,
    "adverse_action_notices_count": 0
  },
  "actual_damages": {
    "credit_denials_amount": 0,
    "higher_interest_amount": 2400,
    "credit_monitoring_amount": 0,
    "time_stress_amount": 1000,
    "other_actual_amount": 0,
    "notes": "Score suppression 80-120 pts = 8-12% higher rates. $25K balances √ó 10% differential = $2,500/yr. 40+ hours monitoring at $25/hr = $1,000"
  }
}
</LITIGATION_DATA>

**CRITICAL RULES:**
1. ACCURACY OVER QUANTITY - Find real violations but NEVER fabricate. Only report violations you can prove from the actual data.
2. Apply MATERIALITY STANDARD - Minor differences, formatting variations, and equivalent representations are NOT violations.
3. Use bureau_violations array to track EACH bureau's data separately for cross-bureau violations.
4. Provide SPECIFIC dates, amounts, account names - no placeholders or guesses.
5. Standing score should reflect actual harm (subprime scores = concrete harm).
6. Dollar amounts as numbers only (no $ signs).
7. Output JSON block at the very end.

===========================================================================
NO VIOLATIONS FOUND - ACCEPTABLE OUTCOME
===========================================================================

**If after thorough search you find NO substantiated violations, output an empty violations array:**

<LITIGATION_DATA>
{
  "violations": [],
  "standing": {
    "has_concrete_harm": false,
    "concrete_harm_type": "None identified",
    "harm_details": "No substantiated FCRA violations found in credit report. All data appears consistent across bureaus.",
    "has_dissemination": false,
    "dissemination_details": "No inaccurate information was disseminated.",
    "has_causation": false,
    "causation_details": "No causal link between credit reporting and harm.",
    "denial_letters_count": 0,
    "adverse_action_notices_count": 0
  },
  "actual_damages": {
    "credit_denials_amount": 0,
    "higher_interest_amount": 0,
    "credit_monitoring_amount": 0,
    "time_stress_amount": 0,
    "other_actual_amount": 0,
    "notes": "No violations identified - no damages calculation applicable."
  }
}
</LITIGATION_DATA>

**An empty violations array is acceptable and preferred if no PROVABLE violations exist.**
**Do NOT invent violations to fill the array - this destroys legal credibility.**"""
        else:
            # STAGE 2: Use comprehensive FCRA v2.6 + RLPP prompt
            print("\nüî® Loading comprehensive FCRA v2.6 + RLPP prompt...")
            loader = get_prompt_loader()
            prompt = loader.build_comprehensive_stage2_prompt(
                dispute_round=dispute_round
            )

            if not prompt:
                return {
                    "success": False,
                    "error": "Failed to load comprehensive prompt templates",
                }

        # Stage 2 needs round_names variable
        if stage != 1:
            round_names = {
                1: "Round 1 - Initial Dispute (RLPP Strong Language)",
                2: "Round 2 - MOV Request / Follow-up",
                3: "Round 3 - Pre-Litigation Warning",
                4: "Round 4 - Final Demand / Intent to Sue",
            }

        super_prompt = prompt

        # Stage 2 needs additional context in system prompt
        if stage != 1:
            super_prompt += (
                """

You have Stage 1 analysis results. Now generate the client-facing documents:

PART 5: CLIENT-FACING REPORT (40-50 pages)
- Executive Summary
- Detailed violation analysis
- Standing assessment
- Damages calculation
- Legal strategy & case strength

PART 6: DISPUTE LETTERS
- Round """
                + str(dispute_round)
                + """ letter with RLPP language
- Statutory citations
- Violation documentation
- Proof of willfulness

PART 7: MOV REQUEST (if applicable)
- Method of Verification request
- Bureau-specific requirements
- Deadline enforcement

Output the complete client-facing documents."""
            )

        # For Stage 1, build dispute context and user message
        if stage == 1:
            round_names = {
                1: "Round 1 - Initial Dispute (RLPP Strong Language)",
                2: "Round 2 - MOV Request / Follow-up",
                3: "Round 3 - Pre-Litigation Warning",
                4: "Round 4 - Final Demand / Intent to Sue",
            }

            dispute_context = ""
            if dispute_round > 1 and (previous_letters or bureau_responses):
                dispute_context = f"""

PREVIOUS DISPUTE CONTEXT:
Timeline: {dispute_timeline if dispute_timeline else 'Not provided'}
Previous Letters: {previous_letters if previous_letters else 'Not provided'}
Bureau Responses: {bureau_responses if bureau_responses else 'NO RESPONSE - Possible ¬ß611(a)(7) violation'}
"""

            user_message = f"""
üö® STAGE 1: VIOLATIONS & DAMAGES ANALYSIS

CLIENT: {client_name} (CMM ID: {cmm_id})
Provider: {provider}
Dispute Round: {round_names.get(dispute_round, 'Round ' + str(dispute_round))}

{dispute_context}

CREDIT REPORT:
{credit_report_html}

TASK: Analyze ONLY for violations, standing, and damages.
Output JSON at end with violations, standing, actual_damages.
NO client reports, NO letters - just the analysis data.
"""
        else:
            # Stage 2: Generate comprehensive 107-page litigation package
            user_message = f"""
üö® STAGE 2: GENERATE COMPREHENSIVE 107-PAGE LITIGATION PACKAGE

**CLIENT INFORMATION:**
- Name: {client_name}
- CMM ID: {cmm_id}
- Provider: {provider}
- Dispute Round: {dispute_round}

**STAGE 1 ANALYSIS RESULTS (USE THIS DATA):**
{stage_1_results}

**YOUR TASK:**
Generate complete client-facing litigation package with ALL PARTS (0-5):
- Part 0-3: Forensic analysis (use Stage 1 data from above)
- Part 4: Formal dispute letters (extract real violations from Stage 1)
- Part 5: MOV requests (where applicable)

Use RLPP aggressive language appropriate for Round {dispute_round}.
Include scissor markers (‚úÇÔ∏è) around each letter for easy extraction.
Total output: 80-120 pages, litigation-ready format.

CRITICAL: Use ACTUAL violations and account data from Stage 1 results above.
NO templates or placeholders. Extract real account names, bureaus, violations.
"""

        # Call Claude API
        print(f"\nü§ñ Sending to Claude API for analysis...")
        print(f"   Stage: {stage}")
        print(f"   Analysis mode: {analysis_mode if stage == 1 else 'auto (Stage 2)'}")
        print(f"   Prompt size: {len(super_prompt):,} characters")
        print(
            f"   Report size: {len(credit_report_html):,} characters"
            if stage == 1
            else ""
        )

        import time

        start_time = time.time()

        # Normalize prompts to ensure cache consistency (strip whitespace)
        normalized_super_prompt = super_prompt.strip()
        normalized_user_message = user_message.strip()

        # Token logging for visibility
        approx_prompt_tokens = (
            len(normalized_super_prompt) + len(normalized_user_message)
        ) / 4.0
        print(f"üìè Approx prompt tokens before API call: ~{approx_prompt_tokens:,.0f}")

        try:
            message = client.messages.create(
                model="claude-opus-4-5-20251101",  # Highest quality for comprehensive analysis
                max_tokens=50000,
                temperature=0,
                timeout=900.0,
                system=[
                    {
                        "type": "text",
                        "text": normalized_super_prompt,
                        "cache_control": {"type": "ephemeral"},
                    }
                ],
                messages=[{"role": "user", "content": normalized_user_message}],
            )
        except Exception as api_err:
            error_msg = f"Claude API Error: {str(api_err)}"
            print(f"‚ùå {error_msg}")
            return {"success": False, "error": error_msg}

        elapsed_time = time.time() - start_time
        print(f"‚è±Ô∏è  API call completed in {elapsed_time:.1f} seconds")

        # Extract token usage and calculate cost savings (guard against errors)
        usage = getattr(message, "usage", None)
        if usage:
            # Cost per million tokens (Anthropic pricing for Claude Sonnet 4)
            INPUT_COST_PER_MTOK = 3.00  # $3 per million input tokens
            CACHED_INPUT_COST_PER_MTOK = (
                0.30  # $0.30 per million cached tokens (90% discount)
            )
            OUTPUT_COST_PER_MTOK = 15.00  # $15 per million output tokens

            # Calculate costs
            input_tokens = getattr(usage, "input_tokens", 0)
            cache_creation_tokens = getattr(usage, "cache_creation_input_tokens", 0)
            cache_read_tokens = getattr(usage, "cache_read_input_tokens", 0)
            output_tokens = getattr(usage, "output_tokens", 0)

            # Actual cost calculation
            cache_creation_cost = (
                cache_creation_tokens / 1_000_000
            ) * INPUT_COST_PER_MTOK
            cache_read_cost = (
                cache_read_tokens / 1_000_000
            ) * CACHED_INPUT_COST_PER_MTOK
            regular_input_cost = (input_tokens / 1_000_000) * INPUT_COST_PER_MTOK
            output_cost = (output_tokens / 1_000_000) * OUTPUT_COST_PER_MTOK

            total_input_tokens = (
                input_tokens + cache_creation_tokens + cache_read_tokens
            )
            total_cost = (
                cache_creation_cost + cache_read_cost + regular_input_cost + output_cost
            )
            cost_without_cache = (
                (input_tokens + cache_creation_tokens + cache_read_tokens) / 1_000_000
            ) * INPUT_COST_PER_MTOK + output_cost

            savings = cost_without_cache - total_cost
            savings_percent = (
                (savings / cost_without_cache * 100) if cost_without_cache > 0 else 0
            )

            print("\n" + "=" * 60)
            print("üí∞ COST ANALYSIS")
            print("=" * 60)
            print(f"üìä Token Usage:")
            print(f"   Input tokens: {input_tokens:,}")
            if cache_creation_tokens > 0:
                print(f"   Cache creation: {cache_creation_tokens:,} (first request)")
            if cache_read_tokens > 0:
                print(f"   Cache read: {cache_read_tokens:,} (90% cheaper!)")
            print(f"   Output tokens: {output_tokens:,}")
            print(f"   Total: {total_input_tokens + output_tokens:,}")

            print(f"\nüíµ Cost Breakdown:")
            if cache_creation_cost > 0:
                print(f"   Cache creation: ${cache_creation_cost:.4f}")
            if cache_read_cost > 0:
                print(f"   Cached input: ${cache_read_cost:.4f} ‚ö°")
            if regular_input_cost > 0:
                print(f"   Regular input: ${regular_input_cost:.4f}")
            print(f"   Output: ${output_cost:.4f}")
            print(f"   TOTAL: ${total_cost:.4f}")

            # Log AI usage for monitoring
            log_ai_request(
                model="claude-sonnet-4-20250514",
                tokens_in=total_input_tokens,
                tokens_out=output_tokens,
                cost=total_cost,
                duration_ms=0,  # Will add timing later
            )

            if cache_read_tokens > 0:
                print(f"\nüéâ SAVINGS:")
                print(f"   Without caching: ${cost_without_cache:.4f}")
                print(f"   With caching: ${total_cost:.4f}")
                print(f"   You saved: ${savings:.4f} ({savings_percent:.1f}%)")
            elif cache_creation_tokens > 0:
                print(f"\nüìå Cache Status: Created")
                print(
                    f"   Next requests will save ~${cache_creation_cost * 0.9:.4f} (90% discount)"
                )

            print("=" * 60 + "\n")

        analysis_result = ""
        for block in message.content:
            if block.type == "text":
                analysis_result += block.text

        print(f"\n‚úÖ Analysis result length: {len(analysis_result):,} characters")

        # Extract litigation data if Stage 1
        if stage == 1:
            extract_litigation_data(analysis_result)

        # Calculate totals safely
        total_tokens = 0
        total_cost_final = 0
        if usage:
            total_tokens = total_input_tokens + output_tokens
            total_cost_final = total_cost

        return {
            "success": True,
            "analysis": analysis_result,
            "client": client_name,
            "stage": stage,
            "tokens_used": total_tokens,
            "cost": total_cost_final,
            "cache_read": cache_read_tokens > 0 if usage else False,
        }

    except Exception as e:
        print(f"‚ùå Claude API Error: {str(e)}")
        return {"success": False, "error": str(e)}


def extract_litigation_data(analysis_text):
    """Extract structured litigation data from Claude's analysis"""
    import json
    import re

    try:
        # Try to find <LITIGATION_DATA> JSON block
        pattern = r"<LITIGATION_DATA>\s*(\{[\s\S]*?\})\s*</LITIGATION_DATA>"
        match = re.search(pattern, analysis_text)

        if match:
            json_str = match.group(1)
            print(f"‚úÖ Found <LITIGATION_DATA> block ({len(json_str)} characters)")
        else:
            # Fallback: look for bare JSON at end
            last_brace = analysis_text.rfind("{")
            if last_brace == -1:
                print("‚ö†Ô∏è  No JSON found in analysis")
                return None
            json_str = analysis_text[last_brace:]
            print(f"‚úÖ Found bare JSON at end ({len(json_str)} characters)")

        # Parse JSON
        litigation_data = json.loads(json_str)

        # Validate structure
        if "violations" not in litigation_data:
            litigation_data["violations"] = []
        if "standing" not in litigation_data:
            litigation_data["standing"] = {}
        if "actual_damages" not in litigation_data:
            litigation_data["actual_damages"] = {}

        # Ensure evidence fields are properly formatted for all violations
        for v in litigation_data.get("violations", []):
            if "evidence" not in v:
                v["evidence"] = {}
            if not isinstance(v["evidence"], dict):
                v["evidence"] = {}
            v["evidence"].setdefault("transunion", "Not specified")
            v["evidence"].setdefault("experian", "Not specified")
            v["evidence"].setdefault("equifax", "Not specified")

        print(
            f"   ‚úÖ Extracted {len(litigation_data.get('violations', []))} violations"
        )
        return litigation_data

    except json.JSONDecodeError as e:
        print(f"‚ùå JSON parse error: {str(e)}")
        return None
    except Exception as e:
        print(f"‚ùå Error extracting litigation data: {str(e)}")
        return None


def auto_populate_litigation_database(analysis_id, client_id, litigation_data, db):
    """
    Automatically populate Violations, Standing, and Damages tables from extracted data
    """
    from litigation_tools import calculate_case_score, calculate_damages

    try:
        print(f"\nü§ñ AUTO-POPULATING LITIGATION DATABASE...")

        # 1. POPULATE VIOLATIONS (handles both old single-bureau format and new bureau_violations array)
        violations_added = 0
        if litigation_data.get("violations"):
            for v_data in litigation_data["violations"]:
                # Check for new bureau_violations array format
                bureau_violations = v_data.get("bureau_violations", [])

                if bureau_violations and isinstance(bureau_violations, list):
                    # NEW FORMAT: Create separate violation record per bureau
                    for bv in bureau_violations:
                        bureau = bv.get("bureau", "Unknown")
                        fcra_section = bv.get(
                            "fcra_section", v_data.get("fcra_section", "")
                        )
                        data_reported = bv.get("data_reported", "")

                        violation = Violation(
                            analysis_id=analysis_id,
                            client_id=client_id,
                            account_name=v_data.get("account_name", "Unknown"),
                            bureau=bureau,
                            fcra_section=fcra_section,
                            violation_type=v_data.get("violation_type", ""),
                            description=f"{v_data.get('description', '')} | {data_reported}",
                            is_willful=v_data.get("is_willful", False),
                            willfulness_notes=v_data.get("willfulness_indicators", ""),
                            statutory_damages_min=100,
                            statutory_damages_max=1000,
                        )
                        db.add(violation)
                        violations_added += 1
                else:
                    # OLD FORMAT: Single bureau per violation (backwards compatibility)
                    violation = Violation(
                        analysis_id=analysis_id,
                        client_id=client_id,
                        account_name=v_data.get("account_name", "Unknown"),
                        bureau=v_data.get("bureau", "Unknown"),
                        fcra_section=v_data.get("fcra_section", ""),
                        violation_type=v_data.get("violation_type", ""),
                        description=v_data.get("description", ""),
                        is_willful=v_data.get("is_willful", False),
                        willfulness_notes=v_data.get("willfulness_indicators", ""),
                        statutory_damages_min=100,
                        statutory_damages_max=1000,
                    )
                    db.add(violation)
                    violations_added += 1

            print(f"   ‚úÖ Added {violations_added} violations")

        # 2. POPULATE STANDING
        if litigation_data.get("standing"):
            s_data = litigation_data["standing"]
            standing = Standing(
                analysis_id=analysis_id,
                client_id=client_id,
                has_concrete_harm=s_data.get("has_concrete_harm", False),
                concrete_harm_type=s_data.get("concrete_harm_type", ""),
                concrete_harm_details=s_data.get("harm_details", ""),
                has_dissemination=s_data.get("has_dissemination", False),
                dissemination_details=s_data.get("dissemination_details", ""),
                has_causation=s_data.get("has_causation", False),
                causation_details=s_data.get("causation_details", ""),
                denial_letters_count=s_data.get("denial_letters_count", 0),
                adverse_action_notices_count=s_data.get(
                    "adverse_action_notices_count", 0
                ),
                standing_verified=True,
            )
            db.add(standing)
            print(
                f"   ‚úÖ Added standing data (concrete harm: {s_data.get('has_concrete_harm', False)})"
            )

        # Commit violations and standing before calculating damages
        db.commit()

        # 3. CALCULATE AND POPULATE DAMAGES
        violations_for_calc = (
            db.query(Violation).filter_by(analysis_id=analysis_id).all()
        )
        violations_data = [
            {
                "fcra_section": v.fcra_section,
                "is_willful": v.is_willful,
                "violation_type": v.violation_type,
            }
            for v in violations_for_calc
        ]

        # Map Claude's output format to calculate_damages expected format
        claude_damages = litigation_data.get("actual_damages", {})
        actual_damages_input = {
            "credit_denials": claude_damages.get("credit_denials_amount", 0),
            "higher_interest": claude_damages.get("higher_interest_amount", 0),
            "credit_monitoring": claude_damages.get("credit_monitoring_amount", 0),
            "time_stress": claude_damages.get("time_stress_amount", 0),
            "other": claude_damages.get("other_actual_amount", 0),
            "notes": claude_damages.get("notes", ""),
        }
        damages_calc = calculate_damages(violations_data, actual_damages_input)

        damages = Damages(
            analysis_id=analysis_id,
            client_id=client_id,
            credit_denials_amount=damages_calc["actual"]["credit_denials"],
            higher_interest_amount=damages_calc["actual"]["higher_interest"],
            credit_monitoring_amount=damages_calc["actual"]["credit_monitoring"],
            time_stress_amount=damages_calc["actual"]["time_stress"],
            other_actual_amount=damages_calc["actual"]["other"],
            actual_damages_total=damages_calc["actual"]["total"],
            section_605b_count=damages_calc["statutory"]["605b"]["count"],
            section_605b_amount=damages_calc["statutory"]["605b"]["amount"],
            section_607b_count=damages_calc["statutory"]["607b"]["count"],
            section_607b_amount=damages_calc["statutory"]["607b"]["amount"],
            section_611_count=damages_calc["statutory"]["611"]["count"],
            section_611_amount=damages_calc["statutory"]["611"]["amount"],
            section_623_count=damages_calc["statutory"]["623"]["count"],
            section_623_amount=damages_calc["statutory"]["623"]["amount"],
            statutory_damages_total=damages_calc["statutory"]["total"],
            willfulness_multiplier=damages_calc["punitive"]["multiplier"],
            punitive_damages_amount=damages_calc["punitive"]["amount"],
            estimated_hours=damages_calc["attorney_fees"]["estimated_hours"],
            hourly_rate=damages_calc["attorney_fees"]["hourly_rate"],
            attorney_fees_projection=damages_calc["attorney_fees"]["total"],
            total_exposure=damages_calc["settlement"]["total_exposure"],
            settlement_target=damages_calc["settlement"]["target"],
            minimum_acceptable=damages_calc["settlement"]["minimum"],
            notes=actual_damages_input.get("notes", ""),
        )
        db.add(damages)
        print(
            f"   ‚úÖ Calculated damages (total exposure: ${damages_calc['settlement']['total_exposure']:,.2f})"
        )

        # Commit damages before calculating score
        db.commit()

        # 4. CALCULATE AND POPULATE CASE SCORE
        standing_obj = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        standing_data = {
            "has_concrete_harm": (
                standing_obj.has_concrete_harm if standing_obj else False
            ),
            "has_dissemination": (
                standing_obj.has_dissemination if standing_obj else False
            ),
            "has_causation": standing_obj.has_causation if standing_obj else False,
            "denial_letters_count": (
                standing_obj.denial_letters_count if standing_obj else 0
            ),
        }

        documentation_complete = len(violations_data) > 0 and standing_obj is not None

        score_data = calculate_case_score(
            standing_data, violations_data, damages_calc, documentation_complete
        )

        case_score = CaseScore(
            analysis_id=analysis_id,
            client_id=client_id,
            total_score=score_data["total"],
            standing_score=score_data["standing"],
            violation_quality_score=score_data["violation_quality"],
            willfulness_score=score_data["willfulness"],
            documentation_score=score_data["documentation"],
            settlement_probability=score_data["settlement_probability"],
            case_strength=score_data["case_strength"],
            recommendation=score_data["recommendation"],
            recommendation_notes="\n".join(score_data["notes"]),
        )
        db.add(case_score)
        print(
            f"   ‚úÖ Calculated case score ({score_data['total']}/10 - {score_data['case_strength']})"
        )

        # Final commit
        db.commit()

        print(f"‚úÖ AUTO-POPULATION COMPLETE!")
        print(f"   Violations: {violations_added}")
        print(f"   Standing: Added")
        print(f"   Damages: ${damages_calc['settlement']['total_exposure']:,.2f}")
        print(f"   Case Score: {score_data['total']}/10")

        return True

    except Exception as e:
        print(f"‚ùå Error auto-populating database: {str(e)}")
        db.rollback()
        return False


@app.route("/webhook", methods=["POST"])
def webhook():
    """Receives credit report data from HTML form or file upload"""
    try:
        # Get data from request - support JSON, form data, and file uploads
        data = request.get_json(force=True, silent=True) or request.form.to_dict()

        # Extract the specific fields we need
        client_name = data.get("clientName", "Unknown Client")
        cmm_contact_id = data.get("cmmContactId", "Unknown")
        credit_provider = data.get("creditProvider", "Unknown Provider")
        credit_report_html = data.get("creditReportHTML", "")
        analysis_mode = data.get("analysisMode", "manual")
        dispute_round = int(data.get("disputeRound", 1))
        previous_letters = data.get("previousLetters", "")
        bureau_responses = data.get("bureauResponses", "")
        dispute_timeline = data.get("disputeTimeline", "")

        # Read uploaded file if HTML not in form data
        if not credit_report_html and "creditReportHTML" in request.files:
            file = request.files["creditReportHTML"]
            if file and file.filename:
                credit_report_html = file.read().decode("utf-8")

        credit_report_html = clean_credit_report_html(credit_report_html)
        # Validate we got the essential data
        if not credit_report_html:
            return (
                jsonify({"success": False, "error": "No credit report HTML provided"}),
                400,
            )

        # Create report record
        report = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "client_name": client_name,
            "cmm_contact_id": cmm_contact_id,
            "credit_provider": credit_provider,
            "report_length": len(credit_report_html),
            "credit_report_html": credit_report_html,
            "status": "received",
            "processed": False,
        }
        # Analyze with Claude API (section-based Stage 1)
        analysis = run_stage1_for_all_sections(
            client_name=client_name,
            cmm_id=cmm_contact_id,
            provider=credit_provider,
            credit_report_text=credit_report_html,
            analysis_mode=analysis_mode,
            dispute_round=dispute_round,
            previous_letters=previous_letters,
            bureau_responses=bureau_responses,
            dispute_timeline=dispute_timeline,
        )

        if analysis.get("success"):
            report["analysis"] = analysis.get("combined_analysis", "")
            report["processed"] = True
            report["tokens_used"] = analysis.get("tokens_used", 0)
            report["cost"] = analysis.get("cost", 0)
            print(f"‚úÖ FCRA Section-based Analysis completed for {client_name}")
        else:
            report["analysis_error"] = analysis.get("error", "Unknown error")
            print(f"‚ö†Ô∏è Section-based analysis failed: {analysis.get('error')}")
        # Store it
        credit_reports.append(report)

        # Log to console
        print("\n" + "=" * 60)
        print("‚úÖ CREDIT REPORT RECEIVED")
        print("=" * 60)
        print(f"Client: {client_name}")
        print(f"CMM ID: {cmm_contact_id}")
        print(f"Provider: {credit_provider}")
        print(f"Report Size: {len(credit_report_html):,} characters")
        print(f"Time: {report['timestamp']}")
        print("=" * 60 + "\n")

        # Return success
        return (
            jsonify(
                {
                    "success": True,
                    "message": "Credit report received successfully! ‚úÖ",
                    "client": client_name,
                    "cmm_id": cmm_contact_id,
                    "timestamp": report["timestamp"],
                    "report_size": len(credit_report_html),
                    "total_reports": len(credit_reports),
                }
            ),
            200,
        )

    except Exception as e:
        print(f"\n‚ùå ERROR: {str(e)}\n")
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/webhook/batch", methods=["POST"])
def webhook_batch():
    """Process multiple credit reports in batch - maximizes cache efficiency

    Features:
    - Input validation for each client entry
    - Error isolation (one failure doesn't abort the batch)
    - Complete results including analyses for automation
    - Shared prompt cache across all clients (90% savings after first)
    """
    try:
        data = request.get_json()
        if not data:
            return (
                jsonify(
                    {"success": False, "error": "Invalid JSON or no data provided"}
                ),
                400,
            )

        clients = data.get("clients", [])

        if not clients:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": 'No clients provided in batch request. Expected "clients" array.',
                    }
                ),
                400,
            )

        if not isinstance(clients, list):
            return (
                jsonify({"success": False, "error": '"clients" must be an array'}),
                400,
            )

        print("\n" + "=" * 60)
        print(f"üì¶ BATCH PROCESSING: {len(clients)} clients")
        print("=" * 60)

        results = []

        for idx, client_data in enumerate(clients, 1):
            # Validate client_data is a dictionary
            if not isinstance(client_data, dict):
                results.append(
                    {
                        "client_index": idx,
                        "client_name": f"Client {idx}",
                        "success": False,
                        "error": f"Client entry {idx} is not a valid object",
                        "analysis": None,
                    }
                )
                print(f"‚ö†Ô∏è Skipping invalid client {idx} (not a valid object)")
                continue

            # Extract and validate fields
            client_name = client_data.get("clientName", f"Client {idx}")
            cmm_contact_id = client_data.get("cmmContactId", "Unknown")
            credit_provider = client_data.get("creditProvider", "Unknown Provider")
            credit_report_html = client_data.get("creditReportHTML", "")
            analysis_mode = client_data.get("analysisMode", "manual")
            dispute_round = client_data.get("disputeRound", 1)
            previous_letters = client_data.get("previousLetters", "")
            bureau_responses = client_data.get("bureauResponses", "")
            dispute_timeline = client_data.get("disputeTimeline", "")

            print(f"\nüîÑ Processing {idx}/{len(clients)}: {client_name}")

            # Validate required fields
            if not credit_report_html or not credit_report_html.strip():
                results.append(
                    {
                        "client_index": idx,
                        "client_name": client_name,
                        "success": False,
                        "error": "No credit report HTML provided",
                        "analysis": None,
                    }
                )
                print(f"‚ö†Ô∏è Skipping {client_name}: No credit report HTML")
                continue

            # Validate dispute_round is valid integer
            try:
                dispute_round = int(dispute_round)
                if dispute_round < 1 or dispute_round > 4:
                    raise ValueError("Dispute round must be 1-4")
            except (ValueError, TypeError) as e:
                results.append(
                    {
                        "client_index": idx,
                        "client_name": client_name,
                        "success": False,
                        "error": f"Invalid dispute_round: {str(e)}",
                        "analysis": None,
                    }
                )
                print(f"‚ö†Ô∏è Skipping {client_name}: Invalid dispute round")
                continue

            # Process this client (isolated error handling)
            try:
                # Clean the report
                cleaned_html = clean_credit_report_html(credit_report_html)

                # Analyze with Claude API (benefits from cached prompt!)
                analysis_result = analyze_with_claude(
                    client_name=client_name,
                    cmm_id=cmm_contact_id,
                    provider=credit_provider,
                    credit_report_html=cleaned_html,
                    analysis_mode=analysis_mode,
                    dispute_round=dispute_round,
                    previous_letters=previous_letters,
                    bureau_responses=bureau_responses,
                    dispute_timeline=dispute_timeline,
                )

                # Store report
                report = {
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "client_name": client_name,
                    "cmm_contact_id": cmm_contact_id,
                    "credit_provider": credit_provider,
                    "report_length": len(cleaned_html),
                    "credit_report_html": cleaned_html,
                    "status": "processed" if analysis_result["success"] else "failed",
                    "processed": analysis_result["success"],
                }

                if analysis_result["success"]:
                    report["analysis"] = analysis_result["analysis"]
                    results.append(
                        {
                            "client_index": idx,
                            "client_name": client_name,
                            "cmm_contact_id": cmm_contact_id,
                            "success": True,
                            "message": "Analysis completed successfully",
                            "analysis": analysis_result[
                                "analysis"
                            ],  # Include full analysis for automation
                        }
                    )
                    print(f"‚úÖ Completed: {client_name}")
                else:
                    report["analysis_error"] = analysis_result.get(
                        "error", "Unknown error"
                    )
                    results.append(
                        {
                            "client_index": idx,
                            "client_name": client_name,
                            "cmm_contact_id": cmm_contact_id,
                            "success": False,
                            "error": analysis_result.get("error", "Unknown error"),
                            "analysis": None,
                        }
                    )
                    print(
                        f"‚ùå Failed: {client_name} - {analysis_result.get('error', 'Unknown error')}"
                    )

                credit_reports.append(report)

            except Exception as client_error:
                # Isolate error - don't let one client crash the entire batch
                error_msg = f"Processing error: {str(client_error)}"
                results.append(
                    {
                        "client_index": idx,
                        "client_name": client_name,
                        "cmm_contact_id": cmm_contact_id,
                        "success": False,
                        "error": error_msg,
                        "analysis": None,
                    }
                )
                print(f"‚ùå Error processing {client_name}: {error_msg}")
                continue

        successful = sum(1 for r in results if r["success"])
        failed = len(results) - successful

        print("\n" + "=" * 60)
        print("üéâ BATCH PROCESSING COMPLETE")
        print("=" * 60)
        print(f"‚úÖ Successful: {successful}/{len(results)}")
        print(f"‚ùå Failed: {failed}/{len(results)}")
        if successful > 1:
            print(f"üí∞ Prompt caching saved ~70-90% on costs (after first request)!")
        print("=" * 60 + "\n")

        return (
            jsonify(
                {
                    "success": True,  # Batch endpoint succeeded even if some clients failed
                    "total_clients": len(results),
                    "successful": successful,
                    "failed": failed,
                    "results": results,  # Includes full analyses for automation
                    "message": f"Batch processing complete: {successful}/{len(results)} successful",
                }
            ),
            200,
        )

    except Exception as e:
        print(f"\n‚ùå BATCH ENDPOINT ERROR: {str(e)}\n")
        import traceback

        traceback.print_exc()
        return (
            jsonify({"success": False, "error": f"Batch endpoint error: {str(e)}"}),
            500,
        )


@app.route("/history")
def history():
    """View all received reports in JSON format"""
    # Don't include full HTML to keep response manageable
    summary = []
    for report in credit_reports:
        summary.append(
            {
                "timestamp": report["timestamp"],
                "client_name": report["client_name"],
                "cmm_contact_id": report["cmm_contact_id"],
                "credit_provider": report["credit_provider"],
                "report_length": report["report_length"],
                "status": report["status"],
                "processed": report["processed"],
            }
        )

    return jsonify({"total_reports": len(credit_reports), "reports": summary}), 200


@app.route("/test")
def test():
    """Test endpoint to verify server is working"""
    return (
        jsonify(
            {
                "status": "Server is running! ‚úÖ",
                "reports_received": len(credit_reports),
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "ready_for": "Phase 2 - Claude API Integration",
            }
        ),
        200,
    )


@app.route("/clear", methods=["POST"])
def clear_history():
    """Clear all stored reports (for testing)"""
    credit_reports.clear()
    return jsonify({"success": True, "message": "All reports cleared"}), 200


@app.route("/view/<int:report_id>")
def view_analysis(report_id):
    """View the Claude analysis for a specific report"""
    if report_id < len(credit_reports):
        report = credit_reports[report_id]
        return f"""
        <html>
        <head><title>FCRA Analysis - {report['client_name']}</title></head>
        <body style="font-family: Arial; max-width: 900px; margin: 40px auto; padding: 20px;">
            <h1>FCRA Analysis: {report['client_name']}</h1>
            <p><strong>CMM ID:</strong> {report['cmm_contact_id']}</p>
            <p><strong>Provider:</strong> {report['credit_provider']}</p>
            <p><strong>Date:</strong> {report['timestamp']}</p>
            <hr>
            <h2>Analysis:</h2>
            <pre style="white-space: pre-wrap; background: #f5f5f5; padding: 20px; border-radius: 8px;">{report.get('analysis', 'No analysis available')}</pre>
            <p><a href="/">‚Üê Back to Form</a></p>
        </body>
        </html>
        """
    return "Report not found", 404


@app.route("/admin")
def admin_dashboard():
    """Admin dashboard for generating analyses and letters"""
    return render_template("admin.html")


# ============================================================
# PDF CREDIT REPORT PARSING ENDPOINTS
# ============================================================


@app.route("/api/credit-report/parse-pdf", methods=["POST"])
def parse_credit_report_pdf():
    """Parse a PDF credit report and extract structured data."""
    import tempfile

    from services.pdf_parser_service import get_parsed_text_for_analysis
    from services.pdf_parser_service import parse_credit_report_pdf as parse_pdf

    if "file" not in request.files:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "No file uploaded. Please select a PDF file.",
                }
            ),
            400,
        )

    file = request.files["file"]

    if file.filename == "":
        return (
            jsonify(
                {
                    "success": False,
                    "error": "No file selected. Please choose a PDF file.",
                }
            ),
            400,
        )

    if not file.filename.lower().endswith(".pdf"):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Invalid file type. Please upload a PDF file.",
                }
            ),
            400,
        )

    temp_path = None
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_file:
            file.save(temp_file.name)
            temp_path = temp_file.name

        result = parse_pdf(temp_path)

        if not result.get("success"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": result.get("error", "Failed to parse PDF"),
                        "is_password_protected": "password"
                        in (result.get("error", "")).lower(),
                        "is_image_based": "image" in (result.get("error", "")).lower()
                        or "ocr" in (result.get("error", "")).lower(),
                    }
                ),
                400,
            )

        formatted_text = get_parsed_text_for_analysis(result)

        return (
            jsonify(
                {
                    "success": True,
                    "bureau": result.get("bureau", "Unknown"),
                    "personal_info": result.get("personal_info", {}),
                    "accounts": result.get("accounts", []),
                    "inquiries": result.get("inquiries", []),
                    "collections": result.get("collections", []),
                    "public_records": result.get("public_records", []),
                    "parsing_confidence": result.get("parsing_confidence", 0.0),
                    "text_length": result.get("text_length", 0),
                    "formatted_text": formatted_text,
                    "raw_text": result.get("raw_text", "")[:50000],
                }
            ),
            200,
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return (
            jsonify({"success": False, "error": f"Error processing PDF: {str(e)}"}),
            500,
        )
    finally:
        if temp_path:
            try:
                import os

                os.unlink(temp_path)
            except:
                pass


@app.route("/api/credit-report/parse-and-analyze", methods=["POST"])
def parse_and_analyze_credit_report():
    """Parse a PDF credit report and immediately run FCRA analysis."""
    import tempfile

    from services.pdf_parser_service import get_parsed_text_for_analysis
    from services.pdf_parser_service import parse_credit_report_pdf as parse_pdf

    db = get_db()
    temp_path = None

    try:
        if "file" not in request.files:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "No file uploaded. Please select a PDF file.",
                    }
                ),
                400,
            )

        file = request.files["file"]
        client_name = request.form.get("clientName", "")
        client_email = request.form.get("clientEmail", "")
        credit_provider = request.form.get("creditProvider", "Unknown")
        dispute_round = int(request.form.get("disputeRound", 1))

        if not client_name:
            return jsonify({"success": False, "error": "Client name is required"}), 400

        if file.filename == "" or not file.filename.lower().endswith(".pdf"):
            return (
                jsonify({"success": False, "error": "Please upload a valid PDF file."}),
                400,
            )

        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_file:
            file.save(temp_file.name)
            temp_path = temp_file.name

        parse_result = parse_pdf(temp_path)

        if not parse_result.get("success"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": parse_result.get("error", "Failed to parse PDF"),
                        "is_password_protected": "password"
                        in (parse_result.get("error", "")).lower(),
                        "is_image_based": "image"
                        in (parse_result.get("error", "")).lower(),
                    }
                ),
                400,
            )

        formatted_text = get_parsed_text_for_analysis(parse_result)

        if parse_result.get("bureau") and parse_result.get("bureau") != "Unknown":
            credit_provider = parse_result.get("bureau")

        client = db.query(Client).filter_by(name=client_name).first()
        if not client:
            client = Client(name=client_name, email=client_email)
            db.add(client)
            db.commit()
            db.refresh(client)

        credit_report_record = CreditReport(
            client_id=client.id,
            client_name=client_name,
            credit_provider=credit_provider,
            report_html=formatted_text,
            report_date=datetime.now(),
        )
        db.add(credit_report_record)
        db.commit()
        db.refresh(credit_report_record)

        section_analysis = run_stage1_for_all_sections(
            client_name=client_name,
            cmm_id=request.form.get("cmmContactId", ""),
            provider=credit_provider,
            credit_report_text=formatted_text,
            analysis_mode="manual",
            dispute_round=dispute_round,
            previous_letters="",
            bureau_responses="",
            dispute_timeline="",
        )

        if not section_analysis.get("success"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": section_analysis.get("error", "Analysis failed"),
                        "parsed_data": {
                            "bureau": parse_result.get("bureau"),
                            "accounts_count": len(parse_result.get("accounts", [])),
                            "inquiries_count": len(parse_result.get("inquiries", [])),
                            "collections_count": len(
                                parse_result.get("collections", [])
                            ),
                        },
                    }
                ),
                500,
            )

        merged_litigation_data = section_analysis.get("litigation_data", {})

        analysis_record = Analysis(
            credit_report_id=credit_report_record.id,
            client_id=client.id,
            client_name=client_name,
            dispute_round=dispute_round,
            analysis_mode="manual",
            stage=1,
            stage_1_analysis=str(merged_litigation_data),
            cost=section_analysis.get("cost", 0),
            tokens_used=section_analysis.get("tokens_used", 0),
            cache_read=section_analysis.get("cache_read", False),
        )
        db.add(analysis_record)
        db.commit()
        db.refresh(analysis_record)

        if merged_litigation_data and merged_litigation_data.get("violations"):
            auto_populate_litigation_database(
                analysis_id=analysis_record.id,
                client_id=client.id,
                litigation_data=merged_litigation_data,
                db=db,
            )

        return (
            jsonify(
                {
                    "success": True,
                    "analysis_id": analysis_record.id,
                    "client_id": client.id,
                    "parsed_data": {
                        "bureau": parse_result.get("bureau"),
                        "personal_info": parse_result.get("personal_info", {}),
                        "accounts_count": len(parse_result.get("accounts", [])),
                        "inquiries_count": len(parse_result.get("inquiries", [])),
                        "collections_count": len(parse_result.get("collections", [])),
                        "public_records_count": len(
                            parse_result.get("public_records", [])
                        ),
                        "parsing_confidence": parse_result.get(
                            "parsing_confidence", 0.0
                        ),
                    },
                    "violations_found": len(
                        merged_litigation_data.get("violations", [])
                    ),
                    "review_url": f"/analysis/{analysis_record.id}/review",
                }
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": f"Error: {str(e)}"}), 500
    finally:
        db.close()
        if temp_path:
            try:
                import os

                os.unlink(temp_path)
            except:
                pass


@app.route("/api/analyze", methods=["POST"])
@limiter.limit(RATE_LIMITS["ai_analysis"])  # Limit expensive AI operations
def analyze_and_generate_letters():
    """Process credit report, run AI analysis, generate PDF letters"""
    db = get_db()
    try:
        print(f"\nüìã /api/analyze endpoint called")
        data = request.get_json()
        if not data:
            print(f"‚ùå No JSON data received")
            return jsonify({"success": False, "error": "No JSON data in request"}), 400

        # Sanitize inputs
        client_name = sanitize_string(data.get("clientName", ""), max_length=200)
        client_email = sanitize_string(data.get("clientEmail", ""), max_length=255)
        credit_provider = sanitize_string(
            data.get("creditProvider", "Unknown"), max_length=100
        )
        # Sanitize credit report HTML (remove scripts but preserve structure)
        credit_report_html = sanitize_credit_report_html(
            data.get("creditReportHTML", "")
        )
        dispute_round = data.get("disputeRound", 1)
        analysis_mode = data.get("analysisMode", "auto")

        print(
            f"üìù Client: {client_name}, Provider: {credit_provider}, Round: {dispute_round}"
        )

        if not client_name or not credit_report_html:
            error_msg = "Missing required fields"
            print(f"‚ùå {error_msg}")
            return jsonify({"success": False, "error": error_msg}), 400

        # üßπ Clean and analyze with section-based Stage 1
        try:
            print(f"üßπ Cleaning credit report in /api/analyze endpoint...")
            credit_report_text = clean_credit_report_html(credit_report_html)
            print(
                f"‚úÖ Credit report cleaned successfully ({len(credit_report_text)} chars)"
            )
        except Exception as e:
            error_msg = f"Error cleaning credit report: {str(e)}"
            print(f"‚ùå {error_msg}")
            import traceback

            traceback.print_exc()
            return jsonify({"success": False, "error": error_msg}), 400

        # üöÄ Run Stage 1 on each section, merge results
        try:
            print(f"üöÄ Starting Stage 1 analysis with sections...")
            section_analysis = run_stage1_for_all_sections(
                client_name=client_name,
                cmm_id=data.get("cmmContactId", ""),
                provider=credit_provider,
                credit_report_text=credit_report_text,
                analysis_mode="manual",
                dispute_round=dispute_round,
                previous_letters="",
                bureau_responses="",
                dispute_timeline="",
            )
            print(f"‚úÖ Stage 1 analysis complete")
        except Exception as e:
            error_msg = f"Error in Stage 1 analysis: {str(e)}"
            print(f"‚ùå {error_msg}")
            import traceback

            traceback.print_exc()
            return jsonify({"success": False, "error": error_msg}), 500

        if not section_analysis.get("success"):
            error_msg = section_analysis.get("error", "Analysis failed")
            print(f"‚ùå Analysis returned success=False: {error_msg}")
            return jsonify({"success": False, "error": error_msg}), 500

        merged_litigation_data = section_analysis.get("litigation_data", {})

        # Create or get client
        client = db.query(Client).filter_by(name=client_name).first()
        if not client:
            client = Client(name=client_name, email=client_email)
            db.add(client)
            db.commit()
            db.refresh(client)

        # Save credit report
        credit_report_record = CreditReport(
            client_id=client.id,
            client_name=client_name,
            credit_provider=credit_provider,
            report_html=credit_report_html,
            report_date=datetime.now(),
        )
        db.add(credit_report_record)
        db.commit()
        db.refresh(credit_report_record)

        # Save analysis with merged Stage 1 results from all sections
        analysis_record = Analysis(
            credit_report_id=credit_report_record.id,
            client_id=client.id,
            client_name=client_name,
            dispute_round=dispute_round,
            analysis_mode="manual",
            stage=1,  # This is Stage 1 analysis
            stage_1_analysis=str(
                merged_litigation_data
            ),  # Store merged Stage 1 results
            cost=section_analysis.get(
                "cost", 0
            ),  # Cost is at top level of section_analysis
            tokens_used=section_analysis.get("tokens_used", 0),  # Tokens at top level
            cache_read=section_analysis.get("cache_read", False),
        )
        db.add(analysis_record)
        db.commit()
        db.refresh(analysis_record)

        # ü§ñ AUTO-POPULATE LITIGATION DATABASE from merged section data
        if merged_litigation_data and merged_litigation_data.get("violations"):
            print(f"\nüéØ Merged litigation data found! Auto-populating database...")
            auto_populate_litigation_database(
                analysis_id=analysis_record.id,
                client_id=client.id,
                litigation_data=merged_litigation_data,
                db=db,
            )
        else:
            print(f"\n‚ö†Ô∏è  No violations found in merged analysis")

        # Extract and generate PDF letters
        letters_generated = []

        # Parse individual letters using START/END markers
        import re

        # Get combined analysis from section results
        combined_analysis_text = section_analysis.get("combined_analysis", "")

        # Find all individual letters
        letter_pattern = r"==.*?START OF DISPUTE LETTER: ([A-Za-z]+) - (.+?)==(.*?)==.*?END OF DISPUTE LETTER:"
        all_letters = re.findall(
            letter_pattern, combined_analysis_text, re.DOTALL | re.IGNORECASE
        )

        # Group letters by bureau
        bureau_letters = {"Equifax": [], "Experian": [], "TransUnion": []}
        for match in all_letters:
            bureau_name = match[0].strip().title()
            account_name = match[1].strip()
            letter_content = match[2].strip()

            if bureau_name in bureau_letters:
                bureau_letters[bureau_name].append(
                    {"account": account_name, "content": letter_content}
                )

        # Generate one PDF per bureau combining all letters for that bureau
        for bureau, letters in bureau_letters.items():
            if not letters:
                continue

            # Combine all letters for this bureau
            combined_content = f"\n\n{'='*80}\n\n".join(
                [
                    f"ACCOUNT: {letter['account']}\n\n{letter['content']}"
                    for letter in letters
                ]
            )

            # Generate PDF
            filename = f"{client_name.replace(' ', '_')}_{bureau}_Round{dispute_round}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            output_path = os.path.join("static", "generated_letters", filename)

            try:
                pdf_gen.generate_dispute_letter_pdf(
                    letter_content=combined_content,
                    client_name=client_name,
                    bureau=bureau,
                    round_number=dispute_round,
                    output_path=output_path,
                )

                # Save letter record
                letter_record = DisputeLetter(
                    analysis_id=analysis_record.id,
                    client_id=client.id,
                    client_name=client_name,
                    bureau=bureau,
                    round_number=dispute_round,
                    letter_content=combined_content,
                    file_path=output_path,
                )
                db.add(letter_record)
                db.commit()
                db.refresh(letter_record)

                letters_generated.append(
                    {
                        "letter_id": letter_record.id,
                        "bureau": bureau,
                        "round": dispute_round,
                        "filepath": output_path,
                        "letter_count": len(letters),
                    }
                )

                print(f"‚úÖ Generated PDF for {bureau} with {len(letters)} letter(s)")
            except Exception as e:
                print(f"‚ùå Error generating PDF for {bureau}: {e}")

        return (
            jsonify(
                {
                    "success": True,
                    "client_name": client_name,
                    "round": dispute_round,
                    "cost": section_analysis.get("cost", 0),
                    "tokens_used": section_analysis.get("tokens_used", 0),
                    "analysis_id": analysis_record.id,
                    "letters": letters_generated,
                }
            ),
            200,
        )

    except Exception as e:
        print(f"Error in analyze_and_generate_letters: {e}")
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/debug/analysis/<int:analysis_id>")
def debug_analysis_content(analysis_id):
    """Debug endpoint to see what's actually in the database"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        return (
            jsonify(
                {
                    "analysis_id": analysis.id,
                    "stage": analysis.stage,
                    "stage_1_analysis_length": len(analysis.stage_1_analysis or ""),
                    "full_analysis_length": len(analysis.full_analysis or ""),
                    "full_analysis_preview": (analysis.full_analysis or "")[:500],
                    "full_analysis_exists": bool(analysis.full_analysis),
                    "full_analysis_is_none": analysis.full_analysis is None,
                    "full_analysis_is_empty": analysis.full_analysis == "",
                }
            ),
            200,
        )
    finally:
        db.close()


@app.route("/api/download/<int:letter_id>")
def download_letter(letter_id):
    """Download a generated PDF letter"""
    db = get_db()
    try:
        letter = db.query(DisputeLetter).filter_by(id=letter_id).first()

        if not letter:
            return jsonify({"error": "Letter not found"}), 404

        file_path_str = str(letter.file_path)
        if not os.path.exists(file_path_str):
            return jsonify({"error": "PDF file not found"}), 404

        return send_file(
            file_path_str,
            as_attachment=True,
            download_name=f"{letter.client_name}_{letter.bureau}_Round{letter.round_number}.pdf",
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/download/analysis/<int:analysis_id>/full_report")
def download_full_report(analysis_id):
    """Download full litigation report PDF"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        # Query data needed for PDF generation
        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()

        # Check if analysis exists
        if not violations:
            return (
                jsonify({"error": "No analysis data found. Click Accept Case first."}),
                404,
            )

        # Generate Apple-style Client Report PDF
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        client_name_safe = analysis.client_name.replace(" ", "_")
        client_filename = f"{client_name_safe}_Client_Report_{timestamp}.pdf"
        client_output_path = os.path.join(
            "static", "generated_letters", client_filename
        )
        os.makedirs(os.path.dirname(client_output_path), exist_ok=True)
        client_html = generate_client_report_html(
            analysis, violations, standing, damages, case_score
        )
        html_to_pdf(client_html, client_output_path)

        # Generate Apple-style Internal Analysis PDF
        legal_filename = f"{client_name_safe}_Legal_Analysis_{timestamp}.pdf"
        legal_output_path = os.path.join("static", "generated_letters", legal_filename)
        legal_html = generate_internal_analysis_html(
            analysis, violations, standing, damages, case_score
        )
        html_to_pdf(legal_html, legal_output_path)

        # Return the requested PDF type (default to client)
        pdf_type = request.args.get("type", "client")
        # Check if request wants inline viewing (from iframe) or download
        inline = request.args.get("inline", "true").lower() == "true"

        if pdf_type == "legal":
            return send_file(
                legal_output_path,
                as_attachment=not inline,  # False = inline, True = download
                download_name=legal_filename,
                mimetype="application/pdf",
            )
        else:
            return send_file(
                client_output_path,
                as_attachment=not inline,  # False = inline, True = download
                download_name=client_filename,
                mimetype="application/pdf",
            )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/download/analysis/<int:analysis_id>/round_<int:round_num>")
def download_round_letter(analysis_id, round_num):
    """Download dispute letter for specific round"""
    db = get_db()
    try:
        # Get first letter from this analysis/round
        letter = (
            db.query(DisputeLetter)
            .filter_by(analysis_id=analysis_id, round_number=round_num)
            .first()
        )

        if not letter:
            return (
                jsonify(
                    {
                        "error": f"No letter found for Round {round_num}. Click Accept Case first."
                    }
                ),
                404,
            )

        file_path_str = str(letter.file_path)
        if not os.path.exists(file_path_str):
            return jsonify({"error": "PDF file not found"}), 404

        return send_file(
            file_path_str,
            as_attachment=True,
            download_name=f"{letter.client_name}_Round{round_num}_Dispute_Letter.pdf",
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/approve/<int:analysis_id>", methods=["POST"])
def approve_analysis_stage_1(analysis_id):
    """
    Approve Stage 1 analysis and trigger Stage 2 (client documents generation).

    Behavior:
    - stage is NULL/0  ‚Üí treat as Stage 1 (backwards compatible)
    - stage == 1      ‚Üí run Stage 2, generate docs
    - stage == 2      ‚Üí already approved, return existing letters (idempotent)
    - anything else   ‚Üí return error

    Query Parameters:
    - force=true: Force regeneration of documents even if stage 2 is complete
    """
    db = get_db()
    try:
        # Check for force regeneration parameter
        force_regenerate = request.args.get("force", "false").lower() == "true"
        if not force_regenerate:
            data = request.get_json(silent=True) or {}
            force_regenerate = data.get("force", False)

        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        # Backwards compatibility: if stage is None or 0, treat it as Stage 1
        if analysis.stage is None or analysis.stage == 0:
            analysis.stage = 1
            db.commit()

        # If Stage 2 already completed and NOT forcing regeneration, return existing documents
        if analysis.stage == 2 and not force_regenerate:
            documents = db.query(DisputeLetter).filter_by(analysis_id=analysis_id).all()
            documents_payload = [
                {
                    "document_id": d.id,
                    "type": d.bureau.lower().replace(
                        " ", "_"
                    ),  # Convert 'Internal Analysis' to 'internal_analysis'
                    "filepath": str(d.file_path),
                }
                for d in documents
            ]

            return (
                jsonify(
                    {
                        "success": True,
                        "analysis_id": analysis_id,
                        "stage": 2,
                        "message": "Client documents already generated",
                        "cost": 0,  # Stage 2 cost is always $0
                        "tokens": 0,  # Stage 2 tokens is always 0
                        "documents": documents_payload,
                        "total_cost": analysis.cost or 0,
                        "total_tokens": analysis.tokens_used or 0,
                    }
                ),
                200,
            )

        # Stage validation (allow stage 1 or stage 2 with force regeneration)
        if analysis.stage != 1 and not (analysis.stage == 2 and force_regenerate):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Analysis is not in Stage 1 (current stage: {analysis.stage}). Use force=true to regenerate.",
                    }
                ),
                400,
            )

        # If force regenerating, delete old documents and reset to stage 1
        if force_regenerate and analysis.stage == 2:
            print(
                f"\nüîÑ FORCE REGENERATION: Deleting old documents and resetting to stage 1..."
            )
            old_documents = (
                db.query(DisputeLetter).filter_by(analysis_id=analysis_id).all()
            )
            for doc in old_documents:
                # Delete PDF file if it exists
                if doc.file_path and os.path.exists(doc.file_path):
                    try:
                        os.remove(doc.file_path)
                        print(f"  üóëÔ∏è  Deleted: {doc.file_path}")
                    except Exception as e:
                        print(f"  ‚ö†Ô∏è  Could not delete {doc.file_path}: {e}")
                # Delete database record
                db.delete(doc)
            db.commit()
            print(f"  ‚úÖ Deleted {len(old_documents)} old documents")

            # Reset to stage 1
            analysis.stage = 1
            db.commit()
            print(f"  ‚úÖ Reset analysis to stage 1")

        print(
            f"\nüöÄ STAGE 2: Generating client documents for analysis {analysis_id}..."
        )

        # Get credit report for context
        credit_report = (
            db.query(CreditReport).filter_by(id=analysis.credit_report_id).first()
        )
        if not credit_report:
            return jsonify({"success": False, "error": "Credit report not found"}), 404

        # =====================================================================
        # STAGE 2: Generate Apple-style documents (database-driven, no Claude API)
        # =====================================================================
        print(
            f"üìÑ Generating Apple-style documents (database-driven, no Claude API)..."
        )

        # Fetch database objects
        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()
        credit_scores = None  # TODO: Extract if needed

        if not violations:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "No violations found in Stage 1 analysis. Cannot generate client documents.",
                    }
                ),
                400,
            )

        # Generate 3 documents
        documents_generated = []
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        client_filename_safe = analysis.client_name.replace(" ", "_")

        try:
            # 1. INTERNAL ANALYSIS (staff-facing, 3-5 pages)
            print(f"  üìä Generating Internal Analysis...")
            internal_filename = (
                f"{client_filename_safe}_Internal_Analysis_{timestamp}.pdf"
            )
            internal_path = os.path.join(
                "static", "generated_letters", internal_filename
            )

            internal_html = generate_internal_analysis_html(
                analysis=analysis,
                violations=violations,
                standing=standing,
                damages=damages,
                case_score=case_score,
                credit_scores=credit_scores,
            )
            html_to_pdf(internal_html, internal_path)

            internal_record = DisputeLetter(
                analysis_id=analysis_id,
                client_id=analysis.client_id,
                client_name=analysis.client_name,
                bureau="Internal Analysis",  # New bureau type for reports
                round_number=analysis.dispute_round,
                letter_content="Internal Analysis Report",
                file_path=internal_path,
            )
            db.add(internal_record)
            db.commit()
            db.refresh(internal_record)

            documents_generated.append(
                {
                    "document_id": internal_record.id,
                    "type": "internal_analysis",
                    "filepath": internal_path,
                }
            )
            print(f"  ‚úÖ Internal Analysis saved: {internal_path}")

            # 2. CLIENT REPORT (7-page Apple-style report)
            print(f"  üìÑ Generating 7-Page Client Report...")
            client_report_filename = (
                f"{client_filename_safe}_Client_Report_{timestamp}.pdf"
            )
            client_report_path = os.path.join(
                "static", "generated_letters", client_report_filename
            )

            client_report_html = generate_client_report_html(
                analysis=analysis,
                violations=violations,
                standing=standing,
                damages=damages,
                case_score=case_score,
                credit_scores=credit_scores,
            )
            html_to_pdf(client_report_html, client_report_path)

            client_report_record = DisputeLetter(
                analysis_id=analysis_id,
                client_id=analysis.client_id,
                client_name=analysis.client_name,
                bureau="Client Report",  # New bureau type for reports
                round_number=analysis.dispute_round,
                letter_content="7-Page Client Report",
                file_path=client_report_path,
            )
            db.add(client_report_record)
            db.commit()
            db.refresh(client_report_record)

            documents_generated.append(
                {
                    "document_id": client_report_record.id,
                    "type": "client_report",
                    "filepath": client_report_path,
                }
            )
            print(f"  ‚úÖ Client Report saved: {client_report_path}")

            # 3. CLIENT EMAIL (email-optimized, 2-3 pages)
            print(f"  üìß Generating Client Email...")
            client_email_filename = (
                f"{client_filename_safe}_Client_Email_{timestamp}.pdf"
            )
            client_email_path = os.path.join(
                "static", "generated_letters", client_email_filename
            )

            client_email_html = generate_client_email_html(
                analysis=analysis,
                violations=violations,
                standing=standing,
                damages=damages,
                case_score=case_score,
            )
            html_to_pdf(client_email_html, client_email_path)

            client_email_record = DisputeLetter(
                analysis_id=analysis_id,
                client_id=analysis.client_id,
                client_name=analysis.client_name,
                bureau="Client Email",  # New bureau type for reports
                round_number=analysis.dispute_round,
                letter_content="Client Email Report",
                file_path=client_email_path,
            )
            db.add(client_email_record)
            db.commit()
            db.refresh(client_email_record)

            documents_generated.append(
                {
                    "document_id": client_email_record.id,
                    "type": "client_email",
                    "filepath": client_email_path,
                }
            )
            print(f"  ‚úÖ Client Email saved: {client_email_path}")

        except Exception as e:
            print(f"‚ùå Error generating documents: {e}")
            db.rollback()
            return (
                jsonify(
                    {"success": False, "error": f"Document generation failed: {str(e)}"}
                ),
                500,
            )

        # Update analysis stage and metadata (no Claude API cost for Stage 2)
        analysis.stage = 2
        analysis.approved_at = datetime.now()
        # Note: No cost/tokens added for Stage 2 (database-driven, $0 cost)

        # Commit with retry logic
        retry_count = 0
        max_retries = 3
        while retry_count < max_retries:
            try:
                db.commit()
                print(f"‚úÖ Metadata committed successfully")
                break
            except Exception as e:
                retry_count += 1
                if retry_count >= max_retries:
                    db.rollback()
                    return (
                        jsonify(
                            {
                                "success": False,
                                "error": f"Database commit failed: {str(e)}",
                            }
                        ),
                        500,
                    )
                wait_time = 2**retry_count
                print(f"‚ö†Ô∏è Metadata commit failed, retrying in {wait_time}s")
                db.rollback()
                time.sleep(wait_time)

        print(f"‚úÖ Stage 2 complete! Analysis {analysis_id} ready for delivery")

        # AUTO-TRIGGER: Run triage after Stage 2 completion
        try:
            triage_result = triage_service.triage_case(analysis_id)
            if triage_result.get("success"):
                print(
                    f"‚úÖ Auto-triage complete! Priority: {triage_result.get('priority_score')}/5, Queue: {triage_result.get('recommended_queue')}"
                )
            else:
                print(
                    f"‚ö†Ô∏è Auto-triage failed: {triage_result.get('error', 'Unknown error')}"
                )
        except Exception as triage_error:
            print(f"‚ö†Ô∏è Auto-triage error (non-blocking): {triage_error}")

        return (
            jsonify(
                {
                    "success": True,
                    "analysis_id": analysis_id,
                    "stage": 2,
                    "message": "Apple-style documents generated successfully (no Claude API cost)",
                    "cost": 0,  # No Stage 2 cost (database-driven)
                    "tokens": 0,  # No Stage 2 tokens
                    "documents": documents_generated,  # Changed from 'letters'
                    "total_cost": analysis.cost or 0,  # Stage 1 cost only
                    "total_tokens": analysis.tokens_used or 0,  # Stage 1 tokens only
                    "triage": (
                        triage_result
                        if "triage_result" in dir() and triage_result.get("success")
                        else None
                    ),
                }
            ),
            200,
        )

    except Exception as e:
        print(f"‚ùå Error in approve_analysis_stage_1: {e}")
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/delivered", methods=["GET", "POST"])
def delivered_status(analysis_id):
    """
    GET  -> return whether case is marked as delivered
    POST -> set/unset delivered flag (front-end toggle)
    """
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        global delivered_cases

        if request.method == "GET":
            return (
                jsonify({"success": True, "delivered": analysis_id in delivered_cases}),
                200,
            )

        # POST
        data = request.get_json() or {}
        delivered = bool(data.get("delivered", False))

        if delivered:
            delivered_cases.add(analysis_id)
        else:
            delivered_cases.discard(analysis_id)

        return (
            jsonify({"success": True, "delivered": analysis_id in delivered_cases}),
            200,
        )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/download_all")
def download_all_letters(analysis_id):
    """Create a ZIP with all generated PDFs for this analysis"""
    db = get_db()
    try:
        letters = db.query(DisputeLetter).filter_by(analysis_id=analysis_id).all()
        if not letters:
            return (
                jsonify(
                    {"success": False, "error": "No letters found for this analysis"}
                ),
                404,
            )

        import io
        import zipfile

        # Create ZIP in memory
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
            for l in letters:
                path = str(l.file_path)
                if not os.path.exists(path):
                    continue
                # Put each PDF into the zip with a clean filename
                arcname = f"{l.client_name}_{l.bureau}_Round{l.round_number}_{l.id}.pdf"
                zf.write(path, arcname=arcname)

        zip_buffer.seek(0)
        filename = f"FCRA_Letters_Analysis_{analysis_id}.zip"

        return send_file(
            zip_buffer,
            mimetype="application/zip",
            as_attachment=True,
            download_name=filename,
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/analysis/<int:analysis_id>/review")
def review_litigation_analysis(analysis_id):
    """Litigation analysis review page"""
    return render_template("litigation_review.html", analysis_id=analysis_id)


@app.route("/api/analysis/<int:analysis_id>/data", methods=["GET"])
def get_analysis_data(analysis_id):
    """Get full analysis data for review page"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()

        return (
            jsonify(
                {
                    "success": True,
                    "analysis": {
                        "id": analysis.id,
                        "client_name": analysis.client_name,
                        "dispute_round": analysis.dispute_round,
                        "stage": analysis.stage,
                        "cost": analysis.cost,
                        "tokens_used": analysis.tokens_used,
                        "created_at": analysis.created_at.strftime("%Y-%m-%d %H:%M:%S"),
                    },
                    "violations": [
                        {
                            "id": v.id,
                            "fcra_section": v.fcra_section,
                            "violation_type": v.violation_type,
                            "description": v.description,
                            "bureau": v.bureau,
                            "account_name": v.account_name,
                            "is_willful": v.is_willful,
                            "statutory_damages_min": v.statutory_damages_min,
                            "statutory_damages_max": v.statutory_damages_max,
                            "willfulness_notes": v.willfulness_notes,
                        }
                        for v in violations
                    ],
                    "standing": (
                        {
                            "has_concrete_harm": (
                                standing.has_concrete_harm if standing else False
                            ),
                            "concrete_harm_type": (
                                standing.concrete_harm_type if standing else ""
                            ),
                            "concrete_harm_details": (
                                standing.concrete_harm_details if standing else ""
                            ),
                            "has_dissemination": (
                                standing.has_dissemination if standing else False
                            ),
                            "dissemination_details": (
                                standing.dissemination_details if standing else ""
                            ),
                            "has_causation": (
                                standing.has_causation if standing else False
                            ),
                            "causation_details": (
                                standing.causation_details if standing else ""
                            ),
                            "denial_letters_count": (
                                standing.denial_letters_count if standing else 0
                            ),
                            "adverse_action_notices_count": (
                                standing.adverse_action_notices_count if standing else 0
                            ),
                        }
                        if standing
                        else None
                    ),
                    "damages": (
                        {
                            "credit_denials_amount": (
                                damages.credit_denials_amount if damages else 0
                            ),
                            "higher_interest_amount": (
                                damages.higher_interest_amount if damages else 0
                            ),
                            "credit_monitoring_amount": (
                                damages.credit_monitoring_amount if damages else 0
                            ),
                            "time_stress_amount": (
                                damages.time_stress_amount if damages else 0
                            ),
                            "other_actual_amount": (
                                damages.other_actual_amount if damages else 0
                            ),
                            "actual_damages_total": (
                                damages.actual_damages_total if damages else 0
                            ),
                            "section_605b_count": (
                                damages.section_605b_count if damages else 0
                            ),
                            "section_605b_amount": (
                                damages.section_605b_amount if damages else 0
                            ),
                            "section_607b_count": (
                                damages.section_607b_count if damages else 0
                            ),
                            "section_607b_amount": (
                                damages.section_607b_amount if damages else 0
                            ),
                            "section_611_count": (
                                damages.section_611_count if damages else 0
                            ),
                            "section_611_amount": (
                                damages.section_611_amount if damages else 0
                            ),
                            "section_623_count": (
                                damages.section_623_count if damages else 0
                            ),
                            "section_623_amount": (
                                damages.section_623_amount if damages else 0
                            ),
                            "statutory_damages_total": (
                                damages.statutory_damages_total if damages else 0
                            ),
                            "punitive_damages_amount": (
                                damages.punitive_damages_amount if damages else 0
                            ),
                            "willfulness_multiplier": (
                                damages.willfulness_multiplier if damages else 0
                            ),
                            "settlement_target": (
                                damages.settlement_target if damages else 0
                            ),
                            "total_exposure": damages.total_exposure if damages else 0,
                        }
                        if damages
                        else None
                    ),
                    "case_score": (
                        {
                            "total_score": case_score.total_score if case_score else 0,
                            "standing_score": (
                                case_score.standing_score if case_score else 0
                            ),
                            "violation_quality_score": (
                                case_score.violation_quality_score if case_score else 0
                            ),
                            "willfulness_score": (
                                case_score.willfulness_score if case_score else 0
                            ),
                            "documentation_score": (
                                case_score.documentation_score if case_score else 0
                            ),
                            "settlement_probability": (
                                case_score.settlement_probability if case_score else 0
                            ),
                            "case_strength": (
                                case_score.case_strength if case_score else ""
                            ),
                            "recommendation": (
                                case_score.recommendation if case_score else ""
                            ),
                        }
                        if case_score
                        else None
                    ),
                }
            ),
            200,
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/internal-analysis")
def get_internal_analysis_html(analysis_id):
    """Generate Apple-style Internal Analysis HTML"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()

        html = generate_internal_analysis_html(
            analysis=analysis,
            violations=violations,
            standing=standing,
            damages=damages,
            case_score=case_score,
        )

        return html, 200, {"Content-Type": "text/html"}

    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/client-email")
def get_client_email_html(analysis_id):
    """Generate Apple-style Client Email HTML"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()

        html = generate_client_email_html(
            analysis=analysis,
            violations=violations,
            standing=standing,
            damages=damages,
            case_score=case_score,
        )

        return html, 200, {"Content-Type": "text/html"}

    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/admin/clients")
def view_all_clients():
    """View all clients and their analyses"""
    db = get_db()
    try:
        clients = db.query(Client).order_by(Client.created_at.desc()).all()

        clients_data = []
        for client in clients:
            analyses = (
                db.query(Analysis)
                .filter_by(client_id=client.id)
                .order_by(Analysis.created_at.desc())
                .all()
            )
            letters = db.query(DisputeLetter).filter_by(client_id=client.id).all()

            clients_data.append(
                {
                    "id": client.id,
                    "name": client.name,
                    "email": client.email,
                    "created_at": client.created_at.strftime("%Y-%m-%d %H:%M"),
                    "total_analyses": len(analyses),
                    "total_letters": len(letters),
                    "latest_round": analyses[0].dispute_round if analyses else 0,
                }
            )

        return jsonify({"success": True, "clients": clients_data}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/violations", methods=["GET", "POST"])
def manage_violations(analysis_id):
    """Get or add violations for an analysis"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        if request.method == "POST":
            data = request.json
            violations_data = data.get("violations", [])

            for v_data in violations_data:
                willfulness_assessment = assess_willfulness(
                    v_data.get("description", ""), v_data.get("violation_type", "")
                )

                violation = Violation(
                    analysis_id=analysis_id,
                    client_id=analysis.client_id,
                    bureau=v_data.get("bureau"),
                    account_name=v_data.get("account_name"),
                    fcra_section=v_data.get("fcra_section"),
                    violation_type=v_data.get("violation_type"),
                    description=v_data.get("description"),
                    statutory_damages_min=v_data.get("statutory_damages_min", 100),
                    statutory_damages_max=v_data.get("statutory_damages_max", 1000),
                    is_willful=willfulness_assessment["is_willful"],
                    willfulness_notes=", ".join(willfulness_assessment["indicators"]),
                )
                db.add(violation)

            db.commit()
            return (
                jsonify(
                    {
                        "success": True,
                        "message": f"Added {len(violations_data)} violations",
                    }
                ),
                200,
            )

        else:
            violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
            return (
                jsonify(
                    {
                        "success": True,
                        "violations": [
                            {
                                "id": v.id,
                                "bureau": v.bureau,
                                "account_name": v.account_name,
                                "fcra_section": v.fcra_section,
                                "violation_type": v.violation_type,
                                "description": v.description,
                                "statutory_damages_min": v.statutory_damages_min,
                                "statutory_damages_max": v.statutory_damages_max,
                                "is_willful": v.is_willful,
                                "willfulness_notes": v.willfulness_notes,
                            }
                            for v in violations
                        ],
                    }
                ),
                200,
            )
    except Exception as e:
        db.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/standing", methods=["GET", "POST"])
def manage_standing(analysis_id):
    """Get or update standing verification for an analysis"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        if request.method == "POST":
            data = request.json

            standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
            if not standing:
                standing = Standing(
                    analysis_id=analysis_id, client_id=analysis.client_id
                )
                db.add(standing)

            standing.has_concrete_harm = data.get("has_concrete_harm", False)
            standing.concrete_harm_type = data.get("concrete_harm_type")
            standing.concrete_harm_details = data.get("concrete_harm_details")
            standing.has_dissemination = data.get("has_dissemination", False)
            standing.dissemination_details = data.get("dissemination_details")
            standing.has_causation = data.get("has_causation", False)
            standing.causation_details = data.get("causation_details")
            standing.denial_letters_count = data.get("denial_letters_count", 0)
            standing.adverse_action_notices_count = data.get(
                "adverse_action_notices_count", 0
            )
            standing.standing_verified = data.get("standing_verified", False)
            standing.notes = data.get("notes")

            db.commit()
            return jsonify({"success": True, "message": "Standing updated"}), 200

        else:
            standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
            if not standing:
                return jsonify({"success": True, "standing": None}), 200

            return (
                jsonify(
                    {
                        "success": True,
                        "standing": {
                            "has_concrete_harm": standing.has_concrete_harm,
                            "concrete_harm_type": standing.concrete_harm_type,
                            "concrete_harm_details": standing.concrete_harm_details,
                            "has_dissemination": standing.has_dissemination,
                            "dissemination_details": standing.dissemination_details,
                            "has_causation": standing.has_causation,
                            "causation_details": standing.causation_details,
                            "denial_letters_count": standing.denial_letters_count,
                            "adverse_action_notices_count": standing.adverse_action_notices_count,
                            "standing_verified": standing.standing_verified,
                            "notes": standing.notes,
                        },
                    }
                ),
                200,
            )
    except Exception as e:
        db.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/damages", methods=["GET", "POST"])
def manage_damages(analysis_id):
    """Calculate and store damages for an analysis"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        if request.method == "POST":
            data = request.json

            violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
            violations_data = [
                {
                    "fcra_section": v.fcra_section,
                    "is_willful": v.is_willful,
                    "violation_type": v.violation_type,
                }
                for v in violations
            ]

            actual_damages_input = {
                "credit_denials": data.get("credit_denials_amount", 0),
                "higher_interest": data.get("higher_interest_amount", 0),
                "credit_monitoring": data.get("credit_monitoring_amount", 0),
                "time_stress": data.get("time_stress_amount", 0),
                "other": data.get("other_actual_amount", 0),
            }

            damages_calc = calculate_damages(violations_data, actual_damages_input)

            damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
            if not damages:
                damages = Damages(analysis_id=analysis_id, client_id=analysis.client_id)
                db.add(damages)

            damages.credit_denials_amount = damages_calc["actual"]["credit_denials"]
            damages.higher_interest_amount = damages_calc["actual"]["higher_interest"]
            damages.credit_monitoring_amount = damages_calc["actual"][
                "credit_monitoring"
            ]
            damages.time_stress_amount = damages_calc["actual"]["time_stress"]
            damages.other_actual_amount = damages_calc["actual"]["other"]
            damages.actual_damages_total = damages_calc["actual"]["total"]

            damages.section_605b_count = damages_calc["statutory"]["605b"]["count"]
            damages.section_605b_amount = damages_calc["statutory"]["605b"]["amount"]
            damages.section_607b_count = damages_calc["statutory"]["607b"]["count"]
            damages.section_607b_amount = damages_calc["statutory"]["607b"]["amount"]
            damages.section_611_count = damages_calc["statutory"]["611"]["count"]
            damages.section_611_amount = damages_calc["statutory"]["611"]["amount"]
            damages.section_623_count = damages_calc["statutory"]["623"]["count"]
            damages.section_623_amount = damages_calc["statutory"]["623"]["amount"]
            damages.statutory_damages_total = damages_calc["statutory"]["total"]

            damages.willfulness_multiplier = damages_calc["punitive"]["multiplier"]
            damages.punitive_damages_amount = damages_calc["punitive"]["amount"]

            damages.estimated_hours = damages_calc["attorney_fees"]["estimated_hours"]
            damages.hourly_rate = damages_calc["attorney_fees"]["hourly_rate"]
            damages.attorney_fees_projection = damages_calc["attorney_fees"]["total"]

            damages.total_exposure = damages_calc["settlement"]["total_exposure"]
            damages.settlement_target = damages_calc["settlement"]["target"]
            damages.minimum_acceptable = damages_calc["settlement"]["minimum"]

            damages.notes = data.get("notes")

            db.commit()

            return jsonify({"success": True, "damages": damages_calc}), 200

        else:
            damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
            if not damages:
                return jsonify({"success": True, "damages": None}), 200

            return (
                jsonify(
                    {
                        "success": True,
                        "damages": {
                            "actual": {
                                "credit_denials": damages.credit_denials_amount,
                                "higher_interest": damages.higher_interest_amount,
                                "credit_monitoring": damages.credit_monitoring_amount,
                                "time_stress": damages.time_stress_amount,
                                "other": damages.other_actual_amount,
                                "total": damages.actual_damages_total,
                            },
                            "statutory": {
                                "605b": {
                                    "count": damages.section_605b_count,
                                    "amount": damages.section_605b_amount,
                                },
                                "607b": {
                                    "count": damages.section_607b_count,
                                    "amount": damages.section_607b_amount,
                                },
                                "611": {
                                    "count": damages.section_611_count,
                                    "amount": damages.section_611_amount,
                                },
                                "623": {
                                    "count": damages.section_623_count,
                                    "amount": damages.section_623_amount,
                                },
                                "total": damages.statutory_damages_total,
                            },
                            "punitive": {
                                "multiplier": damages.willfulness_multiplier,
                                "amount": damages.punitive_damages_amount,
                            },
                            "attorney_fees": {
                                "estimated_hours": damages.estimated_hours,
                                "hourly_rate": damages.hourly_rate,
                                "total": damages.attorney_fees_projection,
                            },
                            "settlement": {
                                "total_exposure": damages.total_exposure,
                                "target": damages.settlement_target,
                                "minimum": damages.minimum_acceptable,
                            },
                        },
                    }
                ),
                200,
            )
    except Exception as e:
        db.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/score", methods=["GET", "POST"])
def get_case_score(analysis_id):
    """Calculate and retrieve case strength score"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()

        standing_data = {
            "has_concrete_harm": standing.has_concrete_harm if standing else False,
            "has_dissemination": standing.has_dissemination if standing else False,
            "has_causation": standing.has_causation if standing else False,
        }

        violations_data = [
            {"violation_type": v.violation_type, "is_willful": v.is_willful}
            for v in violations
        ]

        damages_data = {}
        if damages:
            damages_data = {
                "total_exposure": damages.total_exposure,
                "statutory_total": damages.statutory_damages_total,
            }

        documentation_complete = (
            standing.denial_letters_count > 0 if standing else False
        )

        score_result = calculate_case_score(
            standing_data, violations_data, damages_data, documentation_complete
        )

        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()
        if not case_score:
            case_score = CaseScore(
                analysis_id=analysis_id, client_id=analysis.client_id
            )
            db.add(case_score)

        case_score.standing_score = score_result["standing"]
        case_score.violation_quality_score = score_result["violation_quality"]
        case_score.willfulness_score = score_result["willfulness"]
        case_score.documentation_score = score_result["documentation"]
        case_score.total_score = score_result["total"]
        case_score.settlement_probability = score_result["settlement_probability"]
        case_score.case_strength = score_result["case_strength"]
        case_score.recommendation = score_result["recommendation"]
        case_score.recommendation_notes = "\n".join(score_result["notes"])

        db.commit()

        return jsonify({"success": True, "score": score_result}), 200
    except Exception as e:
        db.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/complete")
def get_complete_analysis(analysis_id):
    """Get complete litigation analysis including violations, damages, standing, and score"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()
        letters = db.query(DisputeLetter).filter_by(analysis_id=analysis_id).all()

        return (
            jsonify(
                {
                    "success": True,
                    "analysis": {
                        "id": analysis.id,
                        "client_name": analysis.client_name,
                        "dispute_round": analysis.dispute_round,
                        "analysis_mode": analysis.analysis_mode,
                        "cost": analysis.cost,
                        "created_at": analysis.created_at.strftime("%Y-%m-%d %H:%M"),
                    },
                    "violations": [
                        {
                            "id": v.id,
                            "bureau": v.bureau,
                            "account_name": v.account_name,
                            "fcra_section": v.fcra_section,
                            "violation_type": v.violation_type,
                            "description": v.description,
                            "is_willful": v.is_willful,
                            "statutory_damages_min": v.statutory_damages_min,
                            "statutory_damages_max": v.statutory_damages_max,
                        }
                        for v in violations
                    ],
                    "standing": (
                        {
                            "has_concrete_harm": (
                                standing.has_concrete_harm if standing else False
                            ),
                            "concrete_harm_type": (
                                standing.concrete_harm_type if standing else None
                            ),
                            "has_dissemination": (
                                standing.has_dissemination if standing else False
                            ),
                            "has_causation": (
                                standing.has_causation if standing else False
                            ),
                            "denial_letters_count": (
                                standing.denial_letters_count if standing else 0
                            ),
                            "standing_verified": (
                                standing.standing_verified if standing else False
                            ),
                        }
                        if standing
                        else None
                    ),
                    "damages": (
                        {
                            "actual_total": (
                                damages.actual_damages_total if damages else 0
                            ),
                            "statutory_total": (
                                damages.statutory_damages_total if damages else 0
                            ),
                            "punitive_total": (
                                damages.punitive_damages_amount if damages else 0
                            ),
                            "attorney_fees": (
                                damages.attorney_fees_projection if damages else 0
                            ),
                            "total_exposure": damages.total_exposure if damages else 0,
                            "settlement_target": (
                                damages.settlement_target if damages else 0
                            ),
                            "minimum_acceptable": (
                                damages.minimum_acceptable if damages else 0
                            ),
                        }
                        if damages
                        else None
                    ),
                    "case_score": (
                        {
                            "total_score": case_score.total_score if case_score else 0,
                            "standing_score": (
                                case_score.standing_score if case_score else 0
                            ),
                            "violation_quality_score": (
                                case_score.violation_quality_score if case_score else 0
                            ),
                            "willfulness_score": (
                                case_score.willfulness_score if case_score else 0
                            ),
                            "documentation_score": (
                                case_score.documentation_score if case_score else 0
                            ),
                            "settlement_probability": (
                                case_score.settlement_probability if case_score else 0
                            ),
                            "case_strength": (
                                case_score.case_strength if case_score else "Unknown"
                            ),
                            "recommendation": (
                                case_score.recommendation
                                if case_score
                                else "Not scored"
                            ),
                        }
                        if case_score
                        else None
                    ),
                    "letters": [
                        {
                            "id": l.id,
                            "bureau": l.bureau,
                            "round": l.round_number,
                            "file_path": l.file_path,
                        }
                        for l in letters
                    ],
                }
            ),
            200,
        )
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# DASHBOARD & PLATFORM ROUTES
# ============================================================


def generate_case_number():
    """Generate unique case number like BA-2024-00001"""
    year = datetime.utcnow().year
    db = get_db()
    try:
        count = db.query(Case).filter(Case.case_number.like(f"BA-{year}-%")).count()
        return f"BA-{year}-{str(count + 1).zfill(5)}"
    finally:
        db.close()


def generate_referral_code():
    """Generate unique referral code like BP1A2B3C4D"""
    return "BP" + secrets.token_hex(4).upper()


def get_status_label(status):
    """Convert status code to readable label"""
    labels = {
        "intake": "Intake",
        "stage1_pending": "Analyzing...",
        "stage1_complete": "Needs Review",
        "stage2_pending": "Generating Docs...",
        "stage2_complete": "Ready",
        "delivered": "Delivered",
        "settled": "Settled",
    }
    return labels.get(status, status)


@app.route("/dashboard")
@require_staff()
def dashboard():
    """Main admin dashboard"""
    db = get_db()
    try:
        from datetime import timedelta

        all_analyses = db.query(Analysis).all()
        all_damages = db.query(Damages).all()
        all_scores = db.query(CaseScore).all()

        total_exposure = sum(d.total_exposure or 0 for d in all_damages)
        active_cases = len(all_analyses)
        one_week_ago = datetime.utcnow() - timedelta(days=7)
        new_this_week = (
            db.query(Analysis).filter(Analysis.created_at >= one_week_ago).count()
        )

        scores = [s.total_score for s in all_scores if s.total_score]
        avg_score = sum(scores) / len(scores) if scores else 0
        high_score_cases = len([s for s in scores if s >= 8])

        pending_review = (
            db.query(Analysis)
            .filter(Analysis.stage == 1, Analysis.approved_at == None)
            .count()
        )

        stats = {
            "total_exposure": total_exposure,
            "active_cases": active_cases,
            "new_this_week": new_this_week,
            "avg_score": avg_score,
            "high_score_cases": high_score_cases,
            "pending_review": pending_review,
        }

        stage1_complete_count = (
            db.query(Analysis)
            .filter(Analysis.stage == 1, Analysis.approved_at == None)
            .count()
        )
        stage2_complete_count = db.query(Analysis).filter(Analysis.stage == 2).count()
        stage2_value = sum(
            (d.total_exposure or 0)
            for d in db.query(Damages).join(Analysis).filter(Analysis.stage == 2).all()
        )

        pipeline = {
            "intake": 0,
            "stage1_pending": 0,
            "stage1_complete": stage1_complete_count,
            "stage2_pending": 0,
            "stage2_complete": stage2_complete_count,
            "stage2_value": stage2_value,
            "delivered": 0,
        }

        recent_analyses = (
            db.query(Analysis).order_by(Analysis.created_at.desc()).limit(20).all()
        )
        cases = []
        for analysis in recent_analyses:
            damages = db.query(Damages).filter_by(analysis_id=analysis.id).first()
            score = db.query(CaseScore).filter_by(analysis_id=analysis.id).first()
            client = db.query(Client).filter_by(id=analysis.client_id).first()

            if analysis.stage == 1 and not analysis.approved_at:
                status = "stage1_complete"
            elif analysis.stage == 2:
                status = "stage2_complete"
            else:
                status = "intake"

            cases.append(
                {
                    "id": analysis.id,
                    "analysis_id": analysis.id,
                    "client_name": analysis.client_name,
                    "client_email": client.email if client else None,
                    "avatar_filename": client.avatar_filename if client else None,
                    "status": status,
                    "status_label": get_status_label(status),
                    "score": score.total_score if score else None,
                    "exposure": damages.total_exposure if damages else None,
                }
            )

        recent_activity = []
        for analysis in (
            db.query(Analysis).order_by(Analysis.created_at.desc()).limit(5).all()
        ):
            if analysis.stage == 2:
                recent_activity.append(
                    {
                        "title": f"{analysis.client_name}",
                        "description": "Documents ready for delivery",
                        "color": "green",
                        "time": analysis.created_at.strftime("%I:%M %p"),
                    }
                )
            elif analysis.stage == 1:
                recent_activity.append(
                    {
                        "title": f"{analysis.client_name}",
                        "description": "Stage 1 analysis complete",
                        "color": "blue",
                        "time": analysis.created_at.strftime("%I:%M %p"),
                    }
                )

        return render_template(
            "dashboard.html",
            stats=stats,
            pipeline=pipeline,
            cases=cases,
            recent_activity=recent_activity,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Dashboard error: {str(e)}", 500
    finally:
        db.close()


@app.route("/analysis")
def analysis_redirect():
    """Redirect to analyses dashboard"""
    return redirect(url_for("analyses_page"))


@app.route("/dashboard/analyses")
@require_staff()
def analyses_page():
    """Case analyses management page"""
    db = get_db()
    try:
        # Get all clients with their latest analysis
        from sqlalchemy import func, outerjoin

        clients = db.query(Client).all()
        all_clients = [{"id": c.id, "name": c.name, "email": c.email} for c in clients]

        # Build analyses list
        analyses = []
        for client in clients:
            # Get latest analysis for this client
            analysis = (
                db.query(Analysis)
                .filter_by(client_id=client.id)
                .order_by(Analysis.created_at.desc())
                .first()
            )

            item = {
                "client_id": client.id,
                "client_name": client.name,
                "client_email": client.email,
                "analysis_id": None,
                "stage": 0,
                "violation_count": 0,
                "case_score": None,
                "settlement_target": None,
                "created_at": None,
            }

            if analysis:
                item["analysis_id"] = analysis.id
                item["stage"] = analysis.stage or 1
                item["created_at"] = analysis.created_at

                # Get violation count
                violation_count = (
                    db.query(Violation).filter_by(analysis_id=analysis.id).count()
                )
                item["violation_count"] = violation_count

                # Get case score
                case_score = (
                    db.query(CaseScore).filter_by(analysis_id=analysis.id).first()
                )
                if case_score:
                    item["case_score"] = case_score.total_score

                # Get damages
                damages = db.query(Damages).filter_by(analysis_id=analysis.id).first()
                if damages:
                    item["settlement_target"] = damages.settlement_target

            analyses.append(item)

        # Sort by stage (pending first) then by date
        analyses.sort(
            key=lambda x: (
                -(x["stage"] or 0) if x["stage"] == 1 else x["stage"] or 0,
                x["created_at"] or datetime.min,
            ),
            reverse=True,
        )

        # Calculate stats
        total = len([a for a in analyses if a["analysis_id"]])
        pending = len([a for a in analyses if a["stage"] == 1])
        complete = len([a for a in analyses if a["stage"] == 2])
        none_count = len([a for a in analyses if a["stage"] == 0])
        total_value = sum(a["settlement_target"] or 0 for a in analyses)

        stats = {
            "total": total,
            "pending": pending,
            "complete": complete,
            "none": none_count,
            "total_value": total_value,
            # Required by dashboard.html base template
            "total_exposure": total_value,
            "active_cases": total,
            "new_this_week": 0,
            "avg_score": 0,
            "high_score_cases": 0,
            "pending_review": pending,
        }

        return render_template(
            "analyses.html",
            analyses=analyses,
            all_clients=all_clients,
            stats=stats,
            active_page="analyses",
        )
    finally:
        db.close()


@app.route("/dashboard/analytics")
@require_staff()
def dashboard_analytics():
    """Analytics and Reporting Dashboard - Business Intelligence Metrics"""
    db = get_db()
    try:
        from datetime import timedelta

        from sqlalchemy import extract, func

        now = datetime.utcnow()
        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        start_of_last_month = (start_of_month - timedelta(days=1)).replace(day=1)
        thirty_days_ago = now - timedelta(days=30)

        # ========== CLIENT STATS ==========
        total_clients = db.query(Client).count()
        new_this_month = (
            db.query(Client).filter(Client.created_at >= start_of_month).count()
        )

        # Client status breakdown
        active_clients = db.query(Client).filter(Client.status == "active").count()
        paused_clients = db.query(Client).filter(Client.status == "paused").count()
        complete_clients = db.query(Client).filter(Client.status == "complete").count()
        signup_clients = db.query(Client).filter(Client.status == "signup").count()

        client_stats = {
            "total": total_clients,
            "new_this_month": new_this_month,
            "active": active_clients,
            "paused": paused_clients,
            "complete": complete_clients,
            "signup": signup_clients,
        }

        # ========== REVENUE STATS ==========
        total_revenue_cents = (
            db.query(func.sum(Client.signup_amount))
            .filter(Client.payment_status == "paid", Client.signup_amount.isnot(None))
            .scalar()
            or 0
        )
        total_revenue = total_revenue_cents / 100

        this_month_revenue_cents = (
            db.query(func.sum(Client.signup_amount))
            .filter(
                Client.payment_status == "paid",
                Client.signup_amount.isnot(None),
                Client.payment_received_at >= start_of_month,
            )
            .scalar()
            or 0
        )
        this_month_revenue = this_month_revenue_cents / 100

        last_month_revenue_cents = (
            db.query(func.sum(Client.signup_amount))
            .filter(
                Client.payment_status == "paid",
                Client.signup_amount.isnot(None),
                Client.payment_received_at >= start_of_last_month,
                Client.payment_received_at < start_of_month,
            )
            .scalar()
            or 0
        )
        last_month_revenue = last_month_revenue_cents / 100

        tier_revenue = {}
        for tier in ["tier1", "tier2", "tier3", "tier4", "tier5", "free"]:
            tier_cents = (
                db.query(func.sum(Client.signup_amount))
                .filter(
                    Client.payment_status == "paid",
                    Client.signup_plan == tier,
                    Client.signup_amount.isnot(None),
                )
                .scalar()
                or 0
            )
            tier_revenue[tier] = tier_cents / 100

        revenue_stats = {
            "total": total_revenue,
            "this_month": this_month_revenue,
            "last_month": last_month_revenue,
            "by_tier": tier_revenue,
            "month_change": this_month_revenue - last_month_revenue,
        }

        # ========== CASE STATS ==========
        total_analyses = db.query(Analysis).count()

        round_counts = {}
        for round_num in [1, 2, 3, 4]:
            count = (
                db.query(Analysis).filter(Analysis.dispute_round == round_num).count()
            )
            round_counts[f"round_{round_num}"] = count

        all_scores = (
            db.query(CaseScore.total_score)
            .filter(CaseScore.total_score.isnot(None))
            .all()
        )
        avg_case_score = (
            sum(s[0] for s in all_scores) / len(all_scores) if all_scores else 0
        )

        high_score = len([s for s in all_scores if s[0] >= 8])
        medium_score = len([s for s in all_scores if 5 <= s[0] < 8])
        low_score = len([s for s in all_scores if s[0] < 5])

        case_stats = {
            "total_analyses": total_analyses,
            "by_round": round_counts,
            "avg_score": round(avg_case_score, 1),
            "high_score": high_score,
            "medium_score": medium_score,
            "low_score": low_score,
        }

        # ========== DISPUTE PROGRESS ==========
        total_items = db.query(DisputeItem).count()
        items_deleted = (
            db.query(DisputeItem).filter(DisputeItem.status == "deleted").count()
        )
        items_updated = (
            db.query(DisputeItem).filter(DisputeItem.status == "updated").count()
        )
        items_verified = (
            db.query(DisputeItem).filter(DisputeItem.status == "verified").count()
        )
        items_sent = db.query(DisputeItem).filter(DisputeItem.status == "sent").count()
        items_in_progress = (
            db.query(DisputeItem).filter(DisputeItem.status == "in_progress").count()
        )
        items_no_change = (
            db.query(DisputeItem).filter(DisputeItem.status == "no_change").count()
        )

        completed_items = items_deleted + items_verified + items_no_change
        success_rate = (
            (items_deleted / completed_items * 100) if completed_items > 0 else 0
        )

        dispute_stats = {
            "total_items": total_items,
            "deleted": items_deleted,
            "updated": items_updated,
            "verified": items_verified,
            "sent": items_sent,
            "in_progress": items_in_progress,
            "no_change": items_no_change,
            "success_rate": round(success_rate, 1),
        }

        # ========== CRA RESPONSE STATS ==========
        total_responses = db.query(CRAResponse).count()
        response_types = {}
        for rtype in [
            "verified",
            "deleted",
            "updated",
            "investigating",
            "no_response",
            "frivolous",
        ]:
            count = (
                db.query(CRAResponse).filter(CRAResponse.response_type == rtype).count()
            )
            response_types[rtype] = count

        cra_stats = {"total_responses": total_responses, "by_type": response_types}

        # ========== TIMELINE DATA (Last 30 days) ==========
        signup_data = []
        revenue_data = []

        for i in range(30, -1, -1):
            day = now - timedelta(days=i)
            day_start = day.replace(hour=0, minute=0, second=0, microsecond=0)
            day_end = day_start + timedelta(days=1)

            day_signups = (
                db.query(Client)
                .filter(Client.created_at >= day_start, Client.created_at < day_end)
                .count()
            )
            signup_data.append(
                {
                    "date": day_start.strftime("%Y-%m-%d"),
                    "label": day_start.strftime("%b %d"),
                    "count": day_signups,
                }
            )

            day_revenue_cents = (
                db.query(func.sum(Client.signup_amount))
                .filter(
                    Client.payment_status == "paid",
                    Client.payment_received_at >= day_start,
                    Client.payment_received_at < day_end,
                    Client.signup_amount.isnot(None),
                )
                .scalar()
                or 0
            )
            revenue_data.append(
                {
                    "date": day_start.strftime("%Y-%m-%d"),
                    "label": day_start.strftime("%b %d"),
                    "amount": day_revenue_cents / 100,
                }
            )

        timeline_data = {"signups": signup_data, "revenue": revenue_data}

        # ========== VA LETTER AUTOMATION STATS ==========
        total_letters = db.query(func.sum(LetterBatch.letter_count)).scalar() or 0
        total_cost_cents = db.query(func.sum(LetterBatch.cost_cents)).scalar() or 0

        pending_approval = (
            db.query(DisputeLetter)
            .filter(
                DisputeLetter.sent_via_letterstream == False,
                DisputeLetter.file_path.isnot(None),
            )
            .count()
        )

        unique_clients_count = (
            db.query(func.count(func.distinct(DisputeLetter.client_id)))
            .filter(DisputeLetter.sent_via_letterstream == True)
            .scalar()
            or 0
        )
        avg_cost_per_client = (
            (total_cost_cents / unique_clients_count) if unique_clients_count > 0 else 0
        )

        recent_batches = (
            db.query(LetterBatch)
            .order_by(LetterBatch.uploaded_at.desc())
            .limit(10)
            .all()
        )

        thirty_five_days_ago = now - timedelta(days=35)
        overdue_responses = (
            db.query(CaseDeadline)
            .filter(
                CaseDeadline.deadline_type == "cra_response",
                CaseDeadline.deadline_date < thirty_five_days_ago,
                CaseDeadline.status != "completed",
            )
            .count()
        )

        reinsertion_violations = (
            db.query(TradelineStatus)
            .filter(TradelineStatus.current_status == "reinsertion_violation")
            .count()
        )

        items_deleted_sum = (
            db.query(func.sum(AutomationMetrics.items_deleted)).scalar() or 0
        )
        items_disputed_sum = (
            db.query(func.sum(AutomationMetrics.items_disputed)).scalar() or 0
        )
        deletion_rate = (
            (items_deleted_sum / items_disputed_sum * 100)
            if items_disputed_sum > 0
            else 0
        )

        automation_stats = {
            "total_letters": total_letters,
            "total_cost": total_cost_cents,
            "pending_approval": pending_approval,
            "avg_cost_per_client": avg_cost_per_client,
            "recent_batches": recent_batches,
            "overdue_responses": overdue_responses,
            "reinsertion_violations": reinsertion_violations,
            "deletion_rate": round(deletion_rate, 1),
            "items_deleted": items_deleted_sum,
            "items_disputed": items_disputed_sum,
        }

        return render_template(
            "analytics.html",
            client_stats=client_stats,
            revenue_stats=revenue_stats,
            case_stats=case_stats,
            dispute_stats=dispute_stats,
            cra_stats=cra_stats,
            timeline_data=timeline_data,
            automation_stats=automation_stats,
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Analytics error: {str(e)}", 500
    finally:
        db.close()


@app.route("/dashboard/predictive")
@require_staff(roles=["admin", "attorney"])
def dashboard_predictive():
    """Predictive Analytics Dashboard - renders analytics template with predictive section"""
    # Default empty data for all template variables
    default_data = {
        "revenue_forecast": {"success": False, "forecasts": []},
        "caseload_forecast": {"success": False, "forecasts": []},
        "growth_opportunities": [],
        "workload_distribution": {"success": False, "distribution": []},
        "revenue_trends": {"success": False, "trends": []},
        "top_clients": {"success": False, "top_clients": []},
        "leaderboard": {"success": False, "staff": []},
        "summary": {"success": False, "totals": {}},
    }

    try:
        # Get predictive analytics data
        revenue_forecast = predictive_analytics_service.forecast_revenue(months_ahead=3)
        caseload_forecast = predictive_analytics_service.forecast_caseload(
            months_ahead=3
        )

        # Get growth opportunities for top clients
        db = get_db()
        clients = db.query(Client).order_by(Client.created_at.desc()).limit(10).all()
        growth_opportunities = []
        for client in clients:
            opp = predictive_analytics_service.identify_growth_opportunities(client.id)
            if opp.get("success"):
                growth_opportunities.append({"client": client, **opp})

        # Get workload distribution
        workload_distribution = attorney_analytics_service.get_workload_distribution()

        # Get leaderboard data
        leaderboard = attorney_analytics_service.get_leaderboard()

        db.close()

        return render_template(
            "predictive_analytics.html",
            revenue_forecast=revenue_forecast,
            caseload_forecast=caseload_forecast,
            growth_opportunities=growth_opportunities,
            workload_distribution=workload_distribution,
            revenue_trends={"success": True, "trends": []},
            top_clients={"success": True, "top_clients": []},
            leaderboard=leaderboard,
            summary={"success": True, "totals": {}},
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        # Return template with empty/default data on error
        return render_template("predictive_analytics.html", **default_data)


@app.route("/api/analytics/revenue-forecast")
@require_staff(roles=["admin", "attorney"])
def api_revenue_forecast():
    """API: Get revenue forecasts"""
    try:
        months = request.args.get("months", 3, type=int)
        result = predictive_analytics_service.forecast_revenue(months_ahead=months)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/client-ltv/<int:client_id>")
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_client_ltv(client_id):
    """API: Get client lifetime value estimation"""
    try:
        result = predictive_analytics_service.calculate_client_ltv(client_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/case-timeline/<int:client_id>")
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_case_timeline(client_id):
    """API: Get predicted case timeline"""
    try:
        result = predictive_analytics_service.predict_case_timeline(client_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/settlement-probability/<int:client_id>")
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_settlement_probability(client_id):
    """API: Get settlement probability prediction"""
    try:
        result = predictive_analytics_service.predict_settlement_probability(client_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/churn-risk/<int:client_id>")
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_churn_risk(client_id):
    """API: Get client churn risk assessment"""
    try:
        result = predictive_analytics_service.calculate_churn_risk(client_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/attorney-performance")
@require_staff(roles=["admin", "attorney"])
def api_attorney_performance():
    """API: Get attorney performance metrics"""
    try:
        staff_id = request.args.get("staff_id", type=int)
        period = request.args.get("period", "month")

        if staff_id:
            result = attorney_analytics_service.calculate_performance(staff_id, period)
        else:
            result = attorney_analytics_service.get_workload_distribution()
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/attorney-leaderboard")
@require_staff(roles=["admin", "attorney"])
def api_attorney_leaderboard():
    """API: Get attorney performance rankings"""
    try:
        metric = request.args.get("metric", "efficiency_score")
        period = request.args.get("period", "month")
        result = attorney_analytics_service.get_leaderboard(metric, period)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/attorney-strengths/<int:staff_id>")
@require_staff(roles=["admin", "attorney"])
def api_attorney_strengths(staff_id):
    """API: Get attorney strengths analysis"""
    try:
        result = attorney_analytics_service.identify_strengths(staff_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/growth-opportunities")
@require_staff(roles=["admin", "attorney"])
def api_growth_opportunities():
    """API: Get growth opportunity insights"""
    try:
        result = predictive_analytics_service.identify_growth_opportunities()
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/case-assignment-recommendation/<int:case_id>")
@require_staff(roles=["admin", "attorney"])
def api_case_assignment_recommendation(case_id):
    """API: Get best attorney recommendation for a case"""
    try:
        result = attorney_analytics_service.recommend_case_assignment(case_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/attorney-capacity/<int:staff_id>")
@require_staff(roles=["admin", "attorney"])
def api_attorney_capacity(staff_id):
    """API: Get attorney capacity forecast"""
    try:
        result = attorney_analytics_service.forecast_capacity(staff_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/caseload-forecast")
@require_staff(roles=["admin", "attorney"])
def api_caseload_forecast():
    """API: Get caseload forecast"""
    try:
        months = request.args.get("months", 3, type=int)
        result = predictive_analytics_service.forecast_caseload(months_ahead=months)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/analytics/revenue-trends")
@require_staff(roles=["admin", "attorney"])
def api_revenue_trends():
    """API: Get historical revenue trends"""
    try:
        result = predictive_analytics_service.get_revenue_trends()
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# =============================================================================
# Revenue Dashboard (Priority 13)
# =============================================================================


@app.route("/dashboard/revenue")
@require_staff(roles=["admin", "attorney"])
def dashboard_revenue():
    """Revenue Dashboard - MRR, LTV, Churn, and Financial Metrics"""
    db = get_db()
    try:
        from services.revenue_metrics_service import get_revenue_metrics_service

        service = get_revenue_metrics_service(db)

        # Get dashboard summary
        summary = service.get_dashboard_summary()
        chart_data = service.get_revenue_chart_data("month", 12)
        top_affiliates = service.get_top_affiliates(5)
        payment_methods = service.get_revenue_by_payment_method()
        plans = service.get_revenue_by_plan()

        return render_template(
            "revenue_dashboard.html",
            summary=summary,
            chart_data=chart_data,
            top_affiliates=top_affiliates,
            payment_methods=payment_methods,
            plans=plans,
            active_page="revenue",
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return render_template(
            "revenue_dashboard.html",
            summary={},
            chart_data={"labels": [], "datasets": {"revenue": [], "clients": []}},
            top_affiliates=[],
            payment_methods={},
            plans={},
            active_page="revenue",
            error=str(e),
        )
    finally:
        db.close()


@app.route("/api/revenue/summary")
@require_staff(roles=["admin", "attorney"])
def api_revenue_summary():
    """API: Get revenue dashboard summary"""
    db = get_db()
    try:
        from services.revenue_metrics_service import get_revenue_metrics_service

        service = get_revenue_metrics_service(db)
        summary = service.get_dashboard_summary()
        return jsonify({"success": True, **summary})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/revenue/by-period")
@require_staff(roles=["admin", "attorney"])
def api_revenue_by_period():
    """API: Get revenue by time period"""
    db = get_db()
    try:
        from services.revenue_metrics_service import get_revenue_metrics_service

        period = request.args.get("period", "month")
        limit = request.args.get("limit", 12, type=int)

        service = get_revenue_metrics_service(db)
        data = service.get_revenue_by_period(period, limit)
        return jsonify({"success": True, "data": data})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/revenue/mrr")
@require_staff(roles=["admin", "attorney"])
def api_revenue_mrr():
    """API: Get MRR/ARR metrics"""
    db = get_db()
    try:
        from services.revenue_metrics_service import get_revenue_metrics_service

        service = get_revenue_metrics_service(db)
        mrr = service.get_mrr()
        mrr_growth = service.get_mrr_growth(6)
        return jsonify({"success": True, "mrr": mrr, "growth": mrr_growth})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/revenue/churn")
@require_staff(roles=["admin", "attorney"])
def api_revenue_churn():
    """API: Get churn and retention metrics"""
    db = get_db()
    try:
        from services.revenue_metrics_service import get_revenue_metrics_service

        service = get_revenue_metrics_service(db)
        churn = service.get_churn_rate(30)
        cohorts = service.get_client_retention_cohorts(6)
        return jsonify({"success": True, "churn": churn, "cohorts": cohorts})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/revenue/export")
@require_staff(roles=["admin"])
def api_revenue_export():
    """API: Export revenue data as CSV"""
    db = get_db()
    try:
        import csv
        from io import StringIO

        from services.revenue_metrics_service import get_revenue_metrics_service

        # Parse date filters with validation
        start_date = None
        end_date = None
        try:
            if request.args.get("start"):
                start_date = datetime.fromisoformat(request.args.get("start"))
            if request.args.get("end"):
                end_date = datetime.fromisoformat(request.args.get("end"))
        except ValueError:
            return (
                jsonify({"error": "Invalid date format. Use ISO format (YYYY-MM-DD)"}),
                400,
            )

        service = get_revenue_metrics_service(db)
        data = service.export_revenue_data(start_date, end_date)

        # Create CSV
        output = StringIO()
        writer = csv.DictWriter(
            output,
            fieldnames=[
                "client_id",
                "name",
                "email",
                "plan",
                "amount_dollars",
                "status",
                "method",
                "payment_date",
                "signup_date",
            ],
        )
        writer.writeheader()
        for row in data:
            writer.writerow(
                {
                    "client_id": row["client_id"],
                    "name": row["name"],
                    "email": row["email"],
                    "plan": row["plan"],
                    "amount_dollars": row["amount_dollars"],
                    "status": row["status"],
                    "method": row["method"],
                    "payment_date": row["payment_date"],
                    "signup_date": row["signup_date"],
                }
            )

        # Return as downloadable CSV
        from flask import Response

        output.seek(0)
        return Response(
            output.getvalue(),
            mimetype="text/csv",
            headers={"Content-Disposition": "attachment; filename=revenue_export.csv"},
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# =============================================================================
# SUBSCRIPTION MANAGEMENT ENDPOINTS
# =============================================================================


@app.route("/api/subscriptions/plans")
def api_subscription_plans():
    """API: Get available subscription plans"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        service = get_subscription_service(db)
        plans = service.get_plans(active_only=True)
        return jsonify({"success": True, "plans": plans})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/subscriptions/sync-plans", methods=["POST"])
@require_staff(roles=["admin"])
def api_sync_subscription_plans():
    """API: Sync subscription plans to Stripe (admin only)"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        service = get_subscription_service(db)
        results = service.sync_plans_to_stripe()
        return jsonify({"success": True, "results": results})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/subscription")
@require_staff()
def api_get_client_subscription(client_id):
    """API: Get client's subscription details"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        service = get_subscription_service(db)
        subscription = service.get_subscription(client_id)
        return jsonify({"success": True, "subscription": subscription})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/subscription/checkout", methods=["POST"])
@require_staff()
def api_create_subscription_checkout(client_id):
    """API: Create a Stripe checkout session for subscription"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        data = request.json or {}
        plan_name = data.get("plan_name", "basic")

        # Build URLs
        base_url = request.host_url.rstrip("/")
        success_url = (
            data.get("success_url")
            or f"{base_url}/dashboard/clients/{client_id}?subscription=success"
        )
        cancel_url = (
            data.get("cancel_url")
            or f"{base_url}/dashboard/clients/{client_id}?subscription=cancelled"
        )

        service = get_subscription_service(db)
        result = service.create_checkout_session(
            client_id=client_id,
            plan_name=plan_name,
            success_url=success_url,
            cancel_url=cancel_url,
        )
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/subscription/create", methods=["POST"])
@require_staff()
def api_create_subscription(client_id):
    """API: Create subscription directly with saved payment method"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        data = request.json or {}
        plan_name = data.get("plan_name", "basic")
        payment_method_id = data.get("payment_method_id")

        service = get_subscription_service(db)
        result = service.create_subscription(
            client_id=client_id,
            plan_name=plan_name,
            payment_method_id=payment_method_id,
        )
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/subscription/cancel", methods=["POST"])
@require_staff()
def api_cancel_subscription(client_id):
    """API: Cancel client's subscription"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        data = request.json or {}
        at_period_end = data.get("at_period_end", True)
        reason = data.get("reason")

        service = get_subscription_service(db)
        result = service.cancel_subscription(
            client_id=client_id, at_period_end=at_period_end, reason=reason
        )
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/subscription/reactivate", methods=["POST"])
@require_staff()
def api_reactivate_subscription(client_id):
    """API: Reactivate a subscription scheduled for cancellation"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        service = get_subscription_service(db)
        result = service.reactivate_subscription(client_id)
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/subscription/change-plan", methods=["POST"])
@require_staff()
def api_change_subscription_plan(client_id):
    """API: Upgrade or downgrade subscription plan"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        data = request.json or {}
        new_plan_name = data.get("plan_name")

        if not new_plan_name:
            return jsonify({"success": False, "error": "plan_name is required"}), 400

        service = get_subscription_service(db)
        result = service.change_plan(client_id, new_plan_name)
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/subscription/billing-portal", methods=["POST"])
@require_staff()
def api_create_billing_portal(client_id):
    """API: Create Stripe billing portal session"""
    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        data = request.json or {}
        base_url = request.host_url.rstrip("/")
        return_url = (
            data.get("return_url") or f"{base_url}/dashboard/clients/{client_id}"
        )

        service = get_subscription_service(db)
        result = service.create_billing_portal_session(client_id, return_url)
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/webhooks/stripe/subscriptions", methods=["POST"])
def api_stripe_subscription_webhook():
    """API: Handle Stripe subscription webhooks"""
    db = get_db()
    try:
        import stripe

        from services.stripe_client import get_webhook_secret
        from services.subscription_service import get_subscription_service

        payload = request.get_data()
        sig_header = request.headers.get("Stripe-Signature")
        webhook_secret = get_webhook_secret()

        # Verify webhook signature
        if webhook_secret:
            try:
                event = stripe.Webhook.construct_event(
                    payload, sig_header, webhook_secret
                )
            except stripe.error.SignatureVerificationError:
                return jsonify({"error": "Invalid signature"}), 400
        else:
            import json

            event_data = json.loads(payload)
            event = stripe.Event.construct_from(event_data, stripe.api_key)

        # Handle the event
        service = get_subscription_service(db)
        result = service.handle_webhook_event(event)

        return jsonify({"success": True, **result})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


# Portal endpoints for client self-service
@app.route("/portal/api/subscription")
def portal_api_get_subscription():
    """Portal API: Get current client's subscription"""
    client = get_portal_client()
    if not client:
        return jsonify({"success": False, "error": "Not authenticated"}), 401

    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        service = get_subscription_service(db)
        subscription = service.get_subscription(client.id)
        return jsonify({"success": True, "subscription": subscription})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/portal/api/subscription/checkout", methods=["POST"])
def portal_api_subscription_checkout():
    """Portal API: Create checkout session for client"""
    client = get_portal_client()
    if not client:
        return jsonify({"success": False, "error": "Not authenticated"}), 401

    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        data = request.json or {}
        plan_name = data.get("plan_name", "basic")

        base_url = request.host_url.rstrip("/")
        success_url = f"{base_url}/portal/subscription?status=success"
        cancel_url = f"{base_url}/portal/subscription?status=cancelled"

        service = get_subscription_service(db)
        result = service.create_checkout_session(
            client_id=client.id,
            plan_name=plan_name,
            success_url=success_url,
            cancel_url=cancel_url,
        )
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/portal/api/subscription/billing-portal", methods=["POST"])
def portal_api_billing_portal():
    """Portal API: Create billing portal session for client"""
    client = get_portal_client()
    if not client:
        return jsonify({"success": False, "error": "Not authenticated"}), 401

    db = get_db()
    try:
        from services.subscription_service import get_subscription_service

        base_url = request.host_url.rstrip("/")
        return_url = f"{base_url}/portal/subscription"

        service = get_subscription_service(db)
        result = service.create_billing_portal_session(client.id, return_url)
        return jsonify({"success": True, **result})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/intake", methods=["POST"])
def api_intake():
    """New client intake endpoint"""
    db = get_db()
    try:
        data = request.json

        client_name = data.get("clientName", "").strip()
        client_email = data.get("clientEmail", "").strip()
        client_phone = data.get("clientPhone", "").strip()
        credit_provider = data.get("creditProvider", "Unknown")
        dispute_round = int(data.get("disputeRound", 1))
        pricing_tier = data.get("pricingTier", "tier1")
        credit_report_html = data.get("creditReportHTML", "")

        if not client_name:
            return jsonify({"success": False, "error": "Client name is required"}), 400
        if not credit_report_html:
            return (
                jsonify({"success": False, "error": "Credit report is required"}),
                400,
            )

        client = Client(name=client_name, email=client_email, phone=client_phone)
        db.add(client)
        db.flush()

        case_number = generate_case_number()
        portal_token = secrets.token_urlsafe(32)

        case = Case(
            client_id=client.id,
            case_number=case_number,
            status="stage1_pending",
            pricing_tier=pricing_tier,
            portal_token=portal_token,
            intake_at=datetime.utcnow(),
        )
        db.add(case)
        db.flush()

        event = CaseEvent(
            case_id=case.id,
            event_type="intake",
            description=f"New client intake: {client_name}",
        )
        db.add(event)
        db.commit()

        print(f"üì• New client intake: {client_name} (Case #{case_number})")
        print(f"   Pricing tier: {pricing_tier}")
        print(f"   Portal token: {portal_token[:20]}...")

        from threading import Thread

        def run_analysis():
            try:
                import requests

                response = requests.post(
                    "http://localhost:5000/api/analyze",
                    json={
                        "clientName": client_name,
                        "clientEmail": client_email,
                        "creditProvider": credit_provider,
                        "creditReportHTML": credit_report_html,
                        "disputeRound": dispute_round,
                        "analysisMode": "manual",
                    },
                    timeout=600,
                )
                print(f"‚úÖ Analysis started for {client_name}")
            except Exception as e:
                print(f"‚ùå Analysis error for {client_name}: {e}")

        thread = Thread(target=run_analysis)
        thread.start()

        return jsonify(
            {
                "success": True,
                "case_number": case_number,
                "case_id": case.id,
                "client_id": client.id,
                "portal_token": portal_token,
                "message": f"Client added. Analysis starting...",
            }
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/clients")
@require_staff(roles=["admin", "paralegal", "attorney"])
def dashboard_clients():
    """Client list page with Phase 8 BAG CRM features - shows ALL clients"""
    db = get_db()
    try:
        status_filter = request.args.get("status", "all")

        # Query all clients directly (not just those with analyses)
        query = db.query(Client).order_by(Client.created_at.desc())

        if status_filter == "active":
            query = query.filter(Client.client_stage == "active")
        elif status_filter == "lead":
            query = query.filter(Client.client_stage == "lead")
        elif status_filter == "onboarding":
            query = query.filter(Client.client_stage == "onboarding")

        clients = query.all()

        cases = []
        for client in clients:
            # Get analysis if exists
            analysis = db.query(Analysis).filter_by(client_id=client.id).first()
            damages = None
            score = None
            violations_count = 0

            if analysis:
                damages = db.query(Damages).filter_by(analysis_id=analysis.id).first()
                score = db.query(CaseScore).filter_by(analysis_id=analysis.id).first()
                violations_count = (
                    db.query(Violation).filter_by(analysis_id=analysis.id).count()
                )

            # Build client name
            client_name = (
                client.name
                or f"{client.first_name or ''} {client.last_name or ''}".strip()
                or "Unknown"
            )

            cases.append(
                {
                    "id": client.id,
                    "analysis_id": analysis.id if analysis else None,
                    "client_id": client.id,
                    "client_name": client_name,
                    "email": client.email,
                    "client_email": client.email,
                    "avatar_filename": client.avatar_filename,
                    "status": client.status or "pending",
                    "status_label": get_status_label(client.client_stage or "lead"),
                    "score": score.total_score if score else None,
                    "exposure": damages.total_exposure if damages else None,
                    "violations": violations_count,
                    "created_at": (
                        client.created_at.strftime("%Y-%m-%d %H:%M")
                        if client.created_at
                        else "N/A"
                    ),
                    # Phase 8 BAG CRM fields
                    "client_type": client.client_type or "L",
                    "follow_up_date": (
                        client.follow_up_date.isoformat()
                        if client.follow_up_date
                        else None
                    ),
                    "mark_1": client.mark_1 or False,
                    "mark_2": client.mark_2 or False,
                    "starred": client.starred or False,
                    "portal_posted": client.portal_posted or False,
                    # Workflow and contact fields
                    "current_dispute_step": client.current_dispute_step or "intake",
                    "phone": client.phone,
                    # Lead scoring
                    "lead_score": client.lead_score,
                    # WhatsApp
                    "whatsapp_verified": client.whatsapp_verified or False,
                }
            )

        return render_template("clients.html", cases=cases, status_filter=status_filter)
    except Exception as e:
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/dashboard/signups")
@require_staff(roles=["admin", "paralegal"])
def dashboard_signups():
    """Admin view for signups and payment status"""
    db = get_db()
    try:
        from datetime import timedelta

        status_filter = request.args.get("status", "all")

        # Get SignupDraft records (pending payments)
        drafts_query = (
            db.query(SignupDraft)
            .filter(SignupDraft.status == "pending")
            .order_by(SignupDraft.created_at.desc())
        )
        drafts = []
        for draft in drafts_query.all():
            form_data = draft.form_data or {}
            drafts.append(
                {
                    "id": draft.id,
                    "draft_uuid": draft.draft_uuid,
                    "client_name": form_data.get("firstName", "")
                    + " "
                    + form_data.get("lastName", ""),
                    "client_email": form_data.get("email", ""),
                    "plan_tier": draft.plan_tier or "unknown",
                    "plan_amount": draft.plan_amount or 0,
                    "status": draft.status,
                    "created_at": (
                        draft.created_at.strftime("%Y-%m-%d %H:%M")
                        if draft.created_at
                        else ""
                    ),
                    "expires_at": (
                        draft.expires_at.strftime("%Y-%m-%d %H:%M")
                        if draft.expires_at
                        else ""
                    ),
                }
            )

        # Get Client records with payment info
        clients_query = (
            db.query(Client)
            .filter(Client.signup_plan != None)
            .order_by(Client.created_at.desc())
        )

        if status_filter == "paid":
            clients_query = clients_query.filter(Client.payment_status == "paid")
        elif status_filter == "pending":
            clients_query = clients_query.filter(Client.payment_status == "pending")
        elif status_filter == "failed":
            clients_query = clients_query.filter(Client.payment_status == "failed")
        elif status_filter == "pending_manual":
            clients_query = clients_query.filter(Client.payment_pending == True)
        elif status_filter == "free":
            clients_query = clients_query.filter(Client.signup_plan == "free")

        clients = []
        for client in clients_query.limit(100).all():
            clients.append(
                {
                    "id": client.id,
                    "name": client.name,
                    "email": client.email,
                    "signup_plan": client.signup_plan,
                    "signup_amount": client.signup_amount or 0,
                    "payment_status": client.payment_status or "pending",
                    "payment_method": getattr(client, "payment_method", None)
                    or "pending",
                    "payment_pending": getattr(client, "payment_pending", False)
                    or False,
                    "portal_token": client.portal_token,
                    "created_at": (
                        client.created_at.strftime("%Y-%m-%d %H:%M")
                        if client.created_at
                        else ""
                    ),
                    "contacted": "contacted" in (client.admin_notes or "").lower(),
                }
            )

        # Calculate stats
        from sqlalchemy import func

        one_week_ago = datetime.utcnow() - timedelta(days=7)

        total_revenue = (
            db.query(func.sum(Client.signup_amount))
            .filter(Client.payment_status == "paid", Client.signup_amount != None)
            .scalar()
            or 0
        )

        pending_count = (
            db.query(SignupDraft).filter(SignupDraft.status == "pending").count()
        )
        pending_count += (
            db.query(Client)
            .filter(Client.payment_status == "pending", Client.signup_plan != None)
            .count()
        )

        paid_count = db.query(Client).filter(Client.payment_status == "paid").count()
        paid_this_week = (
            db.query(Client)
            .filter(
                Client.payment_status == "paid",
                Client.payment_received_at >= one_week_ago,
            )
            .count()
        )

        failed_count = (
            db.query(Client).filter(Client.payment_status == "failed").count()
        )

        stats = {
            "total_revenue": total_revenue,
            "pending_count": pending_count,
            "paid_count": paid_count,
            "paid_this_week": paid_this_week,
            "failed_count": failed_count,
        }

        return render_template(
            "signups.html",
            drafts=drafts,
            clients=clients,
            stats=stats,
            status_filter=status_filter,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/api/signups/mark-contacted", methods=["POST"])
def api_mark_contacted():
    """Mark a signup as contacted"""
    db = get_db()
    try:
        data = request.json
        record_type = data.get("type")
        record_id = data.get("id")

        if not record_type or not record_id:
            return jsonify({"success": False, "error": "Missing type or id"}), 400

        if record_type == "client":
            client = db.query(Client).filter_by(id=record_id).first()
            if not client:
                return jsonify({"success": False, "error": "Client not found"}), 404

            # Add contacted note
            current_notes = client.admin_notes or ""
            if "contacted" not in current_notes.lower():
                contacted_note = (
                    f"[CONTACTED {datetime.utcnow().strftime('%Y-%m-%d %H:%M')}]"
                )
                client.admin_notes = contacted_note + (
                    "\n" + current_notes if current_notes else ""
                )
                db.commit()

            return jsonify({"success": True, "message": "Client marked as contacted"})

        elif record_type == "draft":
            draft = db.query(SignupDraft).filter_by(id=record_id).first()
            if not draft:
                return jsonify({"success": False, "error": "Draft not found"}), 404

            # Update form_data to include contacted flag
            form_data = draft.form_data or {}
            form_data["contacted"] = True
            form_data["contacted_at"] = datetime.utcnow().isoformat()
            draft.form_data = form_data
            flag_modified(draft, "form_data")
            db.commit()

            return jsonify({"success": True, "message": "Draft marked as contacted"})

        else:
            return jsonify({"success": False, "error": "Invalid record type"}), 400

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/settings")
@require_staff(roles=["admin"])
def dashboard_settings():
    """Admin settings page for signup configuration"""
    db = get_db()
    try:
        import json

        settings = {}
        all_settings = db.query(SignupSettings).all()
        for s in all_settings:
            try:
                settings[s.setting_key] = (
                    json.loads(s.setting_value) if s.setting_value else None
                )
            except:
                settings[s.setting_key] = s.setting_value

        defaults = {
            "field_name": "required",
            "field_email": "required",
            "field_phone": "required",
            "field_address": "optional",
            "field_dob": "optional",
            "field_ssn": "deferred",
            "field_credit_login": "deferred",
            "field_referral": "optional",
            "tier_free_enabled": True,
            "tier_free_desc": "Basic Analysis - Free",
            "tier1_enabled": True,
            "tier1_price": 300,
            "tier1_desc": "Initial credit analysis",
            "tier2_enabled": True,
            "tier2_price": 600,
            "tier2_desc": "Two rounds of disputes",
            "tier3_enabled": True,
            "tier3_price": 900,
            "tier3_desc": "Three rounds comprehensive",
            "tier4_enabled": True,
            "tier4_price": 1200,
            "tier4_desc": "Litigation preparation",
            "tier5_enabled": True,
            "tier5_price": 1500,
            "tier5_desc": "Complete package",
            "allow_pay_later": True,
            "payment_stripe_enabled": True,
            "payment_paypal_enabled": False,
            "payment_cashapp_enabled": False,
            "payment_venmo_enabled": False,
            "payment_zelle_enabled": False,
            "payment_cashapp": "",
            "payment_venmo": "",
            "payment_zelle": "",
            "payment_paypal": "",
        }

        for key, value in defaults.items():
            if key not in settings:
                settings[key] = value

        return render_template("settings.html", settings=settings)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/api/settings/save", methods=["POST"])
def api_save_settings():
    """Save signup settings"""
    db = get_db()
    try:
        import json

        data = request.json

        for key, value in data.items():
            setting = db.query(SignupSettings).filter_by(setting_key=key).first()
            if setting:
                setting.setting_value = (
                    json.dumps(value) if not isinstance(value, str) else value
                )
                setting.updated_at = datetime.utcnow()
            else:
                setting = SignupSettings(
                    setting_key=key,
                    setting_value=(
                        json.dumps(value) if not isinstance(value, str) else value
                    ),
                )
                db.add(setting)

        db.commit()
        return jsonify({"success": True, "message": "Settings saved"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settings/get")
def api_get_settings():
    """Get all signup settings as JSON"""
    db = get_db()
    try:
        import json

        settings = {}
        all_settings = db.query(SignupSettings).all()
        for s in all_settings:
            try:
                settings[s.setting_key] = (
                    json.loads(s.setting_value) if s.setting_value else None
                )
            except:
                settings[s.setting_key] = s.setting_value
        return jsonify({"success": True, "settings": settings})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/messages")
@require_staff(roles=["admin", "staff"])
def dashboard_messages():
    """Redirect to SMS settings page (messaging)"""
    return redirect(url_for("dashboard_sms_settings"))


@app.route("/dashboard/sms")
@require_staff(roles=["admin", "staff"])
def dashboard_sms():
    """Redirect to SMS settings page"""
    return redirect(url_for("dashboard_sms_settings"))


@app.route("/dashboard/settings/sms")
@require_staff(roles=["admin"])
def dashboard_sms_settings():
    """SMS Settings page for configuring Twilio SMS automation"""
    db = get_db()
    try:
        from datetime import timedelta

        from services.sms_automation import get_sms_settings
        from services.sms_service import get_twilio_phone_number, is_twilio_configured

        twilio_configured = False
        twilio_phone = None
        try:
            twilio_configured = is_twilio_configured()
            if twilio_configured:
                twilio_phone = get_twilio_phone_number()
        except Exception as e:
            print(f"Twilio check failed: {e}")

        settings = get_sms_settings(db)

        thirty_days_ago = datetime.utcnow() - timedelta(days=30)
        logs = (
            db.query(SMSLog)
            .filter(SMSLog.sent_at >= thirty_days_ago)
            .order_by(SMSLog.sent_at.desc())
            .limit(50)
            .all()
        )

        total = db.query(SMSLog).filter(SMSLog.sent_at >= thirty_days_ago).count()
        sent = (
            db.query(SMSLog)
            .filter(SMSLog.sent_at >= thirty_days_ago, SMSLog.status == "sent")
            .count()
        )
        failed = (
            db.query(SMSLog)
            .filter(SMSLog.sent_at >= thirty_days_ago, SMSLog.status == "failed")
            .count()
        )

        template_types = (
            db.query(SMSLog.template_type)
            .filter(SMSLog.sent_at >= thirty_days_ago)
            .distinct()
            .count()
        )

        stats = {
            "total": total,
            "sent": sent,
            "failed": failed,
            "templates_used": template_types,
        }

        return render_template(
            "sms_settings.html",
            twilio_configured=twilio_configured,
            twilio_phone=twilio_phone,
            settings=settings,
            logs=logs,
            stats=stats,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/api/sms/settings", methods=["POST"])
def api_save_sms_settings():
    """Save SMS automation settings"""
    db = get_db()
    try:
        data = request.json

        setting_keys = [
            "sms_enabled",
            "welcome_sms_enabled",
            "document_reminder_enabled",
            "case_update_enabled",
            "dispute_sent_enabled",
            "cra_response_enabled",
            "payment_reminder_enabled",
            "reminder_delay_hours",
        ]

        for key in setting_keys:
            if key in data:
                value = data[key]
                if isinstance(value, bool):
                    value = "true" if value else "false"
                else:
                    value = str(value)

                setting = (
                    db.query(SignupSettings).filter_by(setting_key=f"sms_{key}").first()
                )
                if setting:
                    setting.setting_value = value
                    setting.updated_at = datetime.utcnow()
                else:
                    setting = SignupSettings(
                        setting_key=f"sms_{key}", setting_value=value
                    )
                    db.add(setting)

        db.commit()
        return jsonify({"success": True, "message": "SMS settings saved"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/sms/test", methods=["POST"])
def api_send_test_sms():
    """Send a test SMS to verify Twilio configuration"""
    try:
        from services.sms_automation import send_test_sms

        data = request.json
        phone = data.get("phone")
        message = data.get("message")

        if not phone:
            return jsonify({"success": False, "error": "Phone number required"}), 400

        result = send_test_sms(phone, message)

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/sms/send", methods=["POST"])
def api_send_sms():
    """Send an SMS to a specific client"""
    db = get_db()
    try:
        from services.sms_automation import send_custom_sms

        data = request.json
        client_id = data.get("client_id")
        message = data.get("message")

        if not client_id or not message:
            return (
                jsonify({"success": False, "error": "client_id and message required"}),
                400,
            )

        result = send_custom_sms(db, client_id, message)

        return jsonify(result)
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/sms/logs")
def api_get_sms_logs():
    """Get SMS logs with optional filters"""
    db = get_db()
    try:
        from datetime import timedelta

        days = request.args.get("days", 30, type=int)
        client_id = request.args.get("client_id", type=int)
        status = request.args.get("status")
        limit = request.args.get("limit", 100, type=int)

        cutoff = datetime.utcnow() - timedelta(days=days)
        query = db.query(SMSLog).filter(SMSLog.sent_at >= cutoff)

        if client_id:
            query = query.filter(SMSLog.client_id == client_id)
        if status:
            query = query.filter(SMSLog.status == status)

        logs = query.order_by(SMSLog.sent_at.desc()).limit(limit).all()

        logs_data = []
        for log in logs:
            logs_data.append(
                {
                    "id": log.id,
                    "client_id": log.client_id,
                    "phone_number": log.phone_number,
                    "message": (
                        log.message[:100] + "..."
                        if len(log.message or "") > 100
                        else log.message
                    ),
                    "template_type": log.template_type,
                    "status": log.status,
                    "twilio_sid": log.twilio_sid,
                    "sent_at": log.sent_at.isoformat() if log.sent_at else None,
                    "error_message": log.error_message,
                }
            )

        return jsonify({"success": True, "logs": logs_data})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# EMAIL AUTOMATION ROUTES
# ============================================================


@app.route("/dashboard/email")
@require_staff(roles=["admin", "staff"])
def dashboard_email():
    """Redirect to email settings page"""
    return redirect(url_for("dashboard_email_settings"))


@app.route("/dashboard/settings/email")
@require_staff(roles=["admin"])
def dashboard_email_settings():
    """Email Settings page for configuring SendGrid email automation"""
    db = get_db()
    try:
        from datetime import timedelta

        from services.email_automation import get_email_settings
        from services.email_service import is_sendgrid_configured

        sendgrid_configured = False
        try:
            sendgrid_configured = is_sendgrid_configured()
        except Exception as e:
            print(f"SendGrid check failed: {e}")

        settings = get_email_settings(db)

        thirty_days_ago = datetime.utcnow() - timedelta(days=30)
        logs = (
            db.query(EmailLog)
            .filter(EmailLog.sent_at >= thirty_days_ago)
            .order_by(EmailLog.sent_at.desc())
            .limit(50)
            .all()
        )

        total = db.query(EmailLog).filter(EmailLog.sent_at >= thirty_days_ago).count()
        sent = (
            db.query(EmailLog)
            .filter(EmailLog.sent_at >= thirty_days_ago, EmailLog.status == "sent")
            .count()
        )
        failed = (
            db.query(EmailLog)
            .filter(EmailLog.sent_at >= thirty_days_ago, EmailLog.status == "failed")
            .count()
        )

        template_types = (
            db.query(EmailLog.template_type)
            .filter(EmailLog.sent_at >= thirty_days_ago)
            .distinct()
            .count()
        )

        stats = {
            "total": total,
            "sent": sent,
            "failed": failed,
            "templates_used": template_types,
        }

        return render_template(
            "email_settings.html",
            sendgrid_configured=sendgrid_configured,
            settings=settings,
            logs=logs,
            stats=stats,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/api/email/settings", methods=["POST"])
def api_save_email_settings():
    """Save email automation settings"""
    db = get_db()
    try:
        data = request.json

        setting_keys = [
            "email_enabled",
            "welcome_email_enabled",
            "document_reminder_enabled",
            "case_update_enabled",
            "dispute_sent_enabled",
            "cra_response_enabled",
            "payment_reminder_enabled",
            "analysis_ready_enabled",
            "letters_ready_enabled",
        ]

        for key in setting_keys:
            if key in data:
                value = data[key]
                if isinstance(value, bool):
                    value = "true" if value else "false"
                else:
                    value = str(value)

                setting = (
                    db.query(SignupSettings)
                    .filter_by(setting_key=f"email_{key}")
                    .first()
                )
                if setting:
                    setting.setting_value = value
                    setting.updated_at = datetime.utcnow()
                else:
                    setting = SignupSettings(
                        setting_key=f"email_{key}", setting_value=value
                    )
                    db.add(setting)

        db.commit()
        return jsonify({"success": True, "message": "Email settings saved"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/email/test", methods=["POST"])
def api_send_test_email():
    """Send a test email to verify SendGrid configuration"""
    try:
        from services.email_automation import send_test_email

        data = request.json
        email = data.get("email")

        if not email:
            return jsonify({"success": False, "error": "Email address required"}), 400

        result = send_test_email(email)

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/email/send", methods=["POST"])
def api_send_email():
    """Send an email to a specific client"""
    db = get_db()
    try:
        from services.email_automation import send_custom_email

        data = request.json
        client_id = data.get("client_id")
        subject = data.get("subject")
        message = data.get("message")

        if not client_id or not subject or not message:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "client_id, subject, and message required",
                    }
                ),
                400,
            )

        result = send_custom_email(db, client_id, subject, message)

        return jsonify(result)
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/email/setup")
def api_email_setup():
    """Redirect to dashboard settings"""
    return redirect("/dashboard/settings")


VALID_TEMPLATE_TYPES = [
    "welcome",
    "document_reminder",
    "case_update",
    "dispute_sent",
    "cra_response",
    "payment_reminder",
    "analysis_ready",
    "letters_ready",
]


def validate_template_type(template_type):
    """Validate that template_type is one of the allowed types"""
    return template_type in VALID_TEMPLATE_TYPES


def validate_email_format(email):
    """Basic email format validation"""
    import re

    if not email:
        return False
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    return bool(re.match(pattern, email))


@app.route("/api/email-templates", methods=["GET"])
def api_get_email_templates():
    """Get all email templates - lists all template types with custom status"""
    db = get_db()
    try:
        template_types = VALID_TEMPLATE_TYPES

        custom_templates = db.query(EmailTemplate).all()
        custom_map = {t.template_type: t for t in custom_templates}

        templates = []
        for tt in template_types:
            if tt in custom_map:
                t = custom_map[tt]
                templates.append(
                    {
                        "template_type": tt,
                        "subject": t.subject,
                        "is_custom": t.is_custom,
                        "has_custom": True,
                        "updated_at": (
                            t.updated_at.isoformat() if t.updated_at else None
                        ),
                    }
                )
            else:
                templates.append(
                    {
                        "template_type": tt,
                        "subject": get_default_subject(tt),
                        "is_custom": False,
                        "has_custom": False,
                        "updated_at": None,
                    }
                )

        return jsonify({"success": True, "templates": templates})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/email-templates/<template_type>", methods=["GET"])
def api_get_email_template(template_type):
    """Get a specific email template by type"""
    if not validate_template_type(template_type):
        return (
            jsonify(
                {"success": False, "error": f"Invalid template type: {template_type}"}
            ),
            400,
        )

    db = get_db()
    try:
        template = (
            db.query(EmailTemplate).filter_by(template_type=template_type).first()
        )

        if template:
            return jsonify(
                {
                    "success": True,
                    "template": {
                        "template_type": template.template_type,
                        "subject": template.subject,
                        "html_content": template.html_content,
                        "design_json": template.design_json,
                        "is_custom": template.is_custom,
                        "updated_at": (
                            template.updated_at.isoformat()
                            if template.updated_at
                            else None
                        ),
                    },
                }
            )
        else:
            return jsonify(
                {
                    "success": True,
                    "template": {
                        "template_type": template_type,
                        "subject": get_default_subject(template_type),
                        "html_content": None,
                        "design_json": None,
                        "is_custom": False,
                        "updated_at": None,
                    },
                }
            )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/email-templates/<template_type>", methods=["POST"])
def api_save_email_template(template_type):
    """Save or update an email template"""
    if not validate_template_type(template_type):
        return (
            jsonify(
                {"success": False, "error": f"Invalid template type: {template_type}"}
            ),
            400,
        )

    db = get_db()
    try:
        data = request.json
        subject = data.get("subject")
        html_content = data.get("html_content")
        design_json = data.get("design_json")

        if not subject or not subject.strip():
            return jsonify({"success": False, "error": "Subject is required"}), 400

        template = (
            db.query(EmailTemplate).filter_by(template_type=template_type).first()
        )

        if template:
            template.subject = subject
            template.html_content = html_content
            template.design_json = design_json
            template.is_custom = True
            template.updated_at = datetime.utcnow()
        else:
            template = EmailTemplate(
                template_type=template_type,
                subject=subject,
                html_content=html_content,
                design_json=design_json,
                is_custom=True,
            )
            db.add(template)

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f'Template "{template_type}" saved successfully',
                "template": {
                    "template_type": template.template_type,
                    "subject": template.subject,
                    "is_custom": template.is_custom,
                },
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/email-templates/<template_type>/reset", methods=["POST"])
def api_reset_email_template(template_type):
    """Reset a template to default (delete custom version)"""
    if not validate_template_type(template_type):
        return (
            jsonify(
                {"success": False, "error": f"Invalid template type: {template_type}"}
            ),
            400,
        )

    db = get_db()
    try:
        template = (
            db.query(EmailTemplate).filter_by(template_type=template_type).first()
        )

        if template:
            db.delete(template)
            db.commit()
            return jsonify(
                {
                    "success": True,
                    "message": f'Template "{template_type}" reset to default',
                }
            )
        else:
            return jsonify(
                {
                    "success": True,
                    "message": f'Template "{template_type}" was already using default',
                }
            )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/email-templates/<template_type>/preview", methods=["POST"])
def api_preview_email_template(template_type):
    """Send a preview email with the template"""
    if not validate_template_type(template_type):
        return (
            jsonify(
                {"success": False, "error": f"Invalid template type: {template_type}"}
            ),
            400,
        )

    db = get_db()
    try:
        from services import email_templates as default_templates
        from services.email_service import is_sendgrid_configured, send_email

        if not is_sendgrid_configured():
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "SendGrid not configured. Please connect SendGrid first.",
                    }
                ),
                400,
            )

        data = request.json
        preview_email = data.get("email", "").strip()
        html_content = data.get("html_content")
        subject = data.get("subject", f"Preview: {template_type}")

        if not preview_email:
            return (
                jsonify({"success": False, "error": "Preview email address required"}),
                400,
            )

        if not validate_email_format(preview_email):
            return jsonify({"success": False, "error": "Invalid email format"}), 400

        if html_content:
            test_html = apply_merge_tags(
                html_content,
                {
                    "client_name": "Test Client",
                    "client_email": preview_email,
                    "portal_link": "https://example.com/portal/test123",
                    "case_status": "Active",
                    "missing_docs": "Driver's License, Utility Bill",
                    "company_name": "Brightpath Ascend Group",
                    "support_email": "support@brightpathascend.com",
                },
            )
        else:
            test_html = default_templates.get_base_template(
                "<h2>Template Preview</h2><p>This is a preview of the default template.</p>",
                subject,
            )

        result = send_email(preview_email, f"[Preview] {subject}", test_html)

        if result["success"]:
            return jsonify({"success": True, "message": "Preview email sent!"})
        else:
            return (
                jsonify(
                    {"success": False, "error": result.get("error", "Failed to send")}
                ),
                500,
            )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


def get_default_subject(template_type):
    """Get the default subject line for a template type"""
    subjects = {
        "welcome": "Welcome to Brightpath Ascend Group!",
        "document_reminder": "Action Required: Documents Needed",
        "case_update": "Case Update",
        "dispute_sent": "Dispute Letter Sent",
        "cra_response": "Response Received",
        "payment_reminder": "Payment Reminder",
        "analysis_ready": "Your Credit Analysis is Ready!",
        "letters_ready": "Your Dispute Letters Are Ready!",
    }
    return subjects.get(
        template_type, f'{template_type.replace("_", " ").title()} Notification'
    )


CRA_ADDRESSES = {
    # Main 3 CRAs - Dispute Addresses
    "equifax_name": "Equifax Information Services LLC",
    "equifax_address": "P.O. Box 740256, Atlanta, GA 30374-0256",
    "equifax_phone": "1-800-685-1111",
    "experian_name": "Experian",
    "experian_address": "P.O. Box 4500, Allen, TX 75013",
    "experian_phone": "1-888-397-3742",
    "transunion_name": "TransUnion LLC",
    "transunion_address": "P.O. Box 2000, Chester, PA 19016-2000",
    "transunion_phone": "1-800-916-8800",
    # Main 3 CRAs - Freeze Addresses
    "equifax_freeze_address": "P.O. Box 105788, Atlanta, GA 30348-5788",
    "equifax_freeze_phone": "1-800-349-9960",
    "experian_freeze_address": "P.O. Box 9554, Allen, TX 75013",
    "experian_freeze_phone": "1-888-397-3742",
    "transunion_freeze_address": "P.O. Box 160, Woodlyn, PA 19094",
    "transunion_freeze_phone": "1-888-909-8872",
    # Secondary Bureaus (9 bureaus)
    "innovis_name": "Innovis",
    "innovis_address": "P.O. Box 1358, Columbus, OH 43216-1358",
    "innovis_phone": "1-800-540-2505",
    "innovis_freeze_address": "P.O. Box 1358, Columbus, OH 43216-1358",
    "chexsystems_name": "ChexSystems",
    "chexsystems_address": "Attn: Consumer Relations, 7805 Hudson Road, Suite 100, Woodbury, MN 55125",
    "chexsystems_phone": "1-800-428-9623",
    "chexsystems_freeze_address": "P.O. Box 583399, Minneapolis, MN 55458",
    "clarity_name": "Clarity Services Inc",
    "clarity_address": "P.O. Box 5717, Clearwater, FL 33758",
    "clarity_phone": "1-866-390-3118",
    "lexisnexis_name": "LexisNexis",
    "lexisnexis_address": "P.O. Box 105108, Atlanta, GA 30348-5108",
    "lexisnexis_phone": "1-888-497-0011",
    "corelogic_name": "CoreLogic Teletrack",
    "corelogic_address": "P.O. Box 509124, San Diego, CA 92150",
    "corelogic_phone": "1-877-309-5226",
    "factortrust_name": "Factor Trust Inc",
    "factortrust_address": "P.O. Box 327, Alpharetta, GA 30009",
    "factortrust_phone": "1-484-671-5880",
    "microbilt_name": "MicroBilt / PRBC",
    "microbilt_address": "1640 Airport Road, Suite 115, Kennesaw, GA 30144",
    "microbilt_phone": "1-866-536-3569",
    "lexisnexis_risk_name": "LexisNexis Risk Solutions",
    "lexisnexis_risk_address": "P.O. Box 105108, Atlanta, GA 30348",
    "lexisnexis_risk_phone": "1-800-456-1244",
    "datax_name": "DataX Ltd",
    "datax_address": "P.O. Box 105168, Atlanta, GA 30348",
    "datax_phone": "1-800-295-4790",
}


def apply_merge_tags(html_content, values):
    """Replace merge tags in HTML content with actual values"""
    if not html_content:
        return html_content

    all_values = {**CRA_ADDRESSES, **values}

    result = html_content
    for tag, value in all_values.items():
        result = result.replace("{{" + tag + "}}", str(value) if value else "")
    return result


@app.route("/api/signups/confirm-payment", methods=["POST"])
def api_confirm_payment():
    """Confirm manual payment for a client"""
    db = get_db()
    try:
        data = request.json
        client_id = data.get("client_id")

        if not client_id:
            return jsonify({"success": False, "error": "Missing client_id"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        client.payment_status = "paid"
        client.payment_pending = False
        client.payment_received_at = datetime.utcnow()

        current_notes = client.admin_notes or ""
        payment_note = f"[PAYMENT CONFIRMED {datetime.utcnow().strftime('%Y-%m-%d %H:%M')} via {client.payment_method or 'manual'}]"
        client.admin_notes = payment_note + (
            "\n" + current_notes if current_notes else ""
        )

        db.commit()
        return jsonify({"success": True, "message": "Payment confirmed"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/case/<int:case_id>")
@require_staff(roles=["admin", "paralegal", "attorney", "viewer"])
def dashboard_case_detail(case_id):
    """Single case detail page"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=case_id).first()
        if not analysis:
            return "Case not found", 404

        violations = db.query(Violation).filter_by(analysis_id=case_id).all()
        standing = db.query(Standing).filter_by(analysis_id=case_id).first()
        damages = db.query(Damages).filter_by(analysis_id=case_id).first()
        score = db.query(CaseScore).filter_by(analysis_id=case_id).first()
        letters = db.query(DisputeLetter).filter_by(analysis_id=case_id).all()
        client = db.query(Client).filter_by(id=analysis.client_id).first()

        return render_template(
            "case_detail.html",
            analysis=analysis,
            client=client,
            violations=violations,
            standing=standing,
            damages=damages,
            score=score,
            letters=letters,
        )
    except Exception as e:
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/portal")
def portal_redirect():
    """Redirect /portal to portal dashboard or login"""
    if "client_id" in session:
        return redirect(url_for("portal.dashboard"))
    # Preserve query parameters (like ?token=xxx for password reset)
    query_string = request.query_string.decode()
    if query_string:
        return redirect(f"/portal/login?{query_string}")
    return redirect(url_for("portal_login"))


@app.route("/portal/guide")
def client_portal_guide():
    """Client Portal SOP/Guide - public page with all screenshots"""
    return render_template("portal/client_guide.html")


@app.route("/portal/<token>")
def client_portal(token):
    """Client-facing portal access via magic link - authenticate and redirect to new portal"""
    db = get_db()
    try:
        # First try to find client by portal token
        client = db.query(Client).filter_by(portal_token=token).first()

        # If not found, try to find a case with this token
        if not client:
            case = db.query(Case).filter_by(portal_token=token).first()
            if case:
                client = db.query(Client).filter_by(id=case.client_id).first()

        # Must have at least a client
        if not client:
            return "Invalid or expired access link", 404

        # Initialize secondary bureau freezes if they don't exist
        secondary_freezes = (
            db.query(SecondaryBureauFreeze).filter_by(client_id=client.id).all()
        )
        if not secondary_freezes:
            default_bureaus = [
                "Innovis",
                "ChexSystems",
                "Clarity Services Inc",
                "LexisNexis",
                "CoreLogic Teletrack",
                "Factor Trust Inc",
                "MicroBilt / PRBC",
                "LexisNexis Risk Solutions (A TransUnion Company)",
                "DataX Ltd",
            ]
            for bureau in default_bureaus:
                freeze = SecondaryBureauFreeze(
                    client_id=client.id, bureau_name=bureau, status="pending"
                )
                db.add(freeze)
            db.commit()

        # Set session to authenticate the client
        session.permanent = True
        session["client_id"] = client.id
        session["client_email"] = client.email
        session["client_name"] = client.name

        # Redirect to new portal dashboard
        return redirect(url_for("portal.dashboard"))
    except Exception as e:
        return f"Error: {str(e)}", 500
    finally:
        db.close()


# ============================================================
# CLIENT PORTAL AUTHENTICATION ROUTES
# ============================================================


def check_rate_limit(email):
    """Check if login attempts are rate limited. Returns (allowed, wait_seconds)"""
    now = datetime.utcnow()
    if email in login_attempts:
        attempts = login_attempts[email]
        time_diff = (now - attempts["last_attempt"]).total_seconds()

        if time_diff > 900:
            login_attempts[email] = {"count": 0, "last_attempt": now}
            return True, 0

        if attempts["count"] >= 5:
            wait_time = 900 - int(time_diff)
            return False, max(0, wait_time)

    return True, 0


def record_login_attempt(email, success=False):
    """Record a login attempt"""
    now = datetime.utcnow()
    if success:
        if email in login_attempts:
            del login_attempts[email]
    else:
        if email not in login_attempts:
            login_attempts[email] = {"count": 0, "last_attempt": now}
        login_attempts[email]["count"] += 1
        login_attempts[email]["last_attempt"] = now


@app.route("/portal/login", methods=["GET", "POST"])
def portal_login():
    """Client portal login page"""
    if request.method == "GET":
        if "client_id" in session:
            return redirect("/portal/dashboard")
        # Pass reset token if present in query params
        reset_token = request.args.get("token", "")
        return render_template("portal_login.html", reset_token=reset_token)

    db = get_db()
    try:
        email = sanitize_string(request.form.get("email", "")).strip().lower()
        password = request.form.get("password", "")  # Don't sanitize password

        if not email or not password:
            return render_template(
                "portal_login.html", error="Email and password are required"
            )

        allowed, wait_time = check_rate_limit(email)
        if not allowed:
            minutes = wait_time // 60
            return render_template(
                "portal_login.html",
                error=f"Too many login attempts. Please wait {minutes} minutes before trying again.",
            )

        client = db.query(Client).filter(Client.email.ilike(email)).first()

        if not client:
            record_login_attempt(email, success=False)
            log_login_failed(email, "Client not found")
            return render_template(
                "portal_login.html", error="Invalid email or password"
            )

        if not client.portal_password_hash:
            record_login_attempt(email, success=False)
            log_login_failed(email, "No password set")
            return render_template(
                "portal_login.html",
                error="No password set. Please use your portal access link or contact support.",
            )

        if not check_password_hash(client.portal_password_hash, password):
            record_login_attempt(email, success=False)
            log_login_failed(email, "Invalid password")
            return render_template(
                "portal_login.html", error="Invalid email or password"
            )

        record_login_attempt(email, success=True)
        log_login(email, "client portal")

        session.permanent = True
        session["client_id"] = client.id
        session["client_email"] = client.email
        session["client_name"] = client.name

        # Ensure client has a portal token
        if not client.portal_token:
            client.portal_token = secrets.token_urlsafe(32)
            db.commit()

        # Redirect to new portal dashboard
        return redirect(url_for("portal.dashboard"))

    except Exception as e:
        print(f"Login error: {e}")
        return render_template(
            "portal_login.html", error="An error occurred. Please try again."
        )
    finally:
        db.close()


# OLD ROUTE REMOVED - Blueprint handles /portal/dashboard now
# @app.route('/portal/dashboard')
# def portal_dashboard():
#     """Redirect to new portal blueprint dashboard"""
#     return redirect(url_for('portal.dashboard'))


@app.route("/portal/create-password")
def portal_create_password():
    """Password creation page - redirect to new portal profile"""
    if "client_id" not in session:
        return redirect(url_for("portal_login"))
    return redirect(url_for("portal.profile"))


@app.route("/portal/messages")
def portal_messages():
    """Messages page - redirect to new portal profile (has contact form)"""
    if "client_id" not in session:
        return redirect(url_for("portal_login"))
    return redirect(url_for("portal.profile"))


@app.route("/portal/logout")
def portal_logout():
    """Log out client and clear session"""
    session.pop("client_id", None)
    session.pop("client_email", None)
    session.pop("client_name", None)
    return redirect("/portal/login")


@app.route("/api/portal/set-password", methods=["POST"])
def api_portal_set_password():
    """Set or update password for a client (from portal)"""
    db = get_db()
    try:
        data = request.json
        token = data.get("token", "")
        password = data.get("password", "")
        current_password = data.get("current_password", "")

        if not token:
            return jsonify({"success": False, "error": "Portal token required"}), 400

        if not password or len(password) < 8:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Password must be at least 8 characters",
                    }
                ),
                400,
            )

        client = db.query(Client).filter_by(portal_token=token).first()
        if not client:
            return jsonify({"success": False, "error": "Invalid portal token"}), 404

        if client.portal_password_hash:
            if not current_password:
                return (
                    jsonify({"success": False, "error": "Current password required"}),
                    400,
                )
            if not check_password_hash(client.portal_password_hash, current_password):
                return (
                    jsonify(
                        {"success": False, "error": "Current password is incorrect"}
                    ),
                    400,
                )

        client.portal_password_hash = generate_password_hash(password)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Password set successfully. You can now log in with your email and password.",
            }
        )

    except Exception as e:
        print(f"Set password error: {e}")
        db.rollback()
        return jsonify({"success": False, "error": "Failed to set password"}), 500
    finally:
        db.close()


@app.route("/api/portal/forgot-password", methods=["POST"])
def api_portal_forgot_password():
    """Send password reset email"""
    db = get_db()
    try:
        data = request.json
        email = data.get("email", "").strip().lower()

        if not email:
            return jsonify({"success": False, "error": "Email is required"}), 400

        client = db.query(Client).filter(Client.email.ilike(email)).first()

        if not client:
            return jsonify(
                {
                    "success": True,
                    "message": "If an account exists with that email, a password reset link has been sent.",
                }
            )

        reset_token = secrets.token_urlsafe(32)
        client.password_reset_token = reset_token
        client.password_reset_expires = datetime.utcnow() + timedelta(hours=24)
        db.commit()

        try:
            from services.email_service import is_sendgrid_configured, send_email

            if is_sendgrid_configured():
                reset_url = f"{request.host_url}portal/login?token={reset_token}"

                html_content = f"""
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <h1 style="color: #1a1a2e;">Brightpath Ascend Group</h1>
                    </div>
                    
                    <h2 style="color: #333;">Password Reset Request</h2>
                    
                    <p>Hello {client.first_name or client.name},</p>
                    
                    <p>We received a request to reset your password for your Client Portal account.</p>
                    
                    <p>Click the button below to reset your password:</p>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="{reset_url}" style="background: linear-gradient(135deg, #84cc16, #22c55e); color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">Reset Password</a>
                    </div>
                    
                    <p>Or copy and paste this link into your browser:</p>
                    <p style="word-break: break-all; color: #3b82f6;">{reset_url}</p>
                    
                    <p><strong>This link will expire in 24 hours.</strong></p>
                    
                    <p>If you didn't request this password reset, you can safely ignore this email.</p>
                    
                    <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 30px 0;">
                    
                    <p style="color: #64748b; font-size: 12px;">
                        Brightpath Ascend Group<br>
                        Credit Repair & FCRA Litigation Services
                    </p>
                </div>
                """

                result = send_email(
                    to_email=client.email,
                    subject="Reset Your Password - Brightpath Ascend Client Portal",
                    html_content=html_content,
                )

                if not result["success"]:
                    print(f"Failed to send reset email: {result.get('error')}")
            else:
                print(
                    f"SendGrid not configured. Reset token for {email}: {reset_token}"
                )

        except Exception as email_error:
            print(f"Email sending error: {email_error}")

        return jsonify(
            {
                "success": True,
                "message": "If an account exists with that email, a password reset link has been sent.",
            }
        )

    except Exception as e:
        print(f"Forgot password error: {e}")
        db.rollback()
        return jsonify({"success": False, "error": "Failed to process request"}), 500
    finally:
        db.close()


@app.route("/api/portal/reset-password", methods=["POST"])
def api_portal_reset_password():
    """Reset password using token from email"""
    db = get_db()
    try:
        data = request.json
        token = data.get("token", "").strip()
        password = data.get("password", "")

        if not token:
            return jsonify({"success": False, "error": "Reset token is required"}), 400

        if not password or len(password) < 8:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Password must be at least 8 characters",
                    }
                ),
                400,
            )

        client = db.query(Client).filter_by(password_reset_token=token).first()

        if not client:
            return (
                jsonify({"success": False, "error": "Invalid or expired reset link"}),
                400,
            )

        if (
            client.password_reset_expires
            and client.password_reset_expires < datetime.utcnow()
        ):
            client.password_reset_token = None
            client.password_reset_expires = None
            db.commit()
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Reset link has expired. Please request a new one.",
                    }
                ),
                400,
            )

        client.portal_password_hash = generate_password_hash(password)
        client.password_reset_token = None
        client.password_reset_expires = None
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Password has been reset successfully. You can now log in.",
            }
        )

    except Exception as e:
        print(f"Reset password error: {e}")
        db.rollback()
        return jsonify({"success": False, "error": "Failed to reset password"}), 500
    finally:
        db.close()


# ============================================================
# CLIENT SIGNUP & ONBOARDING ROUTES
# ============================================================


@app.route("/signup")
def client_signup():
    """Public client signup page"""
    return render_template("client_signup.html")


@app.route("/api/client/signup", methods=["POST"])
def api_client_signup():
    """Handle new client registration"""
    db = get_db()
    try:
        data = request.json

        # Sanitize input - remove HTML tags and limit length
        import re

        def sanitize(value, max_length=255):
            if not value:
                return ""
            # Remove HTML tags
            clean = re.sub(r"<[^>]+>", "", str(value))
            return clean.strip()[:max_length]

        first_name = sanitize(data.get("firstName", ""), 100)
        last_name = sanitize(data.get("lastName", ""), 100)
        email = data.get("email", "").strip().lower()[:255]
        phone = sanitize(data.get("phone", ""), 50)

        if not first_name or not last_name or not email:
            return (
                jsonify({"success": False, "error": "Name and email are required"}),
                400,
            )

        # Validate email format
        email_pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        if not re.match(email_pattern, email):
            return (
                jsonify(
                    {"success": False, "error": "Please enter a valid email address"}
                ),
                400,
            )

        existing = db.query(Client).filter_by(email=email).first()
        if existing:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "An account with this email already exists",
                    }
                ),
                400,
            )

        referral_code = "BP" + secrets.token_hex(4).upper()
        portal_token = secrets.token_urlsafe(32)

        from datetime import date

        dob_str = data.get("dateOfBirth", "")
        dob = None
        if dob_str:
            try:
                dob = date.fromisoformat(dob_str)
            except:
                pass

        # Get plan tier and calculate amount
        plan_tier = data.get("planTier", "free")
        tier_prices = {
            "free": 0,
            "tier1": 300,
            "tier2": 600,
            "tier3": 900,
            "tier4": 1200,
            "tier5": 1500,
        }
        plan_amount = tier_prices.get(plan_tier, 0)

        client = Client(
            name=f"{first_name} {last_name}",
            first_name=first_name,
            last_name=last_name,
            email=email,
            phone=phone,
            address_street=data.get("addressStreet", ""),
            address_city=data.get("addressCity", ""),
            address_state=data.get("addressState", ""),
            address_zip=data.get("addressZip", ""),
            ssn_last_four=data.get("ssnLast4", ""),
            date_of_birth=dob,
            credit_monitoring_service=data.get("creditService", ""),
            credit_monitoring_username=data.get("creditUsername", ""),
            credit_monitoring_password_encrypted=(
                encrypt_value(data.get("creditPassword", ""))
                if data.get("creditPassword")
                else ""
            ),
            current_dispute_round=0,
            dispute_status="new",
            referral_code=referral_code,
            portal_token=portal_token,
            status="signup",
            signup_completed=True,
            agreement_signed=data.get("agreeTerms", False),
            agreement_signed_at=datetime.utcnow() if data.get("agreeTerms") else None,
            signup_plan=plan_tier,
            signup_amount=plan_amount,
            payment_method=data.get("paymentMethod", ""),
            payment_status="pending" if plan_amount > 0 else "free",
        )

        ref_code = data.get("referralCode", "").strip()
        if ref_code:
            referrer = db.query(Client).filter_by(referral_code=ref_code).first()
            if referrer:
                client.referred_by_client_id = referrer.id
                referral = ClientReferral(
                    referring_client_id=referrer.id,
                    referred_name=client.name,
                    referred_email=client.email,
                    referred_phone=client.phone,
                    status="signed_up",
                )
                db.add(referral)

        db.add(client)
        db.flush()
        log_client_created(client.id, client.name, user=session.get("staff_email"))

        case_number = generate_case_number()
        case = Case(
            client_id=client.id,
            case_number=case_number,
            status="intake",
            pricing_tier="tier1",
            portal_token=portal_token,
            intake_at=datetime.utcnow(),
        )
        db.add(case)
        db.flush()

        event = CaseEvent(
            case_id=case.id,
            event_type="signup",
            description=f"Client {client.name} signed up via web portal",
        )
        db.add(event)

        db.commit()

        # Auto-import if credentials provided
        if (
            data.get("creditService")
            and data.get("creditUsername")
            and data.get("creditPassword")
        ):
            try:
                from services.credit_import_automation import run_import_sync

                credit_password = decrypt_value(
                    client.credit_monitoring_password_encrypted
                )
                print(f"üöÄ Auto-importing credit report for {client.name}...")
                result = run_import_sync(
                    service_name=data.get("creditService"),
                    username=data.get("creditUsername"),
                    password=credit_password,
                    ssn_last4=data.get("ssnLast4", ""),
                    client_id=client.id,
                    client_name=client.name,
                )
                if result["success"]:
                    print(f"‚úÖ Auto-import successful for {client.name}")
            except Exception as import_error:
                print(f"‚ö†Ô∏è  Auto-import error (non-fatal): {import_error}")

        return (
            jsonify(
                {
                    "success": True,
                    "clientId": client.id,
                    "caseNumber": case_number,
                    "referralCode": referral_code,
                    "portalToken": portal_token,
                    "message": "Registration complete! We will pull your credit report and begin your analysis.",
                }
            ),
            201,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# STRIPE PAYMENT INTEGRATION
# ============================================================


@app.route("/api/stripe/pricing-tiers", methods=["GET"])
def get_pricing_tiers():
    """Return available pricing tiers for display"""
    from services.stripe_client import PRICING_TIERS

    tiers = []
    for key, tier in PRICING_TIERS.items():
        tiers.append(
            {
                "id": key,
                "name": tier["name"],
                "amount": tier["amount"],
                "display": tier["display"],
                "description": get_tier_description(key),
            }
        )

    return jsonify({"success": True, "tiers": tiers}), 200


def get_tier_description(tier_key):
    """Get description for each pricing tier"""
    descriptions = {
        "tier1": "Basic credit restoration package with initial dispute letters",
        "tier2": "Standard package with follow-up rounds and bureau monitoring",
        "tier3": "Premium package with comprehensive dispute strategy",
        "tier4": "Advanced package with litigation preparation support",
        "tier5": "Elite package with full litigation support and priority handling",
    }
    return descriptions.get(tier_key, "")


@app.route("/api/client/signup/draft", methods=["POST"])
def api_create_signup_draft():
    """Save draft signup data and return draft UUID for payment flow"""
    db = get_db()
    try:
        data = request.json

        first_name = data.get("firstName", "").strip()
        last_name = data.get("lastName", "").strip()
        email = data.get("email", "").strip()

        if not first_name or not last_name or not email:
            return (
                jsonify({"success": False, "error": "Name and email are required"}),
                400,
            )

        existing_client = db.query(Client).filter_by(email=email).first()
        if existing_client:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "An account with this email already exists",
                    }
                ),
                400,
            )

        plan_tier = data.get("planTier", "tier1")
        from services.stripe_client import PRICING_TIERS

        tier_info = PRICING_TIERS.get(plan_tier)
        if not tier_info:
            return jsonify({"success": False, "error": "Invalid pricing tier"}), 400

        draft_uuid = str(uuid.uuid4())
        expires_at = datetime.utcnow() + timedelta(hours=24)

        form_data = {
            "firstName": first_name,
            "lastName": last_name,
            "email": email,
            "phone": data.get("phone", ""),
            "addressStreet": data.get("addressStreet", ""),
            "addressCity": data.get("addressCity", ""),
            "addressState": data.get("addressState", ""),
            "addressZip": data.get("addressZip", ""),
            "dateOfBirth": data.get("dateOfBirth", ""),
            "ssnLast4": data.get("ssnLast4", ""),
            "referralCode": data.get("referralCode", ""),
            "creditService": data.get("creditService", ""),
            "creditUsername": data.get("creditUsername", ""),
            "creditPassword": data.get("creditPassword", ""),
            "agreeTerms": data.get("agreeTerms", False),
            "agreeComms": data.get("agreeComms", False),
        }

        draft = SignupDraft(
            draft_uuid=draft_uuid,
            form_data=form_data,
            plan_tier=plan_tier,
            plan_amount=tier_info["amount"],
            status="pending",
            expires_at=expires_at,
        )

        db.add(draft)
        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "draftId": draft_uuid,
                    "planTier": plan_tier,
                    "planAmount": tier_info["amount"],
                    "planDisplay": tier_info["display"],
                    "expiresAt": expires_at.isoformat(),
                }
            ),
            201,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client/signup/complete-free", methods=["POST"])
def api_complete_free_signup():
    """Complete a free tier signup without payment"""
    db = get_db()
    try:
        data = request.json
        draft_id = data.get("draftId")

        if not draft_id:
            return jsonify({"success": False, "error": "Draft ID is required"}), 400

        draft = db.query(SignupDraft).filter_by(draft_uuid=draft_id).first()
        if not draft:
            return jsonify({"success": False, "error": "Signup draft not found"}), 404

        if draft.status != "pending":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Draft is not pending (status: {draft.status})",
                    }
                ),
                400,
            )

        form_data = draft.form_data or {}

        referral_code = generate_referral_code()
        portal_token = str(uuid.uuid4())
        password_reset_token = secrets.token_urlsafe(32)

        dob_str = form_data.get("dateOfBirth", "")
        dob = None
        if dob_str:
            try:
                from datetime import date as dt_date

                dob = dt_date.fromisoformat(dob_str)
            except:
                pass

        client = Client(
            name=f"{form_data.get('firstName', '')} {form_data.get('lastName', '')}".strip(),
            first_name=form_data.get("firstName", ""),
            last_name=form_data.get("lastName", ""),
            email=form_data.get("email", ""),
            phone=form_data.get("phone", ""),
            address_street=form_data.get("addressStreet", ""),
            address_city=form_data.get("addressCity", ""),
            address_state=form_data.get("addressState", ""),
            address_zip=form_data.get("addressZip", ""),
            ssn_last_four=form_data.get("ssnLast4", ""),
            date_of_birth=dob,
            credit_monitoring_service=form_data.get("creditService", ""),
            credit_monitoring_username=form_data.get("creditUsername", ""),
            credit_monitoring_password_encrypted=(
                encrypt_value(form_data.get("creditPassword", ""))
                if form_data.get("creditPassword")
                else ""
            ),
            status="lead",
            current_dispute_round=0,
            dispute_status="new",
            referral_code=referral_code,
            portal_token=portal_token,
            password_reset_token=password_reset_token,
            password_reset_expires=datetime.utcnow() + timedelta(days=7),
            signup_completed=True,
            agreement_signed=form_data.get("agreeTerms", False),
            agreement_signed_at=(
                datetime.utcnow() if form_data.get("agreeTerms") else None
            ),
        )

        db.add(client)
        draft.status = "completed"
        db.commit()

        # Auto-import if credentials provided
        if (
            form_data.get("creditService")
            and form_data.get("creditUsername")
            and form_data.get("creditPassword")
        ):
            try:
                from services.credit_import_automation import run_import_sync

                credit_password = decrypt_value(
                    client.credit_monitoring_password_encrypted
                )
                print(f"üöÄ Auto-importing credit report for {client.name}...")
                result = run_import_sync(
                    service_name=form_data.get("creditService"),
                    username=form_data.get("creditUsername"),
                    password=credit_password,
                    ssn_last4=form_data.get("ssnLast4", ""),
                    client_id=client.id,
                    client_name=client.name,
                )
                if result["success"]:
                    print(f"‚úÖ Auto-import successful for {client.name}")
            except Exception as import_error:
                print(f"‚ö†Ô∏è  Auto-import error (non-fatal): {import_error}")

        try:
            from services.sms_automation import trigger_welcome_sms

            sms_result = trigger_welcome_sms(db, client.id)
            if sms_result.get("sent"):
                print(f"üì± Welcome SMS sent to client {client.id}")
        except Exception as sms_error:
            print(f"‚ö†Ô∏è  SMS trigger error (non-fatal): {sms_error}")

        try:
            from services.email_automation import trigger_welcome_email

            email_result = trigger_welcome_email(db, client.id)
            if email_result.get("sent"):
                print(f"üìß Welcome email sent to client {client.id}")
        except Exception as email_error:
            print(f"‚ö†Ô∏è  Email trigger error (non-fatal): {email_error}")

        try:
            affiliate_ref_code = form_data.get("referralCode", "").strip()
            if affiliate_ref_code:
                ref_result = affiliate_service.process_referral(
                    client.id, affiliate_ref_code
                )
                if ref_result.get("success"):
                    print(
                        f"ü§ù Client {client.id} linked to affiliate {ref_result.get('affiliate_name')}"
                    )
        except Exception as affiliate_error:
            print(f"‚ö†Ô∏è  Affiliate processing error (non-fatal): {affiliate_error}")

        try:
            WorkflowTriggersService.evaluate_triggers(
                "case_created",
                {
                    "client_id": client.id,
                    "client_name": client.name,
                    "email": client.email,
                    "phone": client.phone,
                    "plan": "free",
                },
            )
        except Exception as wf_error:
            print(f"‚ö†Ô∏è  Workflow trigger error (non-fatal): {wf_error}")

        return (
            jsonify(
                {
                    "success": True,
                    "clientId": client.id,
                    "referralCode": referral_code,
                    "portalToken": portal_token,
                    "passwordResetToken": password_reset_token,
                }
            ),
            201,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client/signup/complete-manual", methods=["POST"])
def api_complete_manual_signup():
    """Complete a signup with manual payment (CashApp, Venmo, Zelle, PayPal, Pay Later)"""
    db = get_db()
    try:
        data = request.json
        draft_id = data.get("draftId")
        payment_method = data.get("paymentMethod", "pending")

        if not draft_id:
            return jsonify({"success": False, "error": "Draft ID is required"}), 400

        draft = db.query(SignupDraft).filter_by(draft_uuid=draft_id).first()
        if not draft:
            return jsonify({"success": False, "error": "Signup draft not found"}), 404

        if draft.status != "pending":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Draft is not pending (status: {draft.status})",
                    }
                ),
                400,
            )

        form_data = draft.form_data or {}

        referral_code = generate_referral_code()
        portal_token = str(uuid.uuid4())
        password_reset_token = secrets.token_urlsafe(32)

        dob_str = form_data.get("dateOfBirth", "")
        dob = None
        if dob_str:
            try:
                from datetime import date as dt_date

                dob = dt_date.fromisoformat(dob_str)
            except:
                pass

        client = Client(
            name=f"{form_data.get('firstName', '')} {form_data.get('lastName', '')}".strip(),
            first_name=form_data.get("firstName", ""),
            last_name=form_data.get("lastName", ""),
            email=form_data.get("email", ""),
            phone=form_data.get("phone", ""),
            address_street=form_data.get("addressStreet", ""),
            address_city=form_data.get("addressCity", ""),
            address_state=form_data.get("addressState", ""),
            address_zip=form_data.get("addressZip", ""),
            ssn_last_four=form_data.get("ssnLast4", ""),
            date_of_birth=dob,
            credit_monitoring_service=form_data.get("creditService", ""),
            credit_monitoring_username=form_data.get("creditUsername", ""),
            credit_monitoring_password_encrypted=(
                encrypt_value(form_data.get("creditPassword", ""))
                if form_data.get("creditPassword")
                else ""
            ),
            status="lead",
            current_dispute_round=0,
            dispute_status="new",
            referral_code=referral_code,
            portal_token=portal_token,
            password_reset_token=password_reset_token,
            password_reset_expires=datetime.utcnow() + timedelta(days=7),
            signup_completed=True,
            agreement_signed=form_data.get("agreeTerms", False),
            agreement_signed_at=(
                datetime.utcnow() if form_data.get("agreeTerms") else None
            ),
        )

        db.add(client)
        draft.status = "completed"
        db.commit()

        # Auto-import if credentials provided
        if (
            form_data.get("creditService")
            and form_data.get("creditUsername")
            and form_data.get("creditPassword")
        ):
            try:
                from services.credit_import_automation import run_import_sync

                credit_password = decrypt_value(
                    client.credit_monitoring_password_encrypted
                )
                print(f"üöÄ Auto-importing credit report for {client.name}...")
                result = run_import_sync(
                    service_name=form_data.get("creditService"),
                    username=form_data.get("creditUsername"),
                    password=credit_password,
                    ssn_last4=form_data.get("ssnLast4", ""),
                    client_id=client.id,
                    client_name=client.name,
                )
                if result["success"]:
                    print(f"‚úÖ Auto-import successful for {client.name}")
            except Exception as import_error:
                print(f"‚ö†Ô∏è  Auto-import error (non-fatal): {import_error}")

        try:
            from services.sms_automation import trigger_welcome_sms

            sms_result = trigger_welcome_sms(db, client.id)
            if sms_result.get("sent"):
                print(f"üì± Welcome SMS sent to client {client.id}")
        except Exception as sms_error:
            print(f"‚ö†Ô∏è  SMS trigger error (non-fatal): {sms_error}")

        try:
            from services.email_automation import trigger_welcome_email

            email_result = trigger_welcome_email(db, client.id)
            if email_result.get("sent"):
                print(f"üìß Welcome email sent to client {client.id}")
        except Exception as email_error:
            print(f"‚ö†Ô∏è  Email trigger error (non-fatal): {email_error}")

        try:
            affiliate_ref_code = form_data.get("referralCode", "").strip()
            if affiliate_ref_code:
                ref_result = affiliate_service.process_referral(
                    client.id, affiliate_ref_code
                )
                if ref_result.get("success"):
                    print(
                        f"ü§ù Client {client.id} linked to affiliate {ref_result.get('affiliate_name')}"
                    )
        except Exception as affiliate_error:
            print(f"‚ö†Ô∏è  Affiliate processing error (non-fatal): {affiliate_error}")

        try:
            WorkflowTriggersService.evaluate_triggers(
                "case_created",
                {
                    "client_id": client.id,
                    "client_name": client.name,
                    "email": client.email,
                    "phone": client.phone,
                    "plan": draft.plan_tier,
                },
            )
        except Exception as wf_error:
            print(f"‚ö†Ô∏è  Workflow trigger error (non-fatal): {wf_error}")

        return (
            jsonify(
                {
                    "success": True,
                    "clientId": client.id,
                    "referralCode": referral_code,
                    "portalToken": portal_token,
                    "passwordResetToken": password_reset_token,
                    "paymentPending": True,
                }
            ),
            201,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client/set-password", methods=["POST"])
def api_set_client_password():
    """Set password for a newly signed up client"""
    db = get_db()
    try:
        data = request.json
        client_id = data.get("clientId")
        portal_token = data.get("portalToken")
        password = data.get("password")

        if not client_id or not portal_token or not password:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Client ID, portal token, and password are required",
                    }
                ),
                400,
            )

        if len(password) < 8:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Password must be at least 8 characters",
                    }
                ),
                400,
            )

        client = (
            db.query(Client).filter_by(id=client_id, portal_token=portal_token).first()
        )
        if not client:
            return jsonify({"success": False, "error": "Invalid client or token"}), 404

        # Hash and save the password
        client.portal_password_hash = generate_password_hash(password)
        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Password created successfully",
                    "portalToken": portal_token,
                }
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/stripe/checkout-session", methods=["POST"])
def api_create_checkout_session():
    """Create Stripe Checkout session for payment"""
    db = get_db()
    try:
        data = request.json
        draft_id = data.get("draftId")

        if not draft_id:
            return jsonify({"success": False, "error": "Draft ID is required"}), 400

        draft = db.query(SignupDraft).filter_by(draft_uuid=draft_id).first()
        if not draft:
            return jsonify({"success": False, "error": "Signup draft not found"}), 404

        if draft.status != "pending":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Draft is not pending (status: {draft.status})",
                    }
                ),
                400,
            )

        if draft.expires_at < datetime.utcnow():
            draft.status = "expired"
            db.commit()
            return (
                jsonify(
                    {"success": False, "error": "Draft has expired. Please start over."}
                ),
                400,
            )

        host = request.host_url.rstrip("/")
        success_url = f"{host}/signup/success?session_id={{CHECKOUT_SESSION_ID}}"
        cancel_url = f"{host}/signup?cancelled=true"

        form_data = draft.form_data or {}
        customer_email = form_data.get("email", "")

        from services.stripe_client import create_checkout_session

        session = create_checkout_session(
            draft_id=draft_id,
            tier_key=draft.plan_tier,
            success_url=success_url,
            cancel_url=cancel_url,
            customer_email=customer_email,
        )

        draft.stripe_checkout_session_id = session.id
        db.commit()

        return (
            jsonify(
                {"success": True, "sessionId": session.id, "checkoutUrl": session.url}
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/stripe/webhook", methods=["POST"])
def stripe_webhook():
    """Handle Stripe webhook events (payment confirmations)"""
    db = get_db()
    try:
        payload = request.get_data()
        sig_header = request.headers.get("Stripe-Signature")

        if not sig_header:
            print("‚ö†Ô∏è  Stripe webhook: Missing Stripe-Signature header")
            return jsonify({"error": "Missing signature"}), 400

        from services.stripe_client import get_webhook_secret, verify_webhook_signature

        try:
            event = verify_webhook_signature(payload, sig_header)
        except Exception as e:
            print(f"‚ö†Ô∏è  Stripe webhook signature verification failed: {e}")
            return jsonify({"error": "Invalid signature"}), 400

        event_type = event.get("type") if isinstance(event, dict) else event.type
        print(f"üîî Stripe webhook received: {event_type}")

        if event_type == "checkout.session.completed":
            session = (
                event.get("data", {}).get("object", {})
                if isinstance(event, dict)
                else event.data.object
            )
            handle_checkout_completed(db, session)

        elif event_type == "payment_intent.succeeded":
            payment_intent = (
                event.get("data", {}).get("object", {})
                if isinstance(event, dict)
                else event.data.object
            )
            handle_payment_succeeded(db, payment_intent)

        elif event_type == "payment_intent.payment_failed":
            payment_intent = (
                event.get("data", {}).get("object", {})
                if isinstance(event, dict)
                else event.data.object
            )
            handle_payment_failed(db, payment_intent)

        return jsonify({"received": True}), 200

    except Exception as e:
        import traceback

        traceback.print_exc()
        print(f"‚ùå Stripe webhook error: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


def handle_checkout_completed(db, session):
    """Handle checkout.session.completed event - promote draft to client"""
    try:
        session_id = session.get("id") if isinstance(session, dict) else session.id
        metadata = (
            session.get("metadata", {})
            if isinstance(session, dict)
            else session.metadata
        )
        customer_id = (
            session.get("customer") if isinstance(session, dict) else session.customer
        )
        payment_intent_id = (
            session.get("payment_intent")
            if isinstance(session, dict)
            else session.payment_intent
        )
        amount_total = (
            session.get("amount_total")
            if isinstance(session, dict)
            else session.amount_total
        )

        draft_id = metadata.get("draft_id") if metadata else None
        tier = metadata.get("tier") if metadata else None

        if not draft_id:
            print(f"‚ö†Ô∏è  Checkout session {session_id} has no draft_id in metadata")
            return

        draft = db.query(SignupDraft).filter_by(draft_uuid=draft_id).first()
        if not draft:
            print(f"‚ö†Ô∏è  Draft {draft_id} not found for session {session_id}")
            return

        if draft.status == "paid":
            print(f"‚úÖ Draft {draft_id} already processed")
            return

        form_data = draft.form_data or {}

        first_name = form_data.get("firstName", "")
        last_name = form_data.get("lastName", "")
        email = form_data.get("email", "")

        existing = db.query(Client).filter_by(email=email).first()
        if existing:
            print(f"‚ö†Ô∏è  Client with email {email} already exists")
            draft.status = "paid"
            draft.promoted_client_id = existing.id
            draft.promoted_at = datetime.utcnow()
            db.commit()
            return

        referral_code = "BP" + secrets.token_hex(4).upper()
        portal_token = secrets.token_urlsafe(32)

        from datetime import date

        dob_str = form_data.get("dateOfBirth", "")
        dob = None
        if dob_str:
            try:
                dob = date.fromisoformat(dob_str)
            except:
                pass

        client = Client(
            name=f"{first_name} {last_name}",
            first_name=first_name,
            last_name=last_name,
            email=email,
            phone=form_data.get("phone", ""),
            address_street=form_data.get("addressStreet", ""),
            address_city=form_data.get("addressCity", ""),
            address_state=form_data.get("addressState", ""),
            address_zip=form_data.get("addressZip", ""),
            ssn_last_four=form_data.get("ssnLast4", ""),
            date_of_birth=dob,
            credit_monitoring_service=form_data.get("creditService", ""),
            credit_monitoring_username=form_data.get("creditUsername", ""),
            credit_monitoring_password_encrypted=(
                encrypt_value(form_data.get("creditPassword", ""))
                if form_data.get("creditPassword")
                else ""
            ),
            current_dispute_round=0,
            dispute_status="new",
            referral_code=referral_code,
            portal_token=portal_token,
            status="active",
            signup_completed=True,
            agreement_signed=form_data.get("agreeTerms", False),
            agreement_signed_at=(
                datetime.utcnow() if form_data.get("agreeTerms") else None
            ),
            signup_plan=tier or draft.plan_tier,
            signup_amount=amount_total or draft.plan_amount,
            stripe_customer_id=customer_id,
            stripe_checkout_session_id=session_id,
            stripe_payment_intent_id=payment_intent_id,
            payment_status="paid",
            payment_received_at=datetime.utcnow(),
        )

        ref_code = form_data.get("referralCode", "").strip()
        if ref_code:
            referrer = db.query(Client).filter_by(referral_code=ref_code).first()
            if referrer:
                client.referred_by_client_id = referrer.id
                referral = ClientReferral(
                    referring_client_id=referrer.id,
                    referred_name=client.name,
                    referred_email=client.email,
                    referred_phone=client.phone,
                    status="signed_up",
                )
                db.add(referral)

        db.add(client)
        db.flush()

        case_number = generate_case_number()
        case = Case(
            client_id=client.id,
            case_number=case_number,
            status="intake",
            pricing_tier=tier or draft.plan_tier,
            base_fee=amount_total / 100 if amount_total else 0,
            portal_token=portal_token,
            intake_at=datetime.utcnow(),
        )
        db.add(case)
        db.flush()

        event = CaseEvent(
            case_id=case.id,
            event_type="signup",
            description=f"Client {client.name} signed up via Stripe payment ({tier or draft.plan_tier})",
            event_data=json.dumps(
                {"payment_intent": payment_intent_id, "amount": amount_total}
            ),
        )
        db.add(event)

        draft.status = "paid"
        draft.promoted_client_id = client.id
        draft.promoted_at = datetime.utcnow()

        db.commit()

        print(f"‚úÖ Promoted draft {draft_id} to client {client.id} ({client.email})")

        try:
            from services.sms_automation import trigger_welcome_sms

            sms_result = trigger_welcome_sms(db, client.id)
            if sms_result.get("sent"):
                print(f"üì± Welcome SMS sent to client {client.id}")
            else:
                print(f"üì± Welcome SMS skipped: {sms_result.get('reason', 'unknown')}")
        except Exception as sms_error:
            print(f"‚ö†Ô∏è  SMS trigger error (non-fatal): {sms_error}")

        try:
            from services.email_automation import trigger_welcome_email

            email_result = trigger_welcome_email(db, client.id)
            if email_result.get("sent"):
                print(f"üìß Welcome email sent to client {client.id}")
            else:
                print(
                    f"üìß Welcome email skipped: {email_result.get('reason', 'unknown')}"
                )
        except Exception as email_error:
            print(f"‚ö†Ô∏è  Email trigger error (non-fatal): {email_error}")

        try:
            WorkflowTriggersService.evaluate_triggers(
                "case_created",
                {
                    "client_id": client.id,
                    "client_name": client.name,
                    "email": client.email,
                    "phone": client.phone,
                    "plan": tier or draft.plan_tier,
                },
            )
            WorkflowTriggersService.evaluate_triggers(
                "payment_received",
                {
                    "client_id": client.id,
                    "amount": amount_total / 100 if amount_total else 0,
                    "payment_method": "stripe",
                    "plan": tier or draft.plan_tier,
                },
            )
        except Exception as wf_error:
            print(f"‚ö†Ô∏è  Workflow trigger error (non-fatal): {wf_error}")

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        print(f"‚ùå Error handling checkout completed: {e}")


def handle_payment_succeeded(db, payment_intent):
    """Handle payment_intent.succeeded event"""
    payment_intent_id = (
        payment_intent.get("id")
        if isinstance(payment_intent, dict)
        else payment_intent.id
    )
    print(f"üí∞ Payment succeeded: {payment_intent_id}")


def handle_payment_failed(db, payment_intent):
    """Handle payment_intent.payment_failed event"""
    payment_intent_id = (
        payment_intent.get("id")
        if isinstance(payment_intent, dict)
        else payment_intent.id
    )
    print(f"‚ùå Payment failed: {payment_intent_id}")


@app.route("/signup/success")
def signup_success():
    """Success page after Stripe checkout"""
    session_id = request.args.get("session_id")

    if not session_id:
        return render_template(
            "client_signup.html", success=False, error="Missing session ID"
        )

    db = get_db()
    try:
        draft = (
            db.query(SignupDraft)
            .filter_by(stripe_checkout_session_id=session_id)
            .first()
        )

        if not draft:
            return render_template(
                "client_signup.html", success=False, error="Session not found"
            )

        if draft.status == "paid" and draft.promoted_client_id:
            client = db.query(Client).filter_by(id=draft.promoted_client_id).first()
            if client:
                return render_template(
                    "client_signup.html",
                    success=True,
                    referral_code=client.referral_code,
                    client_name=client.name,
                    portal_token=client.portal_token,
                )

        return render_template(
            "client_signup.html",
            success=True,
            pending=True,
            message="Your payment is being processed. You will receive a confirmation email shortly.",
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return render_template("client_signup.html", success=False, error=str(e))
    finally:
        db.close()


@app.route("/welcome")
def welcome_redirect():
    """Redirect to signup welcome page"""
    return redirect(url_for("signup_welcome", **request.args))


@app.route("/signup/welcome")
def signup_welcome():
    """Welcome page after successful signup - standalone page"""
    referral_code = request.args.get("ref", "")
    pending = request.args.get("pending", "") == "true"
    password_token = request.args.get("token", "")
    return render_template(
        "signup_welcome.html",
        referral_code=referral_code,
        pending=pending,
        password_token=password_token,
    )


@app.route("/api/client/import", methods=["POST"])
def api_client_import():
    """Import existing client at their current dispute round"""
    db = get_db()
    try:
        data = request.json

        name = data.get("name", "").strip()
        email = data.get("email", "").strip()

        if not name:
            return jsonify({"success": False, "error": "Client name is required"}), 400

        from datetime import date

        dob_str = data.get("dateOfBirth", "")
        dob = None
        if dob_str:
            try:
                dob = date.fromisoformat(dob_str)
            except:
                pass

        referral_code = "BP" + secrets.token_hex(4).upper()
        portal_token = secrets.token_urlsafe(32)

        client = Client(
            name=name,
            first_name=data.get("firstName", ""),
            last_name=data.get("lastName", ""),
            email=email,
            phone=data.get("phone", ""),
            address_street=data.get("addressStreet", ""),
            address_city=data.get("addressCity", ""),
            address_state=data.get("addressState", ""),
            address_zip=data.get("addressZip", ""),
            ssn_last_four=data.get("ssnLast4", ""),
            date_of_birth=dob,
            credit_monitoring_service=data.get("creditService", ""),
            credit_monitoring_username=data.get("creditUsername", ""),
            current_dispute_round=int(data.get("currentRound", 1)),
            current_dispute_step=data.get("currentStep", ""),
            dispute_status=data.get("disputeStatus", "active"),
            legacy_system_id=data.get("legacySystemId", ""),
            legacy_case_number=data.get("legacyCaseNumber", ""),
            imported_at=datetime.utcnow(),
            import_notes=data.get("importNotes", ""),
            referral_code=referral_code,
            portal_token=portal_token,
            status="active",
            signup_completed=True,
            agreement_signed=True,
        )

        db.add(client)
        db.flush()

        case_number = generate_case_number()
        case = Case(
            client_id=client.id,
            case_number=case_number,
            status="intake",
            pricing_tier=data.get("pricingTier", "tier1"),
            portal_token=portal_token,
            intake_at=datetime.utcnow(),
        )
        db.add(case)
        db.flush()

        event = CaseEvent(
            case_id=case.id,
            event_type="import",
            description=f"Client imported from legacy system at round {client.current_dispute_round}",
        )
        db.add(event)

        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "clientId": client.id,
                    "caseId": case.id,
                    "caseNumber": case_number,
                    "message": f"Client imported successfully at round {client.current_dispute_round}",
                }
            ),
            201,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cra-response/upload", methods=["POST"])
def api_cra_response_upload():
    """Upload CRA response letter with automated dispute round handling"""
    db = get_db()
    try:
        client_id = request.form.get("clientId")
        case_id = request.form.get("caseId")
        bureau = request.form.get("bureau")
        dispute_round = int(request.form.get("disputeRound", 1))
        response_type = request.form.get("responseType", "unknown")
        items_deleted = int(request.form.get("itemsDeleted", 0))
        items_verified = int(request.form.get("itemsVerified", 0))
        items_updated = int(request.form.get("itemsUpdated", 0))
        auto_analyze = request.form.get("autoAnalyze", "false").lower() == "true"

        if not client_id or not bureau:
            return (
                jsonify(
                    {"success": False, "error": "Client ID and bureau are required"}
                ),
                400,
            )

        file = request.files.get("file")
        if not file:
            return jsonify({"success": False, "error": "File is required"}), 400

        # Security check: block dangerous file extensions
        if is_blocked_extension(file.filename):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "File type not allowed for security reasons",
                    }
                ),
                400,
            )

        # Only allow PDF files for CRA responses
        if not file.filename.lower().endswith(".pdf"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Only PDF files are allowed for CRA responses",
                    }
                ),
                400,
            )

        os.makedirs("static/cra_responses", exist_ok=True)
        filename = (
            f"{client_id}_{bureau}_round{dispute_round}_{secrets.token_hex(4)}.pdf"
        )
        file_path = f"static/cra_responses/{filename}"
        file.save(file_path)

        from datetime import date

        response_date_str = request.form.get("responseDate", "")
        response_date = None
        if response_date_str:
            try:
                response_date = date.fromisoformat(response_date_str)
            except:
                pass

        cra_response = CRAResponse(
            client_id=int(client_id),
            case_id=int(case_id) if case_id else None,
            bureau=bureau,
            dispute_round=dispute_round,
            response_type=response_type,
            response_date=response_date,
            received_date=date.today(),
            file_path=file_path,
            file_name=file.filename,
            file_size=os.path.getsize(file_path),
            uploaded_by_admin=True,
            items_deleted=items_deleted,
            items_verified=items_verified,
            items_updated=items_updated,
            requires_follow_up=(response_type in ["verified", "investigating"]),
        )

        if cra_response.requires_follow_up:
            from datetime import timedelta

            cra_response.follow_up_deadline = datetime.utcnow() + timedelta(days=30)

        db.add(cra_response)

        client = db.query(Client).filter_by(id=int(client_id)).first()
        old_status = None
        if client:
            old_status = client.dispute_status
            client.last_bureau_response_at = datetime.utcnow()
            if response_type in ["verified", "investigating"]:
                client.dispute_status = "waiting_response"
            elif response_type == "deleted":
                client.dispute_status = "active"

            # Fire status_changed trigger if status actually changed
            if old_status != client.dispute_status:
                try:
                    WorkflowTriggersService.evaluate_triggers(
                        "status_changed",
                        {
                            "client_id": client.id,
                            "client_name": client.name,
                            "old_status": old_status,
                            "new_status": client.dispute_status,
                        },
                    )
                except Exception as trigger_error:
                    print(f"‚ö†Ô∏è  Workflow trigger error (non-fatal): {trigger_error}")

        if response_type == "deleted" or items_deleted > 0:
            dispute_items = (
                db.query(DisputeItem)
                .filter(
                    DisputeItem.client_id == int(client_id),
                    DisputeItem.bureau == bureau,
                    DisputeItem.dispute_round == dispute_round,
                    DisputeItem.status.in_(["sent", "in_progress", "to_do"]),
                )
                .all()
            )

            items_to_mark = (
                min(items_deleted, len(dispute_items))
                if items_deleted > 0
                else len(dispute_items)
            )
            for i, item in enumerate(dispute_items):
                if i < items_to_mark:
                    item.status = "deleted"
                    item.response_date = date.today()

            print(
                f"üìã Marked {items_to_mark} DisputeItems as 'deleted' for client {client_id}, bureau {bureau}"
            )

        from services.deadline_service import complete_deadline

        active_deadlines = (
            db.query(CaseDeadline)
            .filter(
                CaseDeadline.client_id == int(client_id),
                CaseDeadline.bureau == bureau,
                CaseDeadline.dispute_round == dispute_round,
                CaseDeadline.deadline_type == "cra_response",
                CaseDeadline.status == "active",
            )
            .all()
        )

        for deadline in active_deadlines:
            deadline.status = "completed"
            deadline.completed_at = datetime.utcnow()
            deadline.notes = (
                deadline.notes or ""
            ) + f"\n[Auto-completed] Response received: {response_type}"

        case_event = CaseEvent(
            case_id=int(case_id) if case_id else None,
            event_type="cra_response_received",
            description=f"{bureau} response received for round {dispute_round}: {response_type}",
            event_data=json.dumps(
                {
                    "client_id": int(client_id),
                    "bureau": bureau,
                    "dispute_round": dispute_round,
                    "response_type": response_type,
                    "items_deleted": items_deleted,
                    "items_verified": items_verified,
                    "items_updated": items_updated,
                }
            ),
        )
        db.add(case_event)

        db.commit()

        round_status = check_round_complete_internal(db, int(client_id), dispute_round)

        if round_status.get("round_complete"):
            print(
                f"üéØ Round {dispute_round} complete for client {client_id}! All bureaus responded."
            )
            try:
                from services.email_automation import send_admin_notification

                send_admin_notification(
                    subject=f"Dispute Round {dispute_round} Complete - Client #{client_id}",
                    message=f"All 3 bureaus have responded for client #{client_id} in round {dispute_round}.\n\nSuccess Rate: {round_status.get('success_rate', 0):.1f}%\nDeleted: {round_status.get('total_deleted', 0)}\n\nConsider advancing to the next round.",
                )
            except Exception as email_err:
                print(f"‚ö†Ô∏è  Admin notification error (non-fatal): {email_err}")

        try:
            from services.sms_automation import trigger_cra_response

            sms_result = trigger_cra_response(db, int(client_id), bureau)
            if sms_result.get("sent"):
                print(f"üì± CRA response SMS sent to client {client_id} for {bureau}")
        except Exception as sms_error:
            print(f"‚ö†Ô∏è  SMS trigger error (non-fatal): {sms_error}")

        try:
            from services.letter_queue_service import check_cra_response_triggers

            letter_queue_results = check_cra_response_triggers(db, cra_response.id)
            if letter_queue_results:
                print(
                    f"üì¨ Letter Queue: {len(letter_queue_results)} letters auto-queued based on CRA response"
                )
                for lqr in letter_queue_results:
                    print(
                        f"   ‚Üí {lqr.get('letter_type_display', lqr.get('letter_type'))} ({lqr.get('priority')})"
                    )
        except Exception as lq_error:
            print(f"‚ö†Ô∏è  Letter queue trigger error (non-fatal): {lq_error}")

        analysis_result = None
        if auto_analyze:
            try:
                from services.ocr_service import analyze_cra_response

                analysis_result = analyze_cra_response(cra_response.id)
                if analysis_result.get("success"):
                    print(
                        f"ü§ñ Auto-analyzed CRA response {cra_response.id}: {analysis_result.get('summary', {})}"
                    )
                else:
                    print(f"‚ö†Ô∏è  Auto-analyze failed: {analysis_result.get('error')}")
            except Exception as analyze_error:
                print(f"‚ö†Ô∏è  Auto-analyze error (non-fatal): {analyze_error}")
                analysis_result = {"success": False, "error": str(analyze_error)}

        response_data = {
            "success": True,
            "responseId": cra_response.id,
            "message": f"{bureau} response uploaded successfully",
            "roundStatus": round_status,
        }

        if auto_analyze and analysis_result:
            response_data["analysis"] = analysis_result

        return jsonify(response_data), 201

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


def check_round_complete_internal(db, client_id, dispute_round):
    """Internal helper to check if a dispute round is complete"""
    bureaus = ["Experian", "TransUnion", "Equifax"]
    responses = (
        db.query(CRAResponse)
        .filter(
            CRAResponse.client_id == client_id,
            CRAResponse.dispute_round == dispute_round,
        )
        .all()
    )

    bureaus_responded = set()
    total_deleted = 0
    total_verified = 0
    total_updated = 0

    for resp in responses:
        if resp.bureau in bureaus:
            bureaus_responded.add(resp.bureau)
        total_deleted += resp.items_deleted or 0
        total_verified += resp.items_verified or 0
        total_updated += resp.items_updated or 0

    bureaus_missing = [b for b in bureaus if b not in bureaus_responded]
    round_complete = len(bureaus_missing) == 0

    total_items = total_deleted + total_verified + total_updated
    success_rate = (total_deleted / total_items * 100) if total_items > 0 else 0

    client = db.query(Client).filter_by(id=client_id).first()

    next_action = None
    if round_complete:
        if dispute_round < 4:
            next_action = "advance_round"
        else:
            next_action = "complete_or_litigation"

    return {
        "round_complete": round_complete,
        "bureaus_responded": list(bureaus_responded),
        "bureaus_missing": bureaus_missing,
        "total_deleted": total_deleted,
        "total_verified": total_verified,
        "total_updated": total_updated,
        "success_rate": success_rate,
        "current_round": dispute_round,
        "client_dispute_round": client.current_dispute_round if client else None,
        "next_action": next_action,
    }


@app.route("/api/client/<int:client_id>/responses")
def api_client_responses(client_id):
    """Get all CRA responses for a client"""
    db = get_db()
    try:
        responses = (
            db.query(CRAResponse)
            .filter_by(client_id=client_id)
            .order_by(CRAResponse.created_at.desc())
            .all()
        )

        return (
            jsonify(
                {
                    "success": True,
                    "responses": [
                        {
                            "id": r.id,
                            "bureau": r.bureau,
                            "disputeRound": r.dispute_round,
                            "responseType": r.response_type,
                            "responseDate": (
                                r.response_date.isoformat() if r.response_date else None
                            ),
                            "receivedDate": (
                                r.received_date.isoformat() if r.received_date else None
                            ),
                            "fileName": r.file_name,
                            "filePath": r.file_path,
                            "itemsVerified": r.items_verified,
                            "itemsDeleted": r.items_deleted,
                            "itemsUpdated": r.items_updated,
                            "requiresFollowUp": r.requires_follow_up,
                            "followUpDeadline": (
                                r.follow_up_deadline.isoformat()
                                if r.follow_up_deadline
                                else None
                            ),
                            "createdAt": r.created_at.isoformat(),
                        }
                        for r in responses
                    ],
                }
            ),
            200,
        )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# CRA RESPONSE ANALYSIS ENDPOINTS (AI-Powered)
# ============================================================


@app.route("/api/cra-response/<int:response_id>/analyze", methods=["POST"])
def api_analyze_cra_response(response_id):
    """
    Analyze a CRA response document using Claude AI.
    Extracts items, matches to existing DisputeItems, and detects reinsertion violations.

    Returns analysis results for staff review before applying changes.
    """
    db = get_db()
    try:
        cra_response = db.query(CRAResponse).filter_by(id=response_id).first()
        if not cra_response:
            return jsonify({"success": False, "error": "CRA Response not found"}), 404

        if not cra_response.file_path:
            return (
                jsonify(
                    {"success": False, "error": "No file attached to this CRA response"}
                ),
                400,
            )

        from services.ocr_service import analyze_cra_response

        result = analyze_cra_response(response_id)

        if result.get("success"):
            event = CaseEvent(
                case_id=cra_response.case_id,
                event_type="cra_response_analyzed",
                description=f"AI analyzed {cra_response.bureau} response for round {cra_response.dispute_round}",
                event_data=json.dumps(
                    {
                        "cra_response_id": response_id,
                        "ocr_record_id": result.get("ocr_record_id"),
                        "items_found": result.get("summary", {}).get(
                            "total_items_found", 0
                        ),
                        "items_matched": result.get("summary", {}).get(
                            "items_matched", 0
                        ),
                        "reinsertion_violations": result.get("summary", {}).get(
                            "reinsertion_violations", 0
                        ),
                        "tokens_used": result.get("tokens_used", 0),
                    }
                ),
            )
            db.add(event)
            db.commit()

            print(
                f"‚úÖ CRA Response {response_id} analyzed: {result.get('summary', {})}"
            )

        return jsonify(result)

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cra-response/<int:response_id>/analysis")
def api_get_cra_response_analysis(response_id):
    """Get the analysis results for a CRA response (for review)."""
    db = get_db()
    try:
        from database import CRAResponseOCR

        ocr_records = (
            db.query(CRAResponseOCR)
            .filter(
                CRAResponseOCR.client_id
                == db.query(CRAResponse.client_id).filter_by(id=response_id).scalar()
            )
            .order_by(CRAResponseOCR.created_at.desc())
            .all()
        )

        if not ocr_records:
            return (
                jsonify(
                    {"success": False, "error": "No analysis found for this response"}
                ),
                404,
            )

        latest = ocr_records[0]

        from services.ocr_service import get_analysis_for_review

        result = get_analysis_for_review(latest.id)

        return jsonify(result)

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cra-response/<int:response_id>/apply-analysis", methods=["POST"])
def api_apply_cra_response_analysis(response_id):
    """
    Apply the reviewed analysis to update DisputeItem statuses.
    Accepts optional edits to the matched items before applying.
    """
    db = get_db()
    try:
        data = request.json or {}
        ocr_record_id = data.get("ocr_record_id")
        reviewed_items = data.get("reviewed_items")
        create_violations = data.get("create_violations", True)

        staff_user = (
            session.get("staff_email") or session.get("staff_name") or "unknown"
        )

        if not ocr_record_id:
            from database import CRAResponseOCR

            cra_response = db.query(CRAResponse).filter_by(id=response_id).first()
            if not cra_response:
                return (
                    jsonify({"success": False, "error": "CRA Response not found"}),
                    404,
                )

            ocr_record = (
                db.query(CRAResponseOCR)
                .filter(
                    CRAResponseOCR.client_id == cra_response.client_id,
                    CRAResponseOCR.bureau == cra_response.bureau,
                )
                .order_by(CRAResponseOCR.created_at.desc())
                .first()
            )

            if not ocr_record:
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "No analysis found. Run analyze first.",
                        }
                    ),
                    400,
                )

            ocr_record_id = ocr_record.id

        from services.ocr_service import apply_analysis_updates

        result = apply_analysis_updates(
            ocr_record_id=ocr_record_id,
            reviewed_items=reviewed_items,
            create_violations=create_violations,
            staff_user=staff_user,
        )

        if result.get("success"):
            cra_response = db.query(CRAResponse).filter_by(id=response_id).first()

            updates_made = result.get("updates_made", [])
            deleted_count = len(
                [u for u in updates_made if u.get("new_status") == "deleted"]
            )
            verified_count = len(
                [u for u in updates_made if u.get("new_status") == "verified"]
            )
            updated_count = len(
                [u for u in updates_made if u.get("new_status") == "updated"]
            )

            if cra_response:
                cra_response.items_deleted = (
                    cra_response.items_deleted or 0
                ) + deleted_count
                cra_response.items_verified = (
                    cra_response.items_verified or 0
                ) + verified_count
                cra_response.items_updated = (
                    cra_response.items_updated or 0
                ) + updated_count

            event = CaseEvent(
                case_id=cra_response.case_id if cra_response else None,
                event_type="analysis_applied",
                description=f"Applied AI analysis: {len(updates_made)} items updated",
                event_data=json.dumps(
                    {
                        "cra_response_id": response_id,
                        "ocr_record_id": ocr_record_id,
                        "updates_applied": result.get("updates_applied", 0),
                        "violations_created": result.get("violations_created", 0),
                        "applied_by": staff_user,
                    }
                ),
            )
            db.add(event)
            db.commit()

            print(
                f"‚úÖ Analysis applied for response {response_id}: {result.get('updates_applied', 0)} updates"
            )

        return jsonify(result)

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cra-response/list")
def api_list_cra_responses():
    """Get all CRA responses with analysis status for dashboard."""
    db = get_db()
    try:
        from database import CRAResponseOCR

        responses = (
            db.query(CRAResponse)
            .order_by(CRAResponse.created_at.desc())
            .limit(100)
            .all()
        )

        response_list = []
        for r in responses:
            ocr_record = (
                db.query(CRAResponseOCR)
                .filter(
                    CRAResponseOCR.client_id == r.client_id,
                    CRAResponseOCR.bureau == r.bureau,
                )
                .order_by(CRAResponseOCR.created_at.desc())
                .first()
            )

            client = db.query(Client).filter_by(id=r.client_id).first()

            response_list.append(
                {
                    "id": r.id,
                    "clientId": r.client_id,
                    "clientName": client.name if client else "Unknown",
                    "bureau": r.bureau,
                    "disputeRound": r.dispute_round,
                    "responseType": r.response_type,
                    "responseDate": (
                        r.response_date.isoformat() if r.response_date else None
                    ),
                    "fileName": r.file_name,
                    "filePath": r.file_path,
                    "itemsVerified": r.items_verified,
                    "itemsDeleted": r.items_deleted,
                    "itemsUpdated": r.items_updated,
                    "hasAnalysis": ocr_record is not None,
                    "analysisReviewed": ocr_record.reviewed if ocr_record else False,
                    "ocrRecordId": ocr_record.id if ocr_record else None,
                    "confidenceScore": (
                        ocr_record.ocr_confidence if ocr_record else None
                    ),
                    "createdAt": r.created_at.isoformat(),
                }
            )

        return jsonify({"success": True, "responses": response_list})

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# DISPUTE ROUND AUTOMATION ENDPOINTS
# ============================================================


@app.route("/api/dispute/advance-round", methods=["POST"])
def api_advance_dispute_round():
    """
    Advance a client to the next dispute round.
    Creates CRA response deadlines for each bureau.
    """
    db = get_db()
    try:
        data = request.json
        client_id = data.get("client_id")
        new_round = int(data.get("new_round", 1))

        if not client_id:
            return jsonify({"success": False, "error": "Client ID is required"}), 400

        if new_round < 1 or new_round > 4:
            return (
                jsonify({"success": False, "error": "Round must be between 1 and 4"}),
                400,
            )

        client = db.query(Client).filter_by(id=int(client_id)).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        old_round = client.current_dispute_round or 0
        client.current_dispute_round = new_round
        client.round_started_at = datetime.utcnow()
        client.dispute_status = "active"

        from datetime import date

        from services.deadline_service import create_deadline

        bureaus = ["Experian", "TransUnion", "Equifax"]
        created_deadlines = []

        for bureau in bureaus:
            try:
                deadline = create_deadline(
                    db=db,
                    client_id=int(client_id),
                    case_id=None,
                    deadline_type="cra_response",
                    bureau=bureau,
                    dispute_round=new_round,
                    start_date=date.today(),
                    days_allowed=30,
                )
                created_deadlines.append(
                    {
                        "id": deadline.id,
                        "bureau": bureau,
                        "deadline_date": deadline.deadline_date.isoformat(),
                    }
                )
            except Exception as dl_err:
                print(f"‚ö†Ô∏è  Failed to create deadline for {bureau}: {dl_err}")

        case = db.query(Case).filter_by(client_id=int(client_id)).first()
        if case:
            event = CaseEvent(
                case_id=case.id,
                event_type="round_advanced",
                description=f"Dispute round advanced from {old_round} to {new_round}",
                event_data=json.dumps(
                    {
                        "client_id": int(client_id),
                        "old_round": old_round,
                        "new_round": new_round,
                        "deadlines_created": len(created_deadlines),
                    }
                ),
            )
            db.add(event)

        db.commit()

        print(
            f"‚úÖ Client {client_id} advanced to round {new_round}. Created {len(created_deadlines)} deadlines."
        )

        return (
            jsonify(
                {
                    "success": True,
                    "client_id": int(client_id),
                    "old_round": old_round,
                    "new_round": new_round,
                    "deadlines_created": created_deadlines,
                    "message": f"Successfully advanced to Round {new_round}",
                }
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/dispute/check-round-complete", methods=["GET", "POST"])
def api_check_round_complete():
    """
    Check if a dispute round is complete (all 3 bureaus responded).
    Returns completion status and recommended next action.
    """
    db = get_db()
    try:
        if request.method == "POST":
            data = request.json
            client_id = data.get("client_id")
            dispute_round = data.get("dispute_round")
        else:
            client_id = request.args.get("client_id")
            dispute_round = request.args.get("dispute_round")

        if not client_id:
            return jsonify({"success": False, "error": "Client ID is required"}), 400

        client = db.query(Client).filter_by(id=int(client_id)).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if not dispute_round:
            dispute_round = client.current_dispute_round or 1
        else:
            dispute_round = int(dispute_round)

        result = check_round_complete_internal(db, int(client_id), dispute_round)
        result["success"] = True
        result["client_name"] = client.name

        return jsonify(result), 200

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/dispute/round-summary")
def api_dispute_round_summary():
    """
    Get summary of all clients' dispute round status for the dashboard.
    Shows clients ready to advance and clients with incomplete rounds.
    """
    db = get_db()
    try:
        clients = (
            db.query(Client)
            .filter(
                Client.current_dispute_round > 0,
                Client.dispute_status.in_(["active", "waiting_response"]),
            )
            .all()
        )

        clients_ready_to_advance = []
        clients_incomplete_rounds = []

        for client in clients:
            dispute_round = client.current_dispute_round
            round_status = check_round_complete_internal(db, client.id, dispute_round)

            client_info = {
                "id": client.id,
                "name": client.name,
                "email": client.email,
                "current_round": dispute_round,
                "dispute_status": client.dispute_status,
                "round_started_at": (
                    client.round_started_at.isoformat()
                    if client.round_started_at
                    else None
                ),
                "bureaus_responded": round_status.get("bureaus_responded", []),
                "bureaus_missing": round_status.get("bureaus_missing", []),
                "total_deleted": round_status.get("total_deleted", 0),
                "total_verified": round_status.get("total_verified", 0),
                "success_rate": round_status.get("success_rate", 0),
                "round_complete": round_status.get("round_complete", False),
                "next_action": round_status.get("next_action"),
            }

            if round_status.get("round_complete"):
                clients_ready_to_advance.append(client_info)
            else:
                clients_incomplete_rounds.append(client_info)

        from datetime import date

        active_deadlines = (
            db.query(CaseDeadline)
            .filter(
                CaseDeadline.status == "active",
                CaseDeadline.deadline_type == "cra_response",
            )
            .count()
        )

        overdue_deadlines = (
            db.query(CaseDeadline)
            .filter(
                CaseDeadline.status == "active",
                CaseDeadline.deadline_type == "cra_response",
                CaseDeadline.deadline_date < date.today(),
            )
            .count()
        )

        return (
            jsonify(
                {
                    "success": True,
                    "ready_to_advance": clients_ready_to_advance,
                    "incomplete_rounds": clients_incomplete_rounds,
                    "stats": {
                        "total_active_clients": len(clients),
                        "ready_count": len(clients_ready_to_advance),
                        "incomplete_count": len(clients_incomplete_rounds),
                        "active_deadlines": active_deadlines,
                        "overdue_deadlines": overdue_deadlines,
                    },
                }
            ),
            200,
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/dispute/client/<int:client_id>/round-history")
def api_client_round_history(client_id):
    """Get dispute round history for a specific client"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        round_history = []
        for round_num in range(1, 5):
            responses = (
                db.query(CRAResponse)
                .filter(
                    CRAResponse.client_id == client_id,
                    CRAResponse.dispute_round == round_num,
                )
                .all()
            )

            if responses:
                round_data = {
                    "round": round_num,
                    "bureaus": {},
                    "total_deleted": 0,
                    "total_verified": 0,
                    "total_updated": 0,
                }

                for resp in responses:
                    round_data["bureaus"][resp.bureau] = {
                        "response_type": resp.response_type,
                        "response_date": (
                            resp.response_date.isoformat()
                            if resp.response_date
                            else None
                        ),
                        "items_deleted": resp.items_deleted or 0,
                        "items_verified": resp.items_verified or 0,
                        "items_updated": resp.items_updated or 0,
                    }
                    round_data["total_deleted"] += resp.items_deleted or 0
                    round_data["total_verified"] += resp.items_verified or 0
                    round_data["total_updated"] += resp.items_updated or 0

                total_items = (
                    round_data["total_deleted"]
                    + round_data["total_verified"]
                    + round_data["total_updated"]
                )
                round_data["success_rate"] = (
                    (round_data["total_deleted"] / total_items * 100)
                    if total_items > 0
                    else 0
                )
                round_data["is_complete"] = len(round_data["bureaus"]) >= 3

                round_history.append(round_data)

        return (
            jsonify(
                {
                    "success": True,
                    "client_id": client_id,
                    "client_name": client.name,
                    "current_round": client.current_dispute_round,
                    "dispute_status": client.dispute_status,
                    "round_history": round_history,
                }
            ),
            200,
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/import")
@require_staff(roles=["admin", "paralegal"])
def dashboard_import():
    """Admin page for importing existing clients"""
    return render_template("client_import.html")


@app.route("/api/credit-analysis/generate/<int:client_id>", methods=["POST"])
def api_generate_credit_analysis(client_id):
    """Generate a basic credit analysis PDF for a client"""
    db = get_db()
    try:
        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        data = request.json or {}

        credit_scores = {
            "equifax": data.get("equifax_score", "-"),
            "experian": data.get("experian_score", "-"),
            "transunion": data.get("transunion_score", "-"),
        }

        negative_items = data.get("negative_items", [])

        report_date = datetime.now().strftime("%B %d, %Y")

        os.makedirs("generated_pdfs", exist_ok=True)
        safe_name = client.name.replace(" ", "_").lower()
        output_path = f"generated_pdfs/credit_analysis_{safe_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"

        generator = CreditAnalysisPDFGenerator()
        pdf_path = generator.generate_credit_analysis_pdf(
            client_name=client.name,
            report_date=report_date,
            credit_scores=credit_scores,
            negative_items=negative_items,
            output_path=output_path,
        )

        return (
            jsonify(
                {
                    "success": True,
                    "pdf_path": pdf_path,
                    "client_name": client.name,
                    "generated_at": report_date,
                }
            ),
            200,
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/credit-analysis/download/<path:filename>")
def download_credit_analysis(filename):
    """Download a generated credit analysis PDF"""
    return send_file(
        f"generated_pdfs/{filename}", as_attachment=True, mimetype="application/pdf"
    )


@app.route("/api/import/template")
def api_import_template():
    """Download CSV template for bulk import"""
    import csv
    import io

    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(
        [
            "first_name",
            "last_name",
            "email",
            "phone",
            "address_street",
            "address_city",
            "address_state",
            "address_zip",
            "date_of_birth",
            "ssn_last_4",
            "credit_service",
            "current_round",
            "current_step",
            "dispute_status",
            "legacy_system_id",
            "legacy_case_number",
            "import_notes",
        ]
    )
    writer.writerow(
        [
            "John",
            "Doe",
            "john@example.com",
            "(555) 123-4567",
            "123 Main St",
            "New York",
            "NY",
            "10001",
            "1985-06-15",
            "1234",
            "IdentityIQ.com",
            "2",
            "waiting_response",
            "active",
            "CMM-12345",
            "CASE-001",
            "Transferred from CMM",
        ]
    )

    output.seek(0)
    return send_file(
        io.BytesIO(output.getvalue().encode("utf-8")),
        mimetype="text/csv",
        as_attachment=True,
        download_name="client_import_template.csv",
    )


@app.route("/api/client/import/bulk", methods=["POST"])
def api_client_import_bulk():
    """Bulk import clients from CSV file"""
    import csv
    import io

    db = get_db()
    try:
        file = request.files.get("file")
        if not file:
            return jsonify({"success": False, "error": "CSV file is required"}), 400

        content = file.read().decode("utf-8")
        reader = csv.DictReader(io.StringIO(content))

        results = []
        imported = 0
        failed = 0

        for row in reader:
            try:
                name = f"{row.get('first_name', '')} {row.get('last_name', '')}".strip()
                if not name or name == " ":
                    results.append(
                        {"name": "Unknown", "success": False, "error": "Name required"}
                    )
                    failed += 1
                    continue

                from datetime import date

                dob_str = row.get("date_of_birth", "")
                dob = None
                if dob_str:
                    try:
                        dob = date.fromisoformat(dob_str)
                    except:
                        pass

                referral_code = "BP" + secrets.token_hex(4).upper()
                portal_token = secrets.token_urlsafe(32)

                client = Client(
                    name=name,
                    first_name=row.get("first_name", ""),
                    last_name=row.get("last_name", ""),
                    email=row.get("email", ""),
                    phone=row.get("phone", ""),
                    address_street=row.get("address_street", ""),
                    address_city=row.get("address_city", ""),
                    address_state=row.get("address_state", ""),
                    address_zip=row.get("address_zip", ""),
                    ssn_last_four=row.get("ssn_last_4", ""),
                    date_of_birth=dob,
                    credit_monitoring_service=row.get("credit_service", ""),
                    current_dispute_round=int(row.get("current_round", 1)),
                    current_dispute_step=row.get("current_step", ""),
                    dispute_status=row.get("dispute_status", "active"),
                    legacy_system_id=row.get("legacy_system_id", ""),
                    legacy_case_number=row.get("legacy_case_number", ""),
                    imported_at=datetime.utcnow(),
                    import_notes=row.get("import_notes", ""),
                    referral_code=referral_code,
                    portal_token=portal_token,
                    status="active",
                    signup_completed=True,
                    agreement_signed=True,
                )

                db.add(client)
                db.flush()

                case_number = generate_case_number()
                case = Case(
                    client_id=client.id,
                    case_number=case_number,
                    status="intake",
                    pricing_tier="tier1",
                    portal_token=portal_token,
                    intake_at=datetime.utcnow(),
                )
                db.add(case)

                results.append(
                    {"name": name, "success": True, "caseNumber": case_number}
                )
                imported += 1

            except Exception as row_error:
                results.append(
                    {
                        "name": row.get("first_name", "Unknown"),
                        "success": False,
                        "error": str(row_error),
                    }
                )
                failed += 1

        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "imported": imported,
                    "failed": failed,
                    "results": results,
                }
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/referral", methods=["POST"])
def api_submit_referral():
    """Submit a client referral"""
    db = get_db()
    try:
        data = request.json

        referring_client_id = data.get("referringClientId")
        referred_name = data.get("referredName", "").strip()
        referred_email = data.get("referredEmail", "").strip()
        referred_phone = data.get("referredPhone", "").strip()
        comments = data.get("comments", "").strip()

        if not referred_name or not referred_email:
            return (
                jsonify({"success": False, "error": "Name and email are required"}),
                400,
            )

        referral = ClientReferral(
            referring_client_id=(
                int(referring_client_id) if referring_client_id else None
            ),
            referred_name=referred_name,
            referred_email=referred_email,
            referred_phone=referred_phone,
            status="pending",
        )

        db.add(referral)
        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "referralId": referral.id,
                    "message": "Referral submitted successfully! We will reach out to them soon.",
                }
            ),
            201,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# MANUAL REVIEW INTERFACE ENDPOINTS
# ============================================================


@app.route("/analysis/<int:analysis_id>/review")
def analysis_review_page(analysis_id):
    """Render the manual review interface for an analysis"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()

        return render_template(
            "analysis_review.html",
            analysis=analysis,
            violations=violations,
            standing=standing,
            damages=damages,
            score=score,
        )
    finally:
        db.close()


@app.route("/api/violation", methods=["POST"])
def api_add_violation():
    """Add a new violation manually"""
    db = get_db()
    try:
        data = request.json

        analysis_id = data.get("analysis_id")
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        violation = Violation(
            analysis_id=analysis_id,
            client_id=analysis.client_id,
            bureau=data.get("bureau", "Unknown"),
            account_name=data.get("account_name", "Unknown Account"),
            fcra_section=data.get("fcra_section", "611"),
            violation_type=data.get("violation_type", "Unknown"),
            description=data.get("description", ""),
            statutory_damages_min=float(data.get("statutory_damages_min", 100)),
            statutory_damages_max=float(data.get("statutory_damages_max", 1000)),
            is_willful=bool(data.get("is_willful", False)),
            willfulness_notes=data.get("willfulness_notes", ""),
        )

        db.add(violation)
        db.commit()
        db.refresh(violation)

        return (
            jsonify(
                {
                    "success": True,
                    "violation_id": violation.id,
                    "message": "Violation added successfully",
                }
            ),
            201,
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/violation/<int:violation_id>", methods=["GET"])
def api_get_violation(violation_id):
    """Get a single violation"""
    db = get_db()
    try:
        violation = db.query(Violation).filter_by(id=violation_id).first()
        if not violation:
            return jsonify({"success": False, "error": "Violation not found"}), 404

        return (
            jsonify(
                {
                    "success": True,
                    "violation": {
                        "id": violation.id,
                        "analysis_id": violation.analysis_id,
                        "bureau": violation.bureau,
                        "account_name": violation.account_name,
                        "fcra_section": violation.fcra_section,
                        "violation_type": violation.violation_type,
                        "description": violation.description,
                        "statutory_damages_min": violation.statutory_damages_min,
                        "statutory_damages_max": violation.statutory_damages_max,
                        "is_willful": violation.is_willful,
                        "willfulness_notes": violation.willfulness_notes,
                    },
                }
            ),
            200,
        )
    finally:
        db.close()


@app.route("/api/violation/<int:violation_id>", methods=["PUT"])
def api_update_violation(violation_id):
    """Update an existing violation"""
    db = get_db()
    try:
        violation = db.query(Violation).filter_by(id=violation_id).first()
        if not violation:
            return jsonify({"success": False, "error": "Violation not found"}), 404

        data = request.json

        if "bureau" in data:
            violation.bureau = data["bureau"]
        if "account_name" in data:
            violation.account_name = data["account_name"]
        if "fcra_section" in data:
            violation.fcra_section = data["fcra_section"]
        if "violation_type" in data:
            violation.violation_type = data["violation_type"]
        if "description" in data:
            violation.description = data["description"]
        if "statutory_damages_min" in data:
            violation.statutory_damages_min = float(data["statutory_damages_min"])
        if "statutory_damages_max" in data:
            violation.statutory_damages_max = float(data["statutory_damages_max"])
        if "is_willful" in data:
            violation.is_willful = bool(data["is_willful"])
        if "willfulness_notes" in data:
            violation.willfulness_notes = data["willfulness_notes"]

        db.commit()

        return jsonify({"success": True, "message": "Violation updated"}), 200

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/violation/<int:violation_id>", methods=["DELETE"])
def api_delete_violation(violation_id):
    """Delete a violation"""
    db = get_db()
    try:
        violation = db.query(Violation).filter_by(id=violation_id).first()
        if not violation:
            return jsonify({"success": False, "error": "Violation not found"}), 404

        db.delete(violation)
        db.commit()

        return jsonify({"success": True, "message": "Violation deleted"}), 200

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/standing", methods=["PUT"])
def api_update_standing(analysis_id):
    """Update standing data for an analysis"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        data = request.json

        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()

        if not standing:
            standing = Standing(analysis_id=analysis_id, client_id=analysis.client_id)
            db.add(standing)

        standing.has_concrete_harm = bool(data.get("has_concrete_harm", False))
        standing.concrete_harm_type = data.get("concrete_harm_type", "")
        standing.concrete_harm_details = data.get("concrete_harm_details", "")
        standing.has_dissemination = bool(data.get("has_dissemination", False))
        standing.dissemination_details = data.get("dissemination_details", "")
        standing.has_causation = bool(data.get("has_causation", False))
        standing.causation_details = data.get("causation_details", "")
        standing.denial_letters_count = int(data.get("denial_letters_count", 0))
        standing.adverse_action_notices_count = int(
            data.get("adverse_action_notices_count", 0)
        )
        standing.standing_verified = True

        db.commit()

        return jsonify({"success": True, "message": "Standing updated"}), 200

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/damages", methods=["PUT"])
def api_update_damages(analysis_id):
    """Update damages data and recalculate totals"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        data = request.json

        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()

        if not damages:
            damages = Damages(analysis_id=analysis_id, client_id=analysis.client_id)
            db.add(damages)

        damages.credit_denials_amount = float(data.get("credit_denials_amount", 0))
        damages.higher_interest_amount = float(data.get("higher_interest_amount", 0))
        damages.credit_monitoring_amount = float(
            data.get("credit_monitoring_amount", 0)
        )
        damages.time_stress_amount = float(data.get("time_stress_amount", 0))
        damages.other_actual_amount = float(data.get("other_actual_amount", 0))
        damages.notes = data.get("notes", "")

        damages.actual_damages_total = (
            damages.credit_denials_amount
            + damages.higher_interest_amount
            + damages.credit_monitoring_amount
            + damages.time_stress_amount
            + damages.other_actual_amount
        )

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        violations_data = [
            {
                "fcra_section": v.fcra_section,
                "is_willful": v.is_willful,
                "violation_type": v.violation_type,
            }
            for v in violations
        ]

        actual_damages_input = {
            "credit_denials": damages.credit_denials_amount,
            "higher_interest": damages.higher_interest_amount,
            "credit_monitoring": damages.credit_monitoring_amount,
            "time_stress": damages.time_stress_amount,
            "other": damages.other_actual_amount,
            "notes": damages.notes,
        }
        damages_calc = calculate_damages(violations_data, actual_damages_input)

        damages.statutory_damages_total = damages_calc["statutory"]["total"]
        damages.section_605b_count = damages_calc["statutory"]["605b"]["count"]
        damages.section_605b_amount = damages_calc["statutory"]["605b"]["amount"]
        damages.section_607b_count = damages_calc["statutory"]["607b"]["count"]
        damages.section_607b_amount = damages_calc["statutory"]["607b"]["amount"]
        damages.section_611_count = damages_calc["statutory"]["611"]["count"]
        damages.section_611_amount = damages_calc["statutory"]["611"]["amount"]
        damages.section_623_count = damages_calc["statutory"]["623"]["count"]
        damages.section_623_amount = damages_calc["statutory"]["623"]["amount"]
        damages.willfulness_multiplier = damages_calc["punitive"]["multiplier"]
        damages.punitive_damages_amount = damages_calc["punitive"]["amount"]
        damages.estimated_hours = damages_calc["attorney_fees"]["estimated_hours"]
        damages.hourly_rate = damages_calc["attorney_fees"]["hourly_rate"]
        damages.attorney_fees_projection = damages_calc["attorney_fees"]["total"]
        damages.total_exposure = damages_calc["settlement"]["total_exposure"]
        damages.settlement_target = damages_calc["settlement"]["target"]
        damages.minimum_acceptable = damages_calc["settlement"]["minimum"]

        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        standing_data = {
            "has_concrete_harm": standing.has_concrete_harm if standing else False,
            "has_dissemination": standing.has_dissemination if standing else False,
            "has_causation": standing.has_causation if standing else False,
            "denial_letters_count": standing.denial_letters_count if standing else 0,
        }
        documentation_complete = len(violations_data) > 0 and standing is not None

        score_data = calculate_case_score(
            standing_data, violations_data, damages_calc, documentation_complete
        )

        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()
        if not case_score:
            case_score = CaseScore(
                analysis_id=analysis_id, client_id=analysis.client_id
            )
            db.add(case_score)

        case_score.total_score = score_data["total"]
        case_score.standing_score = score_data["standing"]
        case_score.violation_quality_score = score_data["violation_quality"]
        case_score.willfulness_score = score_data["willfulness"]
        case_score.documentation_score = score_data["documentation"]
        case_score.settlement_probability = score_data["settlement_probability"]
        case_score.case_strength = score_data["case_strength"]
        case_score.recommendation = score_data["recommendation"]
        case_score.recommendation_notes = "\n".join(score_data["notes"])

        db.commit()

        return (
            jsonify(
                {"success": True, "message": "Damages updated and scores recalculated"}
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# ENHANCED DOCUMENT GENERATION ENDPOINTS
# ============================================================


@app.route("/api/generate/client-report/<int:analysis_id>", methods=["POST"])
def api_generate_client_report(analysis_id):
    """Generate comprehensive 40-50 page client report"""
    db = get_db()
    try:
        from services.pdf.client_report import ClientReportBuilder

        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()

        client_data = {
            "client_name": analysis.client_name,
            "report_date": datetime.now().strftime("%B %d, %Y"),
            "dispute_round": analysis.dispute_round,
            "credit_scores": {},
            "violations": [
                {
                    "id": v.id,
                    "bureau": v.bureau,
                    "account_name": v.account_name,
                    "fcra_section": v.fcra_section,
                    "violation_type": v.violation_type,
                    "description": v.description,
                    "statutory_damages_min": v.statutory_damages_min,
                    "statutory_damages_max": v.statutory_damages_max,
                    "is_willful": v.is_willful,
                    "willfulness_notes": v.willfulness_notes,
                }
                for v in violations
            ],
            "standing": (
                {
                    "has_concrete_harm": (
                        standing.has_concrete_harm if standing else False
                    ),
                    "concrete_harm_type": (
                        standing.concrete_harm_type if standing else ""
                    ),
                    "concrete_harm_details": (
                        standing.concrete_harm_details if standing else ""
                    ),
                    "has_dissemination": (
                        standing.has_dissemination if standing else False
                    ),
                    "dissemination_details": (
                        standing.dissemination_details if standing else ""
                    ),
                    "has_causation": standing.has_causation if standing else False,
                    "causation_details": standing.causation_details if standing else "",
                    "denial_letters_count": (
                        standing.denial_letters_count if standing else 0
                    ),
                    "adverse_action_notices_count": (
                        standing.adverse_action_notices_count if standing else 0
                    ),
                }
                if standing
                else None
            ),
            "damages": (
                {
                    "actual_damages_total": (
                        damages.actual_damages_total if damages else 0
                    ),
                    "statutory_damages_total": (
                        damages.statutory_damages_total if damages else 0
                    ),
                    "punitive_damages_amount": (
                        damages.punitive_damages_amount if damages else 0
                    ),
                    "total_exposure": damages.total_exposure if damages else 0,
                    "settlement_target": damages.settlement_target if damages else 0,
                    "minimum_acceptable": damages.minimum_acceptable if damages else 0,
                    "credit_denials_amount": (
                        damages.credit_denials_amount if damages else 0
                    ),
                    "higher_interest_amount": (
                        damages.higher_interest_amount if damages else 0
                    ),
                    "credit_monitoring_amount": (
                        damages.credit_monitoring_amount if damages else 0
                    ),
                    "time_stress_amount": damages.time_stress_amount if damages else 0,
                    "other_actual_amount": (
                        damages.other_actual_amount if damages else 0
                    ),
                    "section_605b_count": damages.section_605b_count if damages else 0,
                    "section_605b_amount": (
                        damages.section_605b_amount if damages else 0
                    ),
                    "section_607b_count": damages.section_607b_count if damages else 0,
                    "section_607b_amount": (
                        damages.section_607b_amount if damages else 0
                    ),
                    "section_611_count": damages.section_611_count if damages else 0,
                    "section_611_amount": damages.section_611_amount if damages else 0,
                    "section_623_count": damages.section_623_count if damages else 0,
                    "section_623_amount": damages.section_623_amount if damages else 0,
                    "attorney_fees_projection": (
                        damages.attorney_fees_projection if damages else 0
                    ),
                    "notes": damages.notes if damages else "",
                }
                if damages
                else None
            ),
            "case_score": (
                {
                    "total_score": case_score.total_score if case_score else 0,
                    "case_strength": (
                        case_score.case_strength if case_score else "Unknown"
                    ),
                    "standing_score": case_score.standing_score if case_score else 0,
                    "violation_quality_score": (
                        case_score.violation_quality_score if case_score else 0
                    ),
                    "willfulness_score": (
                        case_score.willfulness_score if case_score else 0
                    ),
                    "documentation_score": (
                        case_score.documentation_score if case_score else 0
                    ),
                    "settlement_probability": (
                        case_score.settlement_probability if case_score else 0
                    ),
                    "recommendation": (
                        case_score.recommendation if case_score else "pending"
                    ),
                }
                if case_score
                else None
            ),
        }

        os.makedirs("static/generated_reports", exist_ok=True)
        safe_name = analysis.client_name.replace(" ", "_")
        filename = (
            f"{safe_name}_Client_Report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        )
        output_path = f"static/generated_reports/{filename}"

        builder = ClientReportBuilder()
        builder.generate(output_path, client_data)

        doc = Document(
            case_id=None,
            analysis_id=analysis_id,
            document_type="client_report",
            filename=filename,
            file_path=output_path,
            file_size=os.path.getsize(output_path),
        )
        db.add(doc)
        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "filename": filename,
                    "filepath": output_path,
                    "document_id": doc.id,
                }
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/generate/internal-memo/<int:analysis_id>", methods=["POST"])
def api_generate_internal_memo(analysis_id):
    """Generate 3-5 page internal staff analysis memo"""
    db = get_db()
    try:
        from services.pdf.internal_memo import InternalMemoBuilder

        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()

        case_data = {
            "client_name": analysis.client_name,
            "analysis_id": analysis.id,
            "dispute_round": analysis.dispute_round,
            "violations": [
                {
                    "id": v.id,
                    "bureau": v.bureau,
                    "account_name": v.account_name,
                    "fcra_section": v.fcra_section,
                    "violation_type": v.violation_type,
                    "description": v.description,
                    "statutory_damages_min": v.statutory_damages_min,
                    "statutory_damages_max": v.statutory_damages_max,
                    "is_willful": v.is_willful,
                    "willfulness_notes": v.willfulness_notes,
                }
                for v in violations
            ],
            "standing": (
                {
                    "has_concrete_harm": (
                        standing.has_concrete_harm if standing else False
                    ),
                    "concrete_harm_type": (
                        standing.concrete_harm_type if standing else ""
                    ),
                    "has_dissemination": (
                        standing.has_dissemination if standing else False
                    ),
                    "dissemination_details": (
                        standing.dissemination_details if standing else ""
                    ),
                    "has_causation": standing.has_causation if standing else False,
                    "causation_details": standing.causation_details if standing else "",
                }
                if standing
                else None
            ),
            "damages": (
                {
                    "actual_damages_total": (
                        damages.actual_damages_total if damages else 0
                    ),
                    "statutory_damages_total": (
                        damages.statutory_damages_total if damages else 0
                    ),
                    "punitive_damages_amount": (
                        damages.punitive_damages_amount if damages else 0
                    ),
                    "total_exposure": damages.total_exposure if damages else 0,
                    "settlement_target": damages.settlement_target if damages else 0,
                    "minimum_acceptable": damages.minimum_acceptable if damages else 0,
                    "attorney_fees_projection": (
                        damages.attorney_fees_projection if damages else 0
                    ),
                }
                if damages
                else None
            ),
            "case_score": (
                {
                    "total_score": case_score.total_score if case_score else 0,
                    "case_strength": (
                        case_score.case_strength if case_score else "Unknown"
                    ),
                    "standing_score": case_score.standing_score if case_score else 0,
                    "violation_quality_score": (
                        case_score.violation_quality_score if case_score else 0
                    ),
                    "willfulness_score": (
                        case_score.willfulness_score if case_score else 0
                    ),
                    "documentation_score": (
                        case_score.documentation_score if case_score else 0
                    ),
                    "settlement_probability": (
                        case_score.settlement_probability if case_score else 0
                    ),
                    "recommendation": (
                        case_score.recommendation if case_score else "pending"
                    ),
                }
                if case_score
                else None
            ),
        }

        os.makedirs("static/generated_reports", exist_ok=True)
        safe_name = analysis.client_name.replace(" ", "_")
        filename = (
            f"{safe_name}_Internal_Memo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        )
        output_path = f"static/generated_reports/{filename}"

        builder = InternalMemoBuilder()
        builder.generate(output_path, case_data)

        doc = Document(
            case_id=None,
            analysis_id=analysis_id,
            document_type="internal_memo",
            filename=filename,
            file_path=output_path,
            file_size=os.path.getsize(output_path),
        )
        db.add(doc)
        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "filename": filename,
                    "filepath": output_path,
                    "document_id": doc.id,
                }
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/generate/round-letters/<int:analysis_id>", methods=["POST"])
def api_generate_round_letters(analysis_id):
    """Generate round-specific dispute letters"""
    db = get_db()
    try:
        from services.pdf.round_letters import RoundLetterBuilder

        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        client = db.query(Client).filter_by(id=analysis.client_id).first()
        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()

        dispute_round = analysis.dispute_round

        client_data = {
            "client_name": client.name if client else analysis.client_name,
            "ssn_last_four": client.ssn_last_four if client else "XXXX",
            "address": (
                {
                    "street": client.address_street if client else "",
                    "city": client.address_city if client else "",
                    "state": client.address_state if client else "",
                    "zip": client.address_zip if client else "",
                }
                if client
                else {}
            ),
            "violations": [
                {
                    "id": v.id,
                    "bureau": v.bureau,
                    "account_name": v.account_name,
                    "fcra_section": v.fcra_section,
                    "violation_type": v.violation_type,
                    "description": v.description,
                    "is_willful": v.is_willful,
                }
                for v in violations
            ],
            "damages": (
                {
                    "total_exposure": damages.total_exposure if damages else 0,
                    "settlement_target": damages.settlement_target if damages else 0,
                    "actual_damages_total": (
                        damages.actual_damages_total if damages else 0
                    ),
                    "statutory_damages_total": (
                        damages.statutory_damages_total if damages else 0
                    ),
                    "punitive_damages_amount": (
                        damages.punitive_damages_amount if damages else 0
                    ),
                    "attorney_fees_projection": (
                        damages.attorney_fees_projection if damages else 0
                    ),
                }
                if damages
                else None
            ),
        }

        os.makedirs("static/generated_letters", exist_ok=True)
        builder = RoundLetterBuilder()

        generated_letters = []
        bureaus = ["Equifax", "Experian", "TransUnion"]

        for bureau in bureaus:
            safe_name = analysis.client_name.replace(" ", "_")
            filename = f"{safe_name}_{bureau}_R{dispute_round}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
            output_path = f"static/generated_letters/{filename}"

            if dispute_round == 1:
                builder.generate_round_1(output_path, client_data, bureau)
            elif dispute_round == 2:
                builder.generate_round_2(output_path, client_data, bureau)
            elif dispute_round == 3:
                builder.generate_round_3(output_path, client_data, bureau)
            elif dispute_round == 4:
                builder.generate_round_4(output_path, client_data, bureau)
            else:
                builder.generate_round_1(output_path, client_data, bureau)

            letter_record = DisputeLetter(
                analysis_id=analysis_id,
                client_id=analysis.client_id,
                client_name=analysis.client_name,
                bureau=bureau,
                round_number=dispute_round,
                letter_content=f"Round {dispute_round} letter generated",
                file_path=output_path,
            )
            db.add(letter_record)

            generated_letters.append(
                {"bureau": bureau, "filename": filename, "filepath": output_path}
            )

        db.commit()

        return (
            jsonify(
                {"success": True, "round": dispute_round, "letters": generated_letters}
            ),
            200,
        )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# EMAIL PREVIEW & SEND ENDPOINTS
# ============================================================


@app.route("/api/analysis/<int:analysis_id>/email-preview", methods=["GET"])
def api_get_email_preview(analysis_id):
    """Get HTML email preview for analysis"""
    db = get_db()
    try:
        # Apple-style email generator imported at top

        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()
        client = db.query(Client).filter_by(id=analysis.client_id).first()

        # Prepare data for email template
        violations_list = [
            {
                "bureau": v.bureau,
                "account_name": v.account_name,
                "violation_type": v.violation_type,
                "description": v.description,
            }
            for v in violations
        ]

        damages_info = {
            "total_exposure": damages.total_exposure if damages else 0,
            "settlement_target": damages.settlement_target if damages else 0,
            "violations_count": len(violations),
        }

        case_strength = case_score.case_strength if case_score else "Moderate"

        # Get portal URL if client has one
        portal_url = None
        if client and client.portal_token:
            portal_url = f"{request.host_url}portal/{client.portal_token}"

        # Generate HTML email
        html_content = generate_client_email_html(
            analysis, violations, standing, damages, case_score
        )

        return (
            jsonify(
                {
                    "success": True,
                    "html": html_content,
                    "client_email": client.email if client else None,
                    "subject": "Your Credit Analysis is Complete",
                }
            ),
            200,
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/analysis/<int:analysis_id>/send-email", methods=["POST"])
def api_send_analysis_email(analysis_id):
    """Send FCRA analysis email to client"""
    db = get_db()
    try:
        # Apple-style email generator imported at top
        import os

        from services.email_automation import send_email

        data = request.json
        to_email = data.get("to_email")
        subject = data.get("subject", "Your Credit Analysis is Complete")
        attach_pdf = data.get("attach_pdf", True)

        if not to_email:
            return (
                jsonify({"success": False, "error": "Email address is required"}),
                400,
            )

        analysis = db.query(Analysis).filter_by(id=analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        violations = db.query(Violation).filter_by(analysis_id=analysis_id).all()
        standing = db.query(Standing).filter_by(analysis_id=analysis_id).first()
        damages = db.query(Damages).filter_by(analysis_id=analysis_id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis_id).first()
        client = db.query(Client).filter_by(id=analysis.client_id).first()

        # Prepare data for email template
        violations_list = [
            {
                "bureau": v.bureau,
                "account_name": v.account_name,
                "violation_type": v.violation_type,
                "description": v.description,
            }
            for v in violations
        ]

        damages_info = {
            "total_exposure": damages.total_exposure if damages else 0,
            "settlement_target": damages.settlement_target if damages else 0,
            "violations_count": len(violations),
        }

        case_strength = case_score.case_strength if case_score else "Moderate"

        # Get portal URL if client has one
        portal_url = None
        if client and client.portal_token:
            portal_url = f"{request.host_url}portal/{client.portal_token}"

        # Generate HTML email
        html_content = generate_client_email_html(
            analysis, violations, standing, damages, case_score
        )

        # Generate new 7-page Apple-style Client Report PDF if attach_pdf is True
        attachments = None
        if attach_pdf:
            import base64
            import tempfile

            try:
                # Create temporary file for PDF
                with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
                    tmp_path = tmp.name

                # Generate 7-page Apple-style report HTML
                report_html = generate_client_report_html(
                    analysis,
                    violations,
                    standing,
                    damages,
                    case_score,
                    credit_scores=None,
                )

                # Convert HTML to PDF using WeasyPrint
                html_to_pdf(report_html, tmp_path)

                # Read and encode PDF to base64
                with open(tmp_path, "rb") as f:
                    pdf_data = f.read()
                    pdf_base64 = base64.b64encode(pdf_data).decode()

                # Clean up temporary file
                os.unlink(tmp_path)

                # Attach PDF to email
                pdf_filename = (
                    f'{analysis.client_name.replace(" ", "_")}_Client_Report.pdf'
                )
                attachments = [
                    {
                        "content": pdf_base64,
                        "filename": pdf_filename,
                        "type": "application/pdf",
                    }
                ]
            except Exception as pdf_error:
                print(f"Error generating PDF attachment: {pdf_error}")
                import traceback

                traceback.print_exc()
                # Continue without attachment if PDF generation fails

        # Send email
        result = send_email(to_email, subject, html_content, attachments=attachments)

        if result.get("success"):
            return (
                jsonify(
                    {
                        "success": True,
                        "message": f"Email sent successfully to {to_email}",
                        "message_id": result.get("message_id"),
                    }
                ),
                200,
            )
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": result.get("error", "Failed to send email"),
                    }
                ),
                500,
            )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# DISPUTE ITEM & SECONDARY FREEZE API ENDPOINTS
# ============================================================


@app.route("/api/dispute-items/batch-update", methods=["POST"])
def api_batch_update_dispute_items():
    """Batch update dispute item comments from client portal"""
    db = get_db()
    try:
        data = request.json
        updates = data.get("updates", [])

        for update in updates:
            item_id = update.get("id")
            comments = update.get("comments", "")

            if item_id:
                item = db.query(DisputeItem).filter_by(id=item_id).first()
                if item:
                    item.comments = comments
                    item.updated_at = datetime.utcnow()

        db.commit()
        return jsonify({"success": True, "updated": len(updates)}), 200

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/secondary-freezes/batch-update", methods=["POST"])
def api_batch_update_secondary_freezes():
    """Batch update secondary bureau freeze status from client portal"""
    db = get_db()
    try:
        data = request.json
        updates = data.get("updates", [])

        for update in updates:
            freeze_id = update.get("id")
            status = update.get("status", "pending")
            comments = update.get("comments", "")

            if freeze_id:
                freeze = db.query(SecondaryBureauFreeze).filter_by(id=freeze_id).first()
                if freeze:
                    freeze.status = status
                    freeze.comments = comments
                    freeze.updated_at = datetime.utcnow()

                    if status == "frozen" and not freeze.freeze_confirmed_at:
                        freeze.freeze_confirmed_at = datetime.utcnow()

        db.commit()
        return jsonify({"success": True, "updated": len(updates)}), 200

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# CONTACT LIST MANAGEMENT ENDPOINTS
# ============================================================


@app.route("/dashboard/contacts")
@require_staff(roles=["admin", "paralegal", "attorney"])
def dashboard_contacts():
    """Enhanced contact list page with CRM features"""
    db = get_db()
    try:
        filter_type = request.args.get("filter", "all")
        page = int(request.args.get("page", 1))
        rows_per_page = request.args.get("rows", "25")

        query = db.query(Client)

        if filter_type == "mark1":
            query = query.filter(Client.mark_1 == True)
        elif filter_type == "mark2":
            query = query.filter(Client.mark_2 == True)
        elif filter_type == "affiliates":
            query = query.filter(Client.is_affiliate == True)
        elif filter_type == "active":
            query = query.filter(Client.client_type == "C")
        elif filter_type == "leads":
            query = query.filter(Client.client_type == "L")
        elif filter_type == "cancelled":
            query = query.filter(Client.client_type == "X")
        elif filter_type == "paused":
            query = query.filter(Client.client_type == "I")
        elif filter_type == "PLACEHOLDER":
            query = query.filter(Client.client_type == "L")
        elif filter_type == "follow_up":
            query = query.filter(Client.follow_up_date != None)
        elif filter_type == "signups":
            query = query.filter(Client.signup_completed == True)
        elif filter_type == "last25":
            query = query.order_by(Client.created_at.desc()).limit(25)
            contacts = query.all()

            # Get dispute letters for each contact
            import glob
            import os

            contact_letters = {}
            for contact in contacts:
                # Get all analyses ordered by most recent first
                analyses = (
                    db.query(Analysis)
                    .filter_by(client_id=contact.id)
                    .order_by(Analysis.created_at.desc())
                    .all()
                )
                letters = []

                # Collect dispute letters from ALL analyses
                for analysis in analyses:
                    dispute_letters = (
                        db.query(DisputeLetter).filter_by(analysis_id=analysis.id).all()
                    )
                    for letter in dispute_letters:
                        if letter.file_path:
                            filename = (
                                letter.file_path.split("/")[-1]
                                if "/" in letter.file_path
                                else letter.file_path
                            )
                            letters.append(
                                {
                                    "id": letter.id,
                                    "bureau": letter.bureau,
                                    "round_number": letter.round_number,
                                    "file_path": letter.file_path,
                                    "filename": filename,
                                }
                            )

                # Add Client/Legal reports ONCE from most recent analysis only (no duplicates)
                if analyses:
                    latest_analysis = analyses[0]  # Most recent analysis
                    violations = (
                        db.query(Violation)
                        .filter_by(analysis_id=latest_analysis.id)
                        .first()
                    )
                    if violations:
                        # Add Client Report option (generates on-demand)
                        letters.append(
                            {
                                "id": f"client_report_{latest_analysis.id}",
                                "bureau": "Client Report",
                                "round_number": None,
                                "file_path": None,  # Not used - generates on-demand
                                "filename": "Client_Report.pdf",
                                "analysis_id": latest_analysis.id,
                                "report_type": "client",
                            }
                        )

                        # Add Legal Analysis option (generates on-demand)
                        letters.append(
                            {
                                "id": f"legal_report_{latest_analysis.id}",
                                "bureau": "Legal Analysis",
                                "round_number": None,
                                "file_path": None,  # Not used - generates on-demand
                                "filename": "Legal_Analysis.pdf",
                                "analysis_id": latest_analysis.id,
                                "report_type": "legal",
                            }
                        )

                contact_letters[contact.id] = letters

            return render_template(
                "contacts.html",
                contacts=contacts,
                contact_letters=contact_letters,
                filter=filter_type,
                page=1,
                total_pages=1,
                total_contacts=len(contacts),
                rows_per_page=25,
            )

        total_contacts = query.count()

        if rows_per_page == "all":
            contacts = query.order_by(Client.created_at.desc()).all()
            total_pages = 1
            rows_per_page_int = total_contacts
        else:
            rows_per_page_int = int(rows_per_page)
            total_pages = max(
                1, (total_contacts + rows_per_page_int - 1) // rows_per_page_int
            )
            offset = (page - 1) * rows_per_page_int
            contacts = (
                query.order_by(Client.created_at.desc())
                .offset(offset)
                .limit(rows_per_page_int)
                .all()
            )

        # Get dispute letters for each contact
        import glob
        import os

        contact_letters = {}
        for contact in contacts:
            # Get all analyses ordered by most recent first
            analyses = (
                db.query(Analysis)
                .filter_by(client_id=contact.id)
                .order_by(Analysis.created_at.desc())
                .all()
            )
            letters = []

            # Collect dispute letters from ALL analyses
            for analysis in analyses:
                dispute_letters = (
                    db.query(DisputeLetter).filter_by(analysis_id=analysis.id).all()
                )
                for letter in dispute_letters:
                    if letter.file_path:
                        filename = (
                            letter.file_path.split("/")[-1]
                            if "/" in letter.file_path
                            else letter.file_path
                        )
                        letters.append(
                            {
                                "id": letter.id,
                                "bureau": letter.bureau,
                                "round_number": letter.round_number,
                                "file_path": letter.file_path,
                                "filename": filename,
                            }
                        )

            # Add Client/Legal reports ONCE from most recent analysis only (no duplicates)
            if analyses:
                latest_analysis = analyses[0]  # Most recent analysis
                violations = (
                    db.query(Violation)
                    .filter_by(analysis_id=latest_analysis.id)
                    .first()
                )
                if violations:
                    # Add Client Report option (generates on-demand)
                    letters.append(
                        {
                            "id": f"client_report_{latest_analysis.id}",
                            "bureau": "Client Report",
                            "round_number": None,
                            "file_path": None,  # Not used - generates on-demand
                            "filename": "Client_Report.pdf",
                            "analysis_id": latest_analysis.id,
                            "report_type": "client",
                        }
                    )

                    # Add Legal Analysis option (generates on-demand)
                    letters.append(
                        {
                            "id": f"legal_report_{latest_analysis.id}",
                            "bureau": "Legal Analysis",
                            "round_number": None,
                            "file_path": None,  # Not used - generates on-demand
                            "filename": "Legal_Analysis.pdf",
                            "analysis_id": latest_analysis.id,
                            "report_type": "legal",
                        }
                    )

            contact_letters[contact.id] = letters

        return render_template(
            "contacts.html",
            contacts=contacts,
            contact_letters=contact_letters,
            filter=filter_type,
            page=page,
            total_pages=total_pages,
            total_contacts=total_contacts,
            rows_per_page=rows_per_page,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return render_template(
            "contacts.html",
            contacts=[],
            contact_letters={},
            filter="all",
            page=1,
            total_pages=1,
            total_contacts=0,
            rows_per_page=25,
        )
    finally:
        db.close()


@app.route("/dashboard/automation-tools")
@require_staff(roles=["admin", "paralegal"])
def dashboard_automation_tools():
    """Automation tools dashboard page"""
    db = get_db()
    try:
        clients = db.query(Client).order_by(Client.first_name).all()
        return render_template(
            "automation_tools.html", clients=clients, active_page="automation-tools"
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return render_template(
            "automation_tools.html", clients=[], active_page="automation-tools"
        )
    finally:
        db.close()


@app.route("/dashboard/automation")
@require_staff(roles=["admin", "paralegal"])
def dashboard_automation_redirect():
    """Redirect old automation URL to automation-tools"""
    return redirect("/dashboard/automation-tools")


@app.route("/dashboard/reports")
@require_staff(roles=["admin", "attorney"])
def dashboard_reports_redirect():
    """Redirect old reports URL to analytics"""
    return redirect("/dashboard/analytics")


@app.route("/dashboard/queue")
@require_staff(roles=["admin", "paralegal"])
def dashboard_queue_redirect():
    """Redirect queue URL to letter-queue"""
    return redirect("/dashboard/letter-queue")


@app.route("/dashboard/cases")
@require_staff(roles=["admin", "attorney", "paralegal"])
def dashboard_cases():
    """Redirect to clients page"""
    return redirect("/dashboard/clients")


@app.route("/api/freeze-letters/generate", methods=["POST"])
def api_generate_freeze_letters():
    """Generate freeze letters for selected bureaus"""
    db = get_db()
    try:
        data = request.json
        client_id = data.get("client_id")
        bureaus = data.get("bureaus", [])

        if not client_id:
            return jsonify({"success": False, "error": "Client ID is required"}), 400
        if not bureaus:
            return (
                jsonify(
                    {"success": False, "error": "At least one bureau must be selected"}
                ),
                400,
            )

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        bureau_name_map = {
            "equifax": "Equifax",
            "experian": "Experian",
            "transunion": "TransUnion",
            "innovis": "Innovis",
            "chexsystems": "ChexSystems",
            "clarity_services": "Clarity Services Inc",
            "lexisnexis": "LexisNexis",
            "corelogic": "CoreLogic Teletrack",
            "factor_trust": "Factor Trust Inc",
            "microbilt": "MicroBilt/PRBC",
            "lexisnexis_risk": "LexisNexis Risk Solutions",
            "datax": "DataX Ltd",
        }

        mapped_bureaus = [bureau_name_map.get(b, b) for b in bureaus]

        from services.freeze_letter_service import generate_freeze_letters

        result = generate_freeze_letters(client_id, mapped_bureaus)

        if result.get("success"):
            return jsonify(
                {
                    "success": True,
                    "batch_id": result.get("batch_id"),
                    "pdf_path": result.get("pdf_path"),
                    "bureaus_count": len(mapped_bureaus),
                }
            )
        else:
            return (
                jsonify(
                    {"success": False, "error": result.get("error", "Unknown error")}
                ),
                400,
            )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/freeze-letters/recent", methods=["GET"])
def api_get_recent_freeze_letters():
    """Get recent freeze letter batches"""
    db = get_db()
    try:
        from database import FreezeLetterBatch

        batches = (
            db.query(FreezeLetterBatch)
            .order_by(FreezeLetterBatch.created_at.desc())
            .limit(20)
            .all()
        )

        result = []
        for batch in batches:
            client = db.query(Client).filter_by(id=batch.client_id).first()
            result.append(
                {
                    "id": batch.batch_uuid,
                    "client_name": (
                        client.name if client else f"Client {batch.client_id}"
                    ),
                    "created_at": (
                        batch.created_at.isoformat() if batch.created_at else None
                    ),
                    "bureaus": batch.bureaus_included or [],
                    "status": batch.status or "generated",
                }
            )

        return jsonify({"success": True, "batches": result})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": True, "batches": []})
    finally:
        db.close()


@app.route("/api/freeze-letters/download/<batch_id>")
def api_download_freeze_letters(batch_id):
    """Download freeze letters PDF or DOCX"""
    db = get_db()
    try:
        from database import FreezeLetterBatch

        batch = db.query(FreezeLetterBatch).filter_by(batch_uuid=batch_id).first()

        if not batch:
            return jsonify({"success": False, "error": "Batch not found"}), 404

        file_format = request.args.get("format", "pdf").lower()

        if file_format == "docx":
            if batch.generated_docx_path and os.path.exists(batch.generated_docx_path):
                return send_file(batch.generated_docx_path, as_attachment=True)
            elif batch.generated_pdf_path:
                docx_path = batch.generated_pdf_path.replace(".pdf", ".docx")
                if os.path.exists(docx_path):
                    return send_file(docx_path, as_attachment=True)
            return jsonify({"success": False, "error": "Word document not found"}), 404
        else:
            if batch.generated_pdf_path and os.path.exists(batch.generated_pdf_path):
                return send_file(batch.generated_pdf_path, as_attachment=True)
            return jsonify({"success": False, "error": "PDF not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================================
# PII CORRECTION LETTERS API
# ============================================================================


@app.route("/api/pii-correction/generate", methods=["POST"])
def api_generate_pii_correction():
    """
    Generate PII correction letters for the Big 3 CRAs.

    Request body:
    {
        "client_id": 123,
        "bureaus": ["Equifax", "Experian", "TransUnion"],  // optional, defaults to all 3
        "incorrect_pii": {
            "names": ["JOHN DOE JR", "J DOE"],
            "addresses": ["123 OLD ST, OLDTOWN, CA 90000"],
            "phones": ["555-123-4567"],
            "employers": ["OLD COMPANY INC"]
        },
        "correct_pii": {  // optional, uses client data if not provided
            "name": "John Doe",
            "address": "456 New St, Newtown, CA 90001",
            "phone": "555-987-6543",
            "employer": "Current Company LLC"
        },
        "case_number": "PII-20260103-1234"  // optional
    }
    """
    db = get_db()
    try:
        data = request.json
        client_id = data.get("client_id")
        bureaus = data.get("bureaus")
        incorrect_pii = data.get("incorrect_pii", {})
        correct_pii = data.get("correct_pii")
        case_number = data.get("case_number")

        if not client_id:
            return jsonify({"success": False, "error": "Client ID is required"}), 400

        if not incorrect_pii:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "incorrect_pii is required - specify what PII to correct",
                    }
                ),
                400,
            )

        # Validate at least one incorrect item
        has_items = any(
            incorrect_pii.get(key)
            for key in ["names", "addresses", "phones", "employers", "ssn_variations"]
        )
        if not has_items:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "incorrect_pii must contain at least one item (names, addresses, phones, employers, or ssn_variations)",
                    }
                ),
                400,
            )

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        from services.pii_correction_service import generate_pii_correction_letters

        result = generate_pii_correction_letters(
            client_id=client_id,
            incorrect_pii=incorrect_pii,
            correct_pii=correct_pii,
            bureaus=bureaus,
            case_number=case_number,
        )

        if result.get("success"):
            return jsonify(
                {
                    "success": True,
                    "batch_id": result.get("batch_id"),
                    "pdf_path": result.get("pdf_path"),
                    "docx_path": result.get("docx_path"),
                    "bureaus_included": result.get("bureaus_included"),
                    "total_letters": result.get("total_letters"),
                }
            )
        else:
            return (
                jsonify(
                    {"success": False, "error": result.get("error", "Unknown error")}
                ),
                400,
            )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/pii-correction/download/<path:file_path>")
def api_download_pii_correction(file_path):
    """Download PII correction letters PDF or DOCX"""
    try:
        # Security: ensure path is within expected directory
        if not file_path.startswith("static/client_uploads/"):
            file_path = f"static/client_uploads/{file_path}"

        if not os.path.exists(file_path):
            return jsonify({"success": False, "error": "File not found"}), 404

        return send_file(file_path, as_attachment=True)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/clients/<int:client_id>/pii-correction", methods=["POST"])
def api_client_pii_correction(client_id):
    """
    Generate PII correction letters for a specific client.
    Convenience endpoint that takes client_id from URL.
    """
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        data = request.json or {}
        incorrect_pii = data.get("incorrect_pii", {})
        correct_pii = data.get("correct_pii")
        bureaus = data.get("bureaus")
        case_number = data.get("case_number")

        if not incorrect_pii:
            return (
                jsonify({"success": False, "error": "incorrect_pii is required"}),
                400,
            )

        from services.pii_correction_service import generate_pii_correction_letters

        result = generate_pii_correction_letters(
            client_id=client_id,
            incorrect_pii=incorrect_pii,
            correct_pii=correct_pii,
            bureaus=bureaus,
            case_number=case_number,
        )

        if result.get("success"):
            return jsonify(
                {
                    "success": True,
                    "batch_id": result.get("batch_id"),
                    "pdf_path": result.get("pdf_path"),
                    "docx_path": result.get("docx_path"),
                    "bureaus_included": result.get("bureaus_included"),
                    "total_letters": result.get("total_letters"),
                }
            )
        else:
            return (
                jsonify(
                    {"success": False, "error": result.get("error", "Unknown error")}
                ),
                400,
            )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/action-plan/generate/<int:client_id>", methods=["POST"])
def api_generate_action_plan(client_id):
    """Generate a branded Action Plan PDF for a client"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        data = request.json or {}

        from datetime import datetime, timedelta

        from services.pdf.brightpath_builder import create_action_plan_pdf

        client_name = (
            client.name or f"{client.first_name or ''} {client.last_name or ''}".strip()
        )

        case = db.query(Case).filter_by(client_id=client_id).first()

        hearing_date = data.get(
            "hearing_date", (datetime.now() + timedelta(days=21)).strftime("%B %d, %Y")
        )
        fcra_value = "$56,000 - $76,000 (estimated)"
        if case and case.total_potential_damages:
            low = int(case.total_potential_damages * 0.8)
            high = int(case.total_potential_damages * 1.2)
            fcra_value = f"${low:,} - ${high:,} (estimated)"

        case_info = {
            "plaintiff": data.get("plaintiff", "N/A"),
            "defendant": client_name,
            "amount": data.get("amount_claimed", "N/A"),
            "court": data.get("court", "N/A"),
            "case_number": data.get("case_number", ""),
            "hearing_date": hearing_date,
            "fcra_value": fcra_value,
        }

        critical_deadline = data.get("critical_deadline")
        deadlines = (
            [f"CRITICAL DEADLINE: {critical_deadline}"] if critical_deadline else []
        )

        base_date = datetime.now()
        week1_tasks = data.get(
            "week1_tasks",
            [
                {
                    "text": "File Notice of Intent to Defend at courthouse",
                    "checked": False,
                    "date": (base_date + timedelta(days=2)).strftime("%b %d"),
                },
                {
                    "text": "Mail Demand Letter to Plaintiff's attorneys (certified)",
                    "checked": False,
                    "date": (base_date + timedelta(days=2)).strftime("%b %d"),
                },
                {
                    "text": "Mail MOV Demand (certified)",
                    "checked": False,
                    "date": (base_date + timedelta(days=2)).strftime("%b %d"),
                },
                {
                    "text": "Organize all credit reports and documents",
                    "checked": False,
                    "date": (base_date + timedelta(days=3)).strftime("%b %d"),
                },
                {
                    "text": "Review and prepare Answer with Affirmative Defenses",
                    "checked": False,
                    "date": (base_date + timedelta(days=4)).strftime("%b %d"),
                },
            ],
        )

        week2_tasks = data.get(
            "week2_tasks",
            [
                {
                    "text": "File Answer with Affirmative Defenses at courthouse",
                    "checked": False,
                    "date": (base_date + timedelta(days=7)).strftime("%b %d"),
                },
                {
                    "text": "Prepare evidence binder (organized by violation)",
                    "checked": False,
                    "date": (base_date + timedelta(days=8)).strftime("%b %d"),
                },
                {
                    "text": "Practice presenting your case (5-10 minutes)",
                    "checked": False,
                    "date": (base_date + timedelta(days=8)).strftime("%b %d"),
                },
                {
                    "text": "Review questions to ask at hearing",
                    "checked": False,
                    "date": (base_date + timedelta(days=9)).strftime("%b %d"),
                },
                {
                    "text": "Confirm hearing time and location",
                    "checked": False,
                    "date": (base_date + timedelta(days=9)).strftime("%b %d"),
                },
            ],
        )

        hearing_tasks = data.get(
            "hearing_tasks",
            [
                {"text": "Arrive 30 minutes early", "checked": False},
                {"text": "Bring evidence binder and all documents", "checked": False},
                {
                    "text": "Dress professionally (business casual minimum)",
                    "checked": False,
                },
                {
                    "text": "Turn off cell phone before entering courtroom",
                    "checked": False,
                },
                {"text": "Address judge as 'Your Honor'", "checked": False},
            ],
        )

        what_to_bring = data.get(
            "what_to_bring",
            [
                "All 3 credit reports (Experian, TransUnion, Equifax)",
                "Notice of Intent to Defend (filed copy)",
                "Answer with Affirmative Defenses (filed copy)",
                "Demand Letter to attorneys (copy + certified mail receipt)",
                "MOV Demand (copy + certified mail receipt)",
                "Any responses received",
                "Government-issued photo ID",
                "Pen and notepad for notes",
            ],
        )

        costs = data.get(
            "costs",
            [
                ("Filing Notice of Intent to Defend", "$0 - $25"),
                ("Certified Mail (Demand Letter)", "$8 - $12"),
                ("Certified Mail (MOV Demand)", "$8 - $12"),
                ("Filing Answer", "$0 - $25"),
                ("TOTAL ESTIMATED", "$16 - $74"),
            ],
        )

        output_dir = "generated_documents/action_plans"
        os.makedirs(output_dir, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        client_name_safe = client_name.replace(" ", "_").replace("/", "_")[:50]
        output_path = os.path.join(
            output_dir, f"{client_name_safe}_Action_Plan_{timestamp}.pdf"
        )

        pdf_path = create_action_plan_pdf(
            client_name=client_name,
            case_info=case_info,
            deadlines=deadlines,
            week1_tasks=week1_tasks,
            week2_tasks=week2_tasks,
            hearing_tasks=hearing_tasks,
            what_to_bring=what_to_bring,
            costs=costs,
            output_path=output_path,
        )

        return jsonify(
            {
                "success": True,
                "pdf_path": pdf_path,
                "message": f"Action Plan generated for {client_name}",
            }
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/action-plan/download/<path:filename>")
def api_download_action_plan(filename):
    """Download an action plan PDF"""
    try:
        filepath = os.path.join(
            "generated_documents/action_plans", os.path.basename(filename)
        )
        if os.path.exists(filepath):
            return send_file(filepath, as_attachment=True)
        return jsonify({"success": False, "error": "File not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/scanner")
def scanner_page():
    """Mobile document scanner page"""
    return render_template("document_scanner.html")


@app.route("/portal/<token>/scanner")
def portal_scanner(token):
    """Client portal scanner - automatically links documents to client"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(portal_token=token).first()
        if not client:
            case = db.query(Case).filter_by(portal_token=token).first()
            if case:
                client = db.query(Client).filter_by(id=case.client_id).first()

        if not client:
            return "Invalid or expired access link", 404

        return render_template(
            "document_scanner.html",
            client_id=client.id,
            client_name=client.name,
            portal_token=token,
            is_portal=True,
        )
    finally:
        db.close()


@app.route("/api/scanner/document-types", methods=["GET"])
def api_get_document_types():
    """Get supported document types for scanning"""
    from services.document_scanner_service import get_document_types

    return jsonify({"success": True, "document_types": get_document_types()})


@app.route("/api/scanner/session/start", methods=["POST"])
def api_start_scan_session():
    """Start a new document scanning session"""
    from services.document_scanner_service import create_scan_session

    data = request.json or {}
    result = create_scan_session(
        client_id=data.get("client_id"),
        client_name=data.get("client_name"),
        document_type=data.get("document_type", "credit_report"),
    )
    return jsonify(result)


@app.route("/api/scanner/session/add-image", methods=["POST"])
def api_add_scan_image():
    """Add an image to an existing scan session"""
    from services.document_scanner_service import get_scan_session

    session_id = request.form.get("session_id")
    if not session_id:
        return jsonify({"success": False, "error": "session_id required"}), 400

    session = get_scan_session(session_id)
    if not session:
        return jsonify({"success": False, "error": "Session not found"}), 404

    if "image" not in request.files:
        return jsonify({"success": False, "error": "No image provided"}), 400

    image_file = request.files["image"]
    image_data = image_file.read()
    filename = image_file.filename or "upload.jpg"

    result = session.add_image(image_data, filename)
    return jsonify(result)


@app.route("/api/scanner/session/remove-image", methods=["POST"])
def api_remove_scan_image():
    """Remove an image from a scan session"""
    from services.document_scanner_service import get_scan_session

    data = request.json or {}
    session_id = data.get("session_id")
    page_number = data.get("page_number")

    if not session_id or not page_number:
        return (
            jsonify({"success": False, "error": "session_id and page_number required"}),
            400,
        )

    session = get_scan_session(session_id)
    if not session:
        return jsonify({"success": False, "error": "Session not found"}), 404

    success = session.remove_image(page_number)
    return jsonify({"success": success})


@app.route("/api/scanner/session/status", methods=["GET"])
def api_scan_session_status():
    """Get status of a scan session"""
    from services.document_scanner_service import get_scan_session

    session_id = request.args.get("session_id")
    if not session_id:
        return jsonify({"success": False, "error": "session_id required"}), 400

    session = get_scan_session(session_id)
    if not session:
        return jsonify({"success": False, "error": "Session not found"}), 404

    return jsonify({"success": True, **session.get_status()})


@app.route("/api/scanner/session/finalize", methods=["POST"])
def api_finalize_scan_session():
    """Finalize scan session - create PDF and run OCR"""
    from services.document_scanner_service import get_scan_session

    data = request.json or {}
    session_id = data.get("session_id")
    run_ocr = data.get("run_ocr", True)

    if not session_id:
        return jsonify({"success": False, "error": "session_id required"}), 400

    session = get_scan_session(session_id)
    if not session:
        return jsonify({"success": False, "error": "Session not found"}), 404

    result = session.finalize(run_ocr=run_ocr)
    return jsonify(result)


@app.route("/api/scanner/session/cancel", methods=["POST"])
def api_cancel_scan_session():
    """Cancel a scan session and cleanup"""
    from services.document_scanner_service import get_scan_session, scan_sessions

    data = request.json or {}
    session_id = data.get("session_id")

    if not session_id:
        return jsonify({"success": False, "error": "session_id required"}), 400

    session = get_scan_session(session_id)
    if not session:
        return jsonify({"success": False, "error": "Session not found"}), 404

    removed = session.cancel()
    if session_id in scan_sessions:
        del scan_sessions[session_id]

    return jsonify({"success": True, "images_removed": removed})


@app.route("/api/scanner/download")
def api_download_scanned_file():
    """Download a scanned PDF or text file"""
    filepath = request.args.get("path")
    if not filepath:
        return jsonify({"success": False, "error": "path required"}), 400

    allowed_dirs = ["generated_documents/scanned_pdfs", "uploads/scans"]
    is_allowed = any(allowed_dir in filepath for allowed_dir in allowed_dirs)

    if not is_allowed:
        return jsonify({"success": False, "error": "Invalid path"}), 403

    if os.path.exists(filepath):
        return send_file(filepath, as_attachment=True)
    return jsonify({"success": False, "error": "File not found"}), 404


@app.route("/api/scanner/scanned-documents", methods=["GET"])
def api_list_scanned_documents():
    """List all scanned documents in the output folder"""
    import glob
    from datetime import datetime

    scan_folder = "generated_documents/scanned_pdfs"
    documents = []

    pdf_files = glob.glob(os.path.join(scan_folder, "*.pdf"))

    for pdf_path in sorted(pdf_files, key=os.path.getmtime, reverse=True):
        filename = os.path.basename(pdf_path)
        text_path = pdf_path.replace(".pdf", "_text.txt")

        parts = filename.replace(".pdf", "").split("_")
        client_name = parts[0] if parts else "Unknown"
        doc_type = parts[1] if len(parts) > 1 else "unknown"

        doc_type_labels = {
            "cra-response-r1": "CRA Response R1",
            "cra-response-r2": "CRA Response R2",
            "cra-response-r3": "CRA Response R3",
            "cra-response-r4": "CRA Response R4",
            "cra-response": "CRA Response",
            "collection-letter": "Collection Letter",
            "creditor-response": "Creditor Response",
            "court-document": "Court Document",
            "id-document": "ID Document",
            "proof-of-address": "Proof of Address",
            "other": "Other",
        }

        stat = os.stat(pdf_path)

        text_preview = ""
        word_count = 0
        if os.path.exists(text_path):
            with open(text_path, "r", encoding="utf-8") as f:
                full_text = f.read()
                word_count = len(full_text.split())
                text_preview = full_text[:500] + ("..." if len(full_text) > 500 else "")

        documents.append(
            {
                "filename": filename,
                "pdf_path": pdf_path,
                "text_path": text_path if os.path.exists(text_path) else None,
                "client_name": client_name,
                "document_type": doc_type_labels.get(
                    doc_type, doc_type.replace("-", " ").title()
                ),
                "document_type_key": doc_type,
                "file_size": stat.st_size,
                "file_size_formatted": f"{stat.st_size / 1024:.1f} KB",
                "created_at": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                "created_at_formatted": datetime.fromtimestamp(stat.st_mtime).strftime(
                    "%b %d, %Y %I:%M %p"
                ),
                "word_count": word_count,
                "text_preview": text_preview,
            }
        )

    return jsonify({"success": True, "count": len(documents), "documents": documents})


@app.route("/dashboard/scanned-documents")
@require_staff(roles=["admin", "paralegal", "attorney"])
def dashboard_scanned_documents():
    """Admin view of scanned documents"""
    return render_template("scanned_documents.html")


@app.route("/api/deadlines/upcoming", methods=["GET"])
def api_get_upcoming_deadlines():
    """Get upcoming deadlines with urgency indicators"""
    db = get_db()
    try:
        from services.deadline_service import get_upcoming_deadlines

        deadlines = get_upcoming_deadlines(db, days_ahead=90, include_overdue=True)

        formatted = []
        for d in deadlines:
            formatted.append(
                {
                    "id": d["id"],
                    "client_name": d.get("client_name", "Unknown"),
                    "type": d.get(
                        "deadline_type_name", d.get("deadline_type", "Unknown")
                    ),
                    "bureau": d.get("bureau"),
                    "due_date": (
                        d["deadline_date"].isoformat()
                        if hasattr(d["deadline_date"], "isoformat")
                        else str(d["deadline_date"])
                    ),
                    "days_left": d.get("days_remaining", 0),
                    "status": d.get("status", "active"),
                }
            )

        return jsonify({"success": True, "deadlines": formatted})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": True, "deadlines": []})
    finally:
        db.close()


@app.route("/api/deadlines/<int:deadline_id>/complete", methods=["POST"])
def api_complete_deadline(deadline_id):
    """Mark a deadline as complete"""
    db = get_db()
    try:
        from services.deadline_service import complete_deadline

        result = complete_deadline(db, deadline_id)
        return jsonify({"success": result is not None})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/deadlines/<int:deadline_id>/extend", methods=["POST"])
def api_extend_deadline(deadline_id):
    """Extend a deadline by specified days"""
    db = get_db()
    try:
        data = request.json
        extra_days = data.get("days", 15)

        from database import CaseDeadline
        from services.deadline_service import extend_deadline

        deadline = db.query(CaseDeadline).filter_by(id=deadline_id).first()
        if deadline:
            new_total_days = deadline.days_allowed + extra_days
            result = extend_deadline(db, deadline_id, new_total_days)
            return jsonify({"success": result is not None})
        return jsonify({"success": False, "error": "Deadline not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlement/calculate", methods=["POST"])
def api_calculate_settlement():
    """Calculate settlement value based on violations and damages"""
    try:
        data = request.json

        total_violations = data.get("total_violations", 0)
        willful_violations = data.get("willful_violations", 0)
        negligent_violations = data.get("negligent_violations", 0)
        actual_damages = data.get("actual_damages", [])

        statutory_min = willful_violations * 100
        statutory_max = willful_violations * 1000

        actual_total = sum(float(d.get("amount", 0)) for d in actual_damages)

        punitive_min = statutory_min * 1.0
        punitive_max = statutory_max * 3.0

        total_min = statutory_min + actual_total + punitive_min
        total_max = statutory_max + actual_total + punitive_max

        attorney_fees = (total_min + total_max) / 2 * 0.35

        if willful_violations > 3 and total_max > 10000:
            likelihood = "High"
        elif total_max > 5000:
            likelihood = "Medium"
        else:
            likelihood = "Low"

        recommended_demand = ((total_min + total_max) / 2) * 2.5

        return jsonify(
            {
                "success": True,
                "statutory_min": statutory_min,
                "statutory_max": statutory_max,
                "punitive_min": punitive_min,
                "punitive_max": punitive_max,
                "actual_damages_total": actual_total,
                "attorney_fees": attorney_fees,
                "total_min": total_min,
                "total_max": total_max,
                "likelihood": likelihood,
                "recommended_demand": recommended_demand,
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/clients")
def api_get_all_clients():
    """Get all clients for credit tracker"""
    db = get_db()
    try:
        clients = db.query(Client).order_by(Client.name).all()
        return jsonify(
            {
                "success": True,
                "clients": [
                    {"id": c.id, "name": c.name, "email": c.email, "status": c.status}
                    for c in clients
                ],
            }
        )
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/details", methods=["GET"])
def api_get_client_details(client_id):
    """Get full client details including documents for modal"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        documents = db.query(ClientDocument).filter_by(client_id=client_id).all()

        client_data = {
            "id": client.id,
            "first_name": client.first_name,
            "last_name": client.last_name,
            "name": client.name,
            "email": client.email,
            "phone": client.phone,
            "phone_2": getattr(client, "phone_2", None),
            "mobile": getattr(client, "mobile", None),
            "company": getattr(client, "company", None),
            "website": getattr(client, "website", None),
            "address_street": client.address_street,
            "address_city": client.address_city,
            "address_state": client.address_state,
            "address_zip": client.address_zip,
            "client_type": getattr(client, "client_type", "L"),
            "status_2": getattr(client, "status_2", None),
            "is_affiliate": getattr(client, "is_affiliate", False),
            "follow_up_date": (
                client.follow_up_date.isoformat()
                if hasattr(client, "follow_up_date") and client.follow_up_date
                else None
            ),
            "groups": getattr(client, "groups", None),
            "mark_1": getattr(client, "mark_1", False),
            "mark_2": getattr(client, "mark_2", False),
            "created_at": (
                client.created_at.strftime("%Y-%m-%d %H:%M")
                if client.created_at
                else None
            ),
            "updated_at": (
                client.updated_at.strftime("%Y-%m-%d %H:%M")
                if client.updated_at
                else None
            ),
        }

        docs_data = [
            {
                "document_type": doc.document_type,
                "received": doc.received,
                "received_at": (
                    doc.received_at.strftime("%Y-%m-%d") if doc.received_at else None
                ),
            }
            for doc in documents
        ]

        return jsonify({"success": True, "client": client_data, "documents": docs_data})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/status", methods=["POST"])
def api_update_client_status(client_id):
    """Update client status and fields"""
    db = get_db()
    try:
        # Sanitize all input data
        data = sanitize_dict(
            request.json or {},
            {
                "email": "email",
                "phone": "phone",
                "phone_2": "phone",
                "mobile": "phone",
                "address_zip": "zip",
                "address_state": "state",
            },
        )
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        updateable_fields = [
            "client_type",
            "status_2",
            "company",
            "phone_2",
            "mobile",
            "website",
            "is_affiliate",
            "follow_up_date",
            "groups",
            "mark_1",
            "mark_2",
            "first_name",
            "last_name",
            "email",
            "phone",
            "address_street",
            "address_city",
            "address_state",
            "address_zip",
        ]

        for field in updateable_fields:
            if field in data:
                value = data[field]
                if field == "follow_up_date" and value:
                    from datetime import date as date_type

                    if isinstance(value, str):
                        value = datetime.strptime(value, "%Y-%m-%d").date()
                setattr(client, field, value)

        client.updated_at = datetime.utcnow()
        db.commit()

        return jsonify({"success": True, "message": "Client updated"})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/create", methods=["POST"])
@validate_request_data(
    required_fields=[],  # Email now optional for import
    field_rules={
        "email": "email",
        "phone": "phone",
        "address_zip": "zip",
        "address_state": "state",
    },
)
def api_create_client():
    """Create a new client"""
    db = get_db()
    try:
        data = request.validated_data  # Use sanitized data

        first_name = data.get("first_name", "")
        last_name = data.get("last_name", "")
        name = f"{first_name} {last_name}".strip() or data.get("email", "Unknown")

        client = Client(
            name=name,
            first_name=first_name,
            last_name=last_name,
            email=data.get("email", ""),
            phone=data.get("phone", ""),
            address_street=data.get("address_street", ""),
            address_city=data.get("address_city", ""),
            address_state=data.get("address_state", ""),
            address_zip=data.get("address_zip", ""),
            portal_token=secrets.token_urlsafe(32),
        )

        for field in [
            "client_type",
            "status_2",
            "company",
            "phone_2",
            "mobile",
            "website",
            "is_affiliate",
            "groups",
            "ssn_last_four",
            "ssn_encrypted",
        ]:
            if field in data and data[field]:
                setattr(client, field, data[field])

        # Handle date_of_birth separately (needs parsing)
        if data.get("date_of_birth"):
            try:
                if isinstance(data["date_of_birth"], str):
                    client.date_of_birth = datetime.strptime(
                        data["date_of_birth"], "%Y-%m-%d"
                    ).date()
                else:
                    client.date_of_birth = data["date_of_birth"]
            except:
                pass  # Skip invalid date

        if data.get("follow_up_date"):
            client.follow_up_date = datetime.strptime(
                data["follow_up_date"], "%Y-%m-%d"
            ).date()

        db.add(client)
        db.commit()

        # Audit log: Client created
        log_audit(
            "CLIENT_CREATED",
            user_id=session.get("staff_id"),
            client_id=client.id,
            details={"name": client.name, "email": client.email},
        )
        log_client_created(client.id, client.name, user=session.get("staff_email"))

        try:
            WorkflowTriggersService.evaluate_triggers(
                "case_created",
                {
                    "client_id": client.id,
                    "client_name": client.name,
                    "email": client.email,
                    "phone": client.phone,
                    "plan": "manual",
                },
            )
        except Exception as wf_error:
            app_logger.warning(f"Workflow trigger error (non-fatal): {wf_error}")

        return jsonify({"success": True, "client_id": client.id})
    except Exception as e:
        db.rollback()
        log_error(e, context={"action": "create_client"})
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/delete", methods=["POST"])
@require_staff()
def api_delete_client(client_id):
    """Delete a client and all related data (GDPR/CCPA compliant full deletion)"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Log the deletion for audit trail
        log_audit(
            "client_delete_initiated",
            {
                "client_id": client_id,
                "client_name": client.name,
                "client_email": client.email,
            },
        )

        # Import all models needed for comprehensive deletion
        from database import (
            AnalysisQueue,
            AttorneyReferral,
            AutomationMetrics,
            BackgroundTask,
            BatchJobItem,
            Booking,
            BulkCampaignRecipient,
            BureauDisputeTracking,
            CaseEvent,
            CaseOutcome,
            CaseScore,
            CaseTriage,
            CertifiedMailingRecord,
            CertifiedMailOrder,
            CFPBComplaint,
            ChatConversation,
            ChatMessage,
            ChexSystemsDispute,
            ClientBadge,
            ClientDocumentSignature,
            ClientLifetimeValue,
            ClientMessage,
            ClientSubscription,
            ClientSuccessMetric,
            ClientTestimonial,
            Commission,
            CRAResponse,
            CRAResponseOCR,
            CreditPullLog,
            CreditPullRequest,
            CROAComplianceTracker,
            CROAProgress,
            Damages,
            DisputeItem,
            Document,
            DripEnrollment,
            EscalationRecommendation,
            ESignatureRequest,
            FreezeLetterBatch,
            FrivolousDefense,
            GeneratedLetter,
            IntegrationEvent,
            InterOrgTransfer,
            Invoice,
            InvoiceItem,
            InvoicePayment,
            LimitedPOA,
            Metro2DisputeLog,
            MortgagePaymentLedger,
            NotarizationOrder,
            NotarizeTransaction,
            OnboardingProgress,
            OutcomePrediction,
            PatternInstance,
            PaymentPlan,
            PaymentPlanInstallment,
            PaymentPlanPayment,
            PushSubscription,
            ROICalculation,
            ScoreScenario,
            SecondaryBureauFreeze,
            SettlementEstimate,
            SignatureAuditLog,
            SignatureSession,
            SignedDocument,
            SpecialtyBureauDispute,
            StaffActivity,
            Standing,
            SuspenseAccountFinding,
            TimelineEvent,
            TradelineStatus,
            Violation,
            VoicemailDrop,
            WhatsAppMessage,
            WorkflowExecution,
        )

        # === PHASE 1: Delete tables that reference other tables (deepest children first) ===
        # Payment plan sub-tables (reference PaymentPlan)
        plan_ids = [
            p.id for p in db.query(PaymentPlan).filter_by(client_id=client_id).all()
        ]
        if plan_ids:
            db.query(PaymentPlanInstallment).filter(
                PaymentPlanInstallment.plan_id.in_(plan_ids)
            ).delete(synchronize_session=False)
            db.query(PaymentPlanPayment).filter(
                PaymentPlanPayment.plan_id.in_(plan_ids)
            ).delete(synchronize_session=False)

        # Invoice sub-tables (reference Invoice)
        invoice_ids = [
            i.id for i in db.query(Invoice).filter_by(client_id=client_id).all()
        ]
        if invoice_ids:
            db.query(InvoiceItem).filter(
                InvoiceItem.invoice_id.in_(invoice_ids)
            ).delete(synchronize_session=False)
            db.query(InvoicePayment).filter(
                InvoicePayment.invoice_id.in_(invoice_ids)
            ).delete(synchronize_session=False)

        # Get case IDs for cascade deletion
        case_ids = [c.id for c in db.query(Case).filter_by(client_id=client_id).all()]

        # Get analysis IDs for cascade deletion
        analysis_ids = [
            a.id for a in db.query(Analysis).filter_by(client_id=client_id).all()
        ]

        # === PHASE 2: Delete case-related tables ===
        if case_ids:
            db.query(CaseEvent).filter(CaseEvent.case_id.in_(case_ids)).delete(
                synchronize_session=False
            )
            db.query(Settlement).filter(Settlement.case_id.in_(case_ids)).delete(
                synchronize_session=False
            )
            db.query(Document).filter(Document.case_id.in_(case_ids)).delete(
                synchronize_session=False
            )
            db.query(AnalysisQueue).filter(AnalysisQueue.case_id.in_(case_ids)).delete(
                synchronize_session=False
            )

        # === PHASE 3: Delete analysis-related tables ===
        if analysis_ids:
            db.query(Violation).filter(Violation.analysis_id.in_(analysis_ids)).delete(
                synchronize_session=False
            )
            db.query(Damages).filter(Damages.analysis_id.in_(analysis_ids)).delete(
                synchronize_session=False
            )
            db.query(Standing).filter(Standing.analysis_id.in_(analysis_ids)).delete(
                synchronize_session=False
            )
            db.query(CaseScore).filter(CaseScore.analysis_id.in_(analysis_ids)).delete(
                synchronize_session=False
            )
            db.query(DisputeItem).filter(
                DisputeItem.analysis_id.in_(analysis_ids)
            ).delete(synchronize_session=False)
            db.query(CRAResponse).filter(
                CRAResponse.analysis_id.in_(analysis_ids)
            ).delete(synchronize_session=False)

        # CRAResponseOCR uses client_id not analysis_id
        db.query(CRAResponseOCR).filter_by(client_id=client_id).delete()

        # === PHASE 4: Delete all tables with direct client_id foreign key ===

        # E-signatures and documents
        db.query(ClientDocumentSignature).filter_by(client_id=client_id).delete()
        db.query(OnboardingProgress).filter_by(client_id=client_id).delete()
        db.query(SignatureSession).filter_by(client_id=client_id).delete()
        db.query(SignedDocument).filter_by(client_id=client_id).delete()
        db.query(SignatureAuditLog).filter_by(client_id=client_id).delete()
        db.query(ESignatureRequest).filter_by(client_id=client_id).delete()

        # CROA compliance
        db.query(CROAProgress).filter_by(client_id=client_id).delete()
        db.query(CROAComplianceTracker).filter_by(client_id=client_id).delete()

        # Tags
        db.query(ClientTagAssignment).filter_by(client_id=client_id).delete()

        # Uploads and documents
        db.query(ClientUpload).filter_by(client_id=client_id).delete()
        db.query(ClientDocument).filter_by(client_id=client_id).delete()

        # Credit monitoring and scores
        db.query(CreditMonitoringCredential).filter_by(client_id=client_id).delete()
        db.query(CreditScoreSnapshot).filter_by(client_id=client_id).delete()
        db.query(CreditScoreProjection).filter_by(client_id=client_id).delete()
        db.query(ScoreScenario).filter_by(client_id=client_id).delete()
        db.query(CreditPullRequest).filter_by(client_id=client_id).delete()
        db.query(CreditPullLog).filter_by(client_id=client_id).delete()

        # Communications - SMS, Email, WhatsApp
        db.query(SMSLog).filter_by(client_id=client_id).delete()
        db.query(EmailLog).filter_by(client_id=client_id).delete()
        db.query(WhatsAppMessage).filter_by(client_id=client_id).delete()
        db.query(Notification).filter_by(client_id=client_id).delete()
        db.query(ClientMessage).filter_by(client_id=client_id).delete()
        # Delete chat messages before conversations (FK constraint)
        conversation_ids = [
            c.id
            for c in db.query(ChatConversation).filter_by(client_id=client_id).all()
        ]
        if conversation_ids:
            db.query(ChatMessage).filter(
                ChatMessage.conversation_id.in_(conversation_ids)
            ).delete(synchronize_session=False)
        db.query(ChatConversation).filter_by(client_id=client_id).delete()
        db.query(VoicemailDrop).filter_by(client_id=client_id).delete()
        db.query(BulkCampaignRecipient).filter_by(client_id=client_id).delete()
        db.query(PushSubscription).filter_by(client_id=client_id).delete()

        # Drip campaigns
        db.query(DripEnrollment).filter_by(client_id=client_id).delete()

        # Cases and related
        db.query(CaseDeadline).filter_by(client_id=client_id).delete()
        db.query(SettlementEstimate).filter_by(client_id=client_id).delete()
        db.query(CaseTriage).filter_by(client_id=client_id).delete()
        db.query(CaseOutcome).filter_by(client_id=client_id).delete()
        db.query(OutcomePrediction).filter_by(client_id=client_id).delete()
        db.query(Case).filter_by(client_id=client_id).delete()

        # Secondary bureaus and freezes
        db.query(SecondaryBureauFreeze).filter_by(client_id=client_id).delete()
        db.query(FreezeLetterBatch).filter_by(client_id=client_id).delete()

        # Legal and compliance
        db.query(AttorneyReferral).filter_by(client_id=client_id).delete()
        db.query(LimitedPOA).filter_by(client_id=client_id).delete()
        db.query(CFPBComplaint).filter_by(client_id=client_id).delete()
        db.query(EscalationRecommendation).filter_by(client_id=client_id).delete()
        db.query(FrivolousDefense).filter_by(client_id=client_id).delete()

        # Specialty disputes
        db.query(ChexSystemsDispute).filter_by(client_id=client_id).delete()
        db.query(SpecialtyBureauDispute).filter_by(client_id=client_id).delete()
        db.query(Metro2DisputeLog).filter_by(client_id=client_id).delete()
        db.query(BureauDisputeTracking).filter_by(client_id=client_id).delete()

        # Certified mail and notarization
        db.query(CertifiedMailOrder).filter_by(client_id=client_id).delete()
        db.query(CertifiedMailingRecord).filter_by(client_id=client_id).delete()
        db.query(NotarizationOrder).filter_by(client_id=client_id).delete()
        db.query(NotarizeTransaction).filter_by(client_id=client_id).delete()

        # Financial - invoices, subscriptions, payments
        db.query(Invoice).filter_by(client_id=client_id).delete()
        db.query(ClientSubscription).filter_by(client_id=client_id).delete()
        db.query(PaymentPlan).filter_by(client_id=client_id).delete()
        db.query(Commission).filter_by(client_id=client_id).delete()

        # Mortgage and suspense
        db.query(MortgagePaymentLedger).filter_by(client_id=client_id).delete()
        db.query(SuspenseAccountFinding).filter_by(client_id=client_id).delete()

        # Patterns and analytics
        db.query(PatternInstance).filter_by(client_id=client_id).delete()
        db.query(AutomationMetrics).filter_by(client_id=client_id).delete()
        db.query(TradelineStatus).filter_by(client_id=client_id).delete()
        db.query(ClientLifetimeValue).filter_by(client_id=client_id).delete()
        db.query(ClientSuccessMetric).filter_by(client_id=client_id).delete()
        db.query(ROICalculation).filter_by(client_id=client_id).delete()

        # Generated letters
        db.query(GeneratedLetter).filter_by(client_id=client_id).delete()

        # Integrations and workflows
        db.query(IntegrationEvent).filter_by(client_id=client_id).delete()
        db.query(WorkflowExecution).filter_by(client_id=client_id).delete()
        db.query(BackgroundTask).filter_by(client_id=client_id).delete()
        db.query(BatchJobItem).filter_by(client_id=client_id).delete()

        # Bookings and scheduling
        db.query(Booking).filter_by(client_id=client_id).delete()

        # Staff activity
        db.query(StaffActivity).filter_by(client_id=client_id).delete()

        # Multi-tenant
        db.query(InterOrgTransfer).filter_by(client_id=client_id).delete()

        # Client extras
        db.query(ClientTestimonial).filter_by(client_id=client_id).delete()
        db.query(ClientBadge).filter_by(client_id=client_id).delete()

        # Timeline
        db.query(TimelineEvent).filter_by(client_id=client_id).delete()

        # Credit reports and analysis (after all dependent tables)
        db.query(DisputeLetter).filter_by(client_id=client_id).delete()
        db.query(CRAResponse).filter_by(client_id=client_id).delete()
        db.query(CRAResponseOCR).filter_by(client_id=client_id).delete()
        db.query(DisputeItem).filter_by(client_id=client_id).delete()
        db.query(Analysis).filter_by(client_id=client_id).delete()
        db.query(CreditReport).filter_by(client_id=client_id).delete()

        # Tasks and notes
        db.query(Task).filter_by(client_id=client_id).delete()
        db.query(ClientNote).filter_by(client_id=client_id).delete()

        # Referrals (handle both directions)
        db.query(ClientReferral).filter_by(referring_client_id=client_id).delete()
        db.query(ClientReferral).filter_by(referred_client_id=client_id).delete()

        # Finally delete the client
        db.delete(client)
        db.commit()

        log_audit(
            "client_deleted",
            {"client_id": client_id, "tables_cleaned": "all related data removed"},
        )

        return jsonify(
            {"success": True, "message": "Client and all related data deleted"}
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        log_error(e, {"action": "client_delete", "client_id": client_id})
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================================
# ADDRESS VALIDATION (USPS API)
# ============================================================================


@app.route("/api/address/validate", methods=["POST"])
@require_staff()
def api_validate_address():
    """
    Validate and standardize an address using USPS API.
    Returns validated address with any corrections made.
    """
    from services.address_validation_service import validate_client_address

    data = request.json or {}
    street = data.get("street", "")
    street2 = data.get("street2", "")
    city = data.get("city", "")
    state = data.get("state", "")
    zip_code = data.get("zip_code", "")

    if not street or not city or not state:
        return (
            jsonify(
                {"success": False, "error": "Street, city, and state are required"}
            ),
            400,
        )

    is_valid, result = validate_client_address(
        street=street, city=city, state=state, zip_code=zip_code, street2=street2
    )

    return jsonify({"success": True, **result})


@app.route("/api/clients/<int:client_id>/validate-address", methods=["POST"])
@require_staff()
def api_validate_client_address(client_id):
    """
    Validate a client's current address and optionally update it.
    """
    from services.address_validation_service import validate_client_address

    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        data = request.json or {}
        update_address = data.get("update_address", False)

        # Use client's current address
        is_valid, result = validate_client_address(
            street=client.address_street or "",
            city=client.address_city or "",
            state=client.address_state or "",
            zip_code=client.address_zip or "",
            street2="",
        )

        # Update client address if requested and valid
        if update_address and is_valid:
            validated = result["validated_address"]
            client.address_street = validated["street"]
            client.address_city = validated["city"]
            client.address_state = validated["state"]
            client.address_zip = validated["full_zip"]
            client.updated_at = datetime.now()
            db.commit()
            result["address_updated"] = True
        else:
            result["address_updated"] = False

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "client_name": client.name,
                **result,
            }
        )

    except Exception as e:
        db.rollback()
        log_error(e, {"action": "validate_client_address", "client_id": client_id})
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/bulk-validate-addresses", methods=["POST"])
@require_staff()
def api_bulk_validate_addresses():
    """
    Validate addresses for multiple clients.
    Returns list of clients with invalid/correctable addresses.
    """
    from services.address_validation_service import validate_client_address

    db = get_db()
    try:
        data = request.json or {}
        client_ids = data.get("client_ids", [])

        # If no IDs specified, check all clients with addresses
        if not client_ids:
            clients = (
                db.query(Client)
                .filter(Client.address_street.isnot(None), Client.address_street != "")
                .all()
            )
        else:
            clients = db.query(Client).filter(Client.id.in_(client_ids)).all()

        results = {"valid": [], "invalid": [], "correctable": [], "no_address": []}

        for client in clients:
            if not client.address_street:
                results["no_address"].append(
                    {"client_id": client.id, "name": client.name}
                )
                continue

            is_valid, result = validate_client_address(
                street=client.address_street or "",
                city=client.address_city or "",
                state=client.address_state or "",
                zip_code=client.address_zip or "",
                street2="",
            )

            client_info = {
                "client_id": client.id,
                "name": client.name,
                "original_address": result["original_address"],
                "validated_address": result["validated_address"],
                "corrections": result["corrections"],
                "error_message": result["error_message"],
            }

            if not is_valid:
                results["invalid"].append(client_info)
            elif result["was_corrected"]:
                results["correctable"].append(client_info)
            else:
                results["valid"].append(client_info)

        return jsonify(
            {
                "success": True,
                "total_checked": len(clients),
                "summary": {
                    "valid": len(results["valid"]),
                    "invalid": len(results["invalid"]),
                    "correctable": len(results["correctable"]),
                    "no_address": len(results["no_address"]),
                },
                "results": results,
            }
        )

    except Exception as e:
        log_error(e, {"action": "bulk_validate_addresses"})
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/bulk-apply-address-corrections", methods=["POST"])
@require_staff()
def api_bulk_apply_address_corrections():
    """Apply USPS-validated address corrections to clients"""
    db = get_db()
    try:
        data = request.json
        corrections = data.get("corrections", [])

        if not corrections:
            return jsonify({"success": False, "error": "No corrections provided"}), 400

        applied = 0
        failed = 0
        results = []

        for correction in corrections:
            client_id = correction.get("client_id")
            validated = correction.get("validated_address", {})

            if not client_id or not validated:
                failed += 1
                results.append(
                    {
                        "client_id": client_id,
                        "status": "skipped",
                        "reason": "Missing data",
                    }
                )
                continue

            client = db.query(Client).filter_by(id=client_id).first()
            if not client:
                failed += 1
                results.append(
                    {
                        "client_id": client_id,
                        "status": "skipped",
                        "reason": "Client not found",
                    }
                )
                continue

            # Store original for logging
            original = {
                "street": client.address_street,
                "city": client.address_city,
                "state": client.address_state,
                "zip": client.address_zip,
            }

            # Apply corrections
            client.address_street = validated.get("street", client.address_street)
            client.address_city = validated.get("city", client.address_city)
            client.address_state = validated.get("state", client.address_state)

            # Build full ZIP with +4 if available
            zip5 = validated.get("zip5", "")
            zip4 = validated.get("zip4", "")
            if zip5:
                client.address_zip = f"{zip5}-{zip4}" if zip4 else zip5

            # Mark as verified
            try:
                client.address_verified = True
                client.address_verified_at = datetime.now()
            except Exception:
                pass  # Column might not exist

            client.updated_at = datetime.now()
            applied += 1

            results.append(
                {
                    "client_id": client_id,
                    "name": f"{client.first_name} {client.last_name}",
                    "status": "applied",
                    "original": original,
                    "corrected": {
                        "street": client.address_street,
                        "city": client.address_city,
                        "state": client.address_state,
                        "zip": client.address_zip,
                    },
                }
            )

        db.commit()

        return jsonify(
            {
                "success": True,
                "applied": applied,
                "failed": failed,
                "total": len(corrections),
                "results": results,
            }
        )

    except Exception as e:
        db.rollback()
        log_error(e, {"action": "bulk_apply_address_corrections"})
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/standardize-addresses-offline", methods=["POST"])
@require_staff()
def api_standardize_addresses_offline():
    """
    Apply basic address standardization without USPS API.
    Fixes: proper casing, state uppercase, common abbreviations.
    Use when USPS rate limit is hit.
    """
    db = get_db()
    try:
        # Common street abbreviations (USPS standard)
        ABBREVIATIONS = {
            "street": "ST",
            "str": "ST",
            "st.": "ST",
            "avenue": "AVE",
            "ave.": "AVE",
            "av": "AVE",
            "boulevard": "BLVD",
            "blvd.": "BLVD",
            "drive": "DR",
            "dr.": "DR",
            "lane": "LN",
            "ln.": "LN",
            "road": "RD",
            "rd.": "RD",
            "court": "CT",
            "ct.": "CT",
            "circle": "CIR",
            "cir.": "CIR",
            "place": "PL",
            "pl.": "PL",
            "terrace": "TER",
            "ter.": "TER",
            "highway": "HWY",
            "hwy.": "HWY",
            "parkway": "PKWY",
            "pkwy.": "PKWY",
            "north": "N",
            "south": "S",
            "east": "E",
            "west": "W",
            "northeast": "NE",
            "northwest": "NW",
            "southeast": "SE",
            "southwest": "SW",
            "apartment": "APT",
            "apt.": "APT",
            "suite": "STE",
            "ste.": "STE",
            "unit": "UNIT",
            "floor": "FL",
        }

        def standardize_street(street):
            if not street:
                return street
            # Title case the street
            words = street.split()
            result = []
            for i, word in enumerate(words):
                word_lower = word.lower().rstrip(".,")
                if word_lower in ABBREVIATIONS:
                    result.append(ABBREVIATIONS[word_lower])
                elif word.isdigit() or (
                    len(word) > 1
                    and word[:-2].isdigit()
                    and word[-2:].lower() in ["st", "nd", "rd", "th"]
                ):
                    # Keep numbers and ordinals as-is
                    result.append(word.upper() if word[-2:].isalpha() else word)
                else:
                    result.append(word.title())
            return " ".join(result)

        # Get all clients with addresses
        clients = (
            db.query(Client)
            .filter(Client.address_street.isnot(None), Client.address_street != "")
            .all()
        )

        standardized = 0
        results = []

        for client in clients:
            original = {
                "street": client.address_street,
                "city": client.address_city,
                "state": client.address_state,
                "zip": client.address_zip,
            }

            changes = []

            # Standardize street
            new_street = standardize_street(client.address_street)
            if new_street != client.address_street:
                client.address_street = new_street
                changes.append(f"street: '{original['street']}' ‚Üí '{new_street}'")

            # Title case city
            if client.address_city:
                new_city = client.address_city.title()
                if new_city != client.address_city:
                    client.address_city = new_city
                    changes.append(f"city: '{original['city']}' ‚Üí '{new_city}'")

            # Uppercase state
            if client.address_state:
                new_state = client.address_state.upper()
                if new_state != client.address_state:
                    client.address_state = new_state
                    changes.append(f"state: '{original['state']}' ‚Üí '{new_state}'")

            if changes:
                client.updated_at = datetime.now()
                standardized += 1
                results.append(
                    {
                        "client_id": client.id,
                        "name": f"{client.first_name} {client.last_name}",
                        "changes": changes,
                    }
                )

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Standardized {standardized} addresses",
                "standardized": standardized,
                "total_checked": len(clients),
                "results": results,
            }
        )

    except Exception as e:
        db.rollback()
        log_error(e, {"action": "standardize_addresses_offline"})
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================================
# PHASE 8: BAG CRM FEATURE PARITY - CLIENT MANAGEMENT ENDPOINTS
# ============================================================================


@app.route("/api/clients/bulk-update", methods=["POST"])
@require_staff()
def api_clients_bulk_update():
    """Bulk update client status and/or type"""
    db = get_db()
    try:
        data = request.json
        client_ids = data.get("client_ids", [])
        status = data.get("status")
        client_type = data.get("client_type")

        if not client_ids:
            return jsonify({"success": False, "error": "No clients selected"}), 400

        updated = 0
        for client_id in client_ids:
            client = db.query(Client).filter_by(id=client_id).first()
            if client:
                if status:
                    client.status = status
                if client_type:
                    client.client_type = client_type
                client.updated_at = datetime.now()
                updated += 1

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Updated {updated} clients",
                "updated_count": updated,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/bulk-delete", methods=["POST"])
@require_staff(roles=["admin"])
def api_clients_bulk_delete():
    """Bulk delete clients (Admin only)"""
    db = get_db()
    try:
        data = request.json
        client_ids = data.get("client_ids", [])

        if not client_ids:
            return jsonify({"success": False, "error": "No clients selected"}), 400

        deleted = 0
        for client_id in client_ids:
            client = db.query(Client).filter_by(id=client_id).first()
            if client:
                # Delete associated records
                db.query(CreditReport).filter_by(client_id=client_id).delete()
                db.query(Analysis).filter_by(client_id=client_id).delete()
                db.query(Client).filter_by(id=client_id).delete()
                deleted += 1

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Deleted {deleted} clients",
                "deleted_count": deleted,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/type", methods=["POST"])
@require_staff()
def api_client_type(client_id):
    """Update client type (L=Lead, C=Client, I=Inactive, X=Cancelled)"""
    db = get_db()
    try:
        data = request.json
        client_type = data.get("client_type")

        if client_type not in ["L", "C", "I", "X", "O", "P"]:
            return jsonify({"success": False, "error": "Invalid client type"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        old_type = client.client_type
        client.client_type = client_type
        client.updated_at = datetime.now()
        db.commit()

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "old_type": old_type,
                "new_type": client_type,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/star", methods=["POST"])
@require_staff()
def api_client_star(client_id):
    """Toggle client starred status"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        client.starred = not client.starred
        client.updated_at = datetime.now()
        db.commit()

        return jsonify(
            {"success": True, "client_id": client_id, "starred": client.starred}
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/flag", methods=["POST"])
@require_staff()
def api_client_flag(client_id):
    """Toggle client priority flag (mark_1 or mark_2)"""
    db = get_db()
    try:
        data = request.json
        flag = data.get("flag")

        if flag not in ["mark_1", "mark_2"]:
            return jsonify({"success": False, "error": "Invalid flag"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if flag == "mark_1":
            client.mark_1 = not client.mark_1
            new_value = client.mark_1
        else:
            client.mark_2 = not client.mark_2
            new_value = client.mark_2

        client.updated_at = datetime.now()
        db.commit()

        return jsonify(
            {"success": True, "client_id": client_id, "flag": flag, "value": new_value}
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/portal", methods=["POST"])
@require_staff()
def api_client_portal(client_id):
    """Toggle client portal posted status"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        client.portal_posted = not client.portal_posted
        client.updated_at = datetime.now()
        db.commit()

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "portal_posted": client.portal_posted,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/send-portal-invite", methods=["POST"])
@require_staff()
def api_send_portal_invite(client_id):
    """
    Send portal invite to client - sets temp password, updates stage to onboarding,
    and emails login instructions.
    """
    import secrets
    import string

    from werkzeug.security import generate_password_hash

    from services.email_service import send_email

    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if not client.email:
            return (
                jsonify({"success": False, "error": "Client has no email address"}),
                400,
            )

        # Generate secure temp password (12 chars: letters + digits + special)
        alphabet = string.ascii_letters + string.digits + "!@#$%"
        temp_password = "".join(secrets.choice(alphabet) for _ in range(12))

        # Set password hash
        client.portal_password_hash = generate_password_hash(temp_password)

        # Update stage to onboarding (so they see CROA documents)
        client.client_stage = "onboarding"

        # Generate portal token as backup access method
        if not client.portal_token:
            client.portal_token = secrets.token_urlsafe(32)

        db.commit()

        # Build login URL
        base_url = request.host_url.rstrip("/")
        login_url = f"{base_url}/portal/login"
        magic_link = f"{base_url}/portal/{client.portal_token}"

        # Send email with login instructions
        html_content = f"""
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #22c55e;">Welcome to Your Client Portal</h2>
            <p>Hi {client.first_name or 'there'},</p>
            <p>Your client portal account is ready! You can now log in to complete your onboarding and sign the required documents.</p>

            <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="margin-top: 0;">Your Login Credentials</h3>
                <p><strong>Email:</strong> {client.email}</p>
                <p><strong>Temporary Password:</strong> {temp_password}</p>
                <p style="color: #6b7280; font-size: 14px;">Please change your password after logging in.</p>
            </div>

            <p>
                <a href="{login_url}" style="display: inline-block; background: #22c55e; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;">
                    Log In to Portal
                </a>
            </p>

            <p style="color: #6b7280; font-size: 14px; margin-top: 30px;">
                Or use this magic link (no password needed):<br>
                <a href="{magic_link}">{magic_link}</a>
            </p>

            <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 30px 0;">
            <p style="color: #9ca3af; font-size: 12px;">
                This is an automated message. If you did not request this, please contact us.
            </p>
        </div>
        """

        email_result = send_email(
            to_email=client.email,
            subject="Your Client Portal is Ready - Login Instructions",
            html_content=html_content,
        )

        return jsonify(
            {
                "success": True,
                "message": f"Portal invite sent to {client.email}",
                "client_stage": client.client_stage,
                "temp_password": temp_password,  # Return to staff so they can share if needed
                "login_url": login_url,
                "magic_link": magic_link,
            }
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/followup", methods=["POST"])
@require_staff()
def api_client_followup(client_id):
    """Set client follow-up date"""
    db = get_db()
    try:
        data = request.json
        date_str = data.get("date")

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if date_str:
            try:
                client.follow_up_date = datetime.strptime(date_str, "%Y-%m-%d").date()
            except ValueError:
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "Invalid date format. Use YYYY-MM-DD",
                        }
                    ),
                    400,
                )
        else:
            client.follow_up_date = None

        client.updated_at = datetime.now()
        db.commit()

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "follow_up_date": (
                    client.follow_up_date.isoformat() if client.follow_up_date else None
                ),
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/workflow", methods=["POST"])
@require_staff()
def api_client_workflow(client_id):
    """Update client workflow step"""
    db = get_db()
    try:
        data = request.json
        workflow = data.get("workflow")

        valid_workflows = [
            "intake",
            "round1",
            "waiting",
            "round2",
            "round3",
            "litigation",
            "settlement",
            "complete",
        ]
        if workflow not in valid_workflows:
            return jsonify({"success": False, "error": "Invalid workflow"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        old_workflow = client.current_dispute_step
        client.current_dispute_step = workflow

        # Also update dispute round based on workflow
        workflow_to_round = {
            "intake": 0,
            "round1": 1,
            "waiting": 1,
            "round2": 2,
            "round3": 3,
            "litigation": 4,
            "settlement": 4,
            "complete": 4,
        }
        client.current_dispute_round = workflow_to_round.get(workflow, 0)
        client.updated_at = datetime.now()
        db.commit()

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "old_workflow": old_workflow,
                "new_workflow": workflow,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/note", methods=["POST"])
@require_staff()
def api_client_add_note(client_id):
    """Add a note to client"""
    db = get_db()
    try:
        data = request.json
        note = data.get("note")

        if not note:
            return jsonify({"success": False, "error": "Note is required"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Add note with timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        new_note = f"[{timestamp}] {note}"

        if client.admin_notes:
            client.admin_notes = new_note + "\n\n" + client.admin_notes
        else:
            client.admin_notes = new_note

        client.updated_at = datetime.now()
        db.commit()

        return jsonify(
            {"success": True, "client_id": client_id, "message": "Note added"}
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/tasks", methods=["GET", "POST"])
def api_client_tasks(client_id):
    """Get or create tasks for a client"""
    db = get_db()
    try:
        if request.method == "GET":
            tasks = (
                db.query(Task)
                .filter_by(client_id=client_id)
                .order_by(Task.due_date.desc())
                .all()
            )
            tasks_data = [
                {
                    "id": t.id,
                    "title": t.title,
                    "task_type": t.task_type,
                    "description": t.description,
                    "due_date": t.due_date.isoformat() if t.due_date else None,
                    "due_time": t.due_time,
                    "status": t.status,
                    "assigned_to": t.assigned_to,
                    "created_at": (
                        t.created_at.strftime("%Y-%m-%d %H:%M")
                        if t.created_at
                        else None
                    ),
                }
                for t in tasks
            ]
            return jsonify({"success": True, "tasks": tasks_data})
        else:
            data = request.json
            task = Task(
                client_id=client_id,
                title=data.get("title"),
                task_type=data.get("task_type", "other"),
                description=data.get("description"),
                due_time=data.get("due_time"),
                status="pending",
                assigned_to=data.get("assigned_to"),
            )
            if data.get("due_date"):
                task.due_date = datetime.strptime(data["due_date"], "%Y-%m-%d").date()

            db.add(task)
            db.commit()
            return jsonify({"success": True, "task_id": task.id})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/notes", methods=["GET", "POST"])
def api_client_notes(client_id):
    """Get or create notes for a client"""
    db = get_db()
    try:
        if request.method == "GET":
            notes = (
                db.query(ClientNote)
                .filter_by(client_id=client_id)
                .order_by(ClientNote.created_at.desc())
                .all()
            )
            notes_data = [
                {
                    "id": n.id,
                    "note_content": n.note_content,
                    "created_by": n.created_by,
                    "created_at": (
                        n.created_at.strftime("%Y-%m-%d %H:%M")
                        if n.created_at
                        else None
                    ),
                }
                for n in notes
            ]
            return jsonify({"success": True, "notes": notes_data})
        else:
            data = request.json
            # Sanitize note content to prevent XSS
            note = ClientNote(
                client_id=client_id,
                note_content=sanitize_string(
                    data.get("note_content", ""), max_length=10000
                ),
                created_by=sanitize_string(
                    data.get("created_by", "Admin"), max_length=100
                ),
            )
            db.add(note)
            db.commit()
            return jsonify({"success": True, "note_id": note.id})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/documents", methods=["POST"])
def api_update_client_documents(client_id):
    """Update document receipt status for a client"""
    db = get_db()
    try:
        data = request.json
        documents = data.get("documents", [])

        for doc_data in documents:
            doc_type = doc_data.get("document_type")
            received = doc_data.get("received", False)

            existing = (
                db.query(ClientDocument)
                .filter_by(client_id=client_id, document_type=doc_type)
                .first()
            )

            if existing:
                existing.received = received
                existing.received_at = (
                    datetime.utcnow()
                    if received and not existing.received_at
                    else existing.received_at
                )
                existing.updated_at = datetime.utcnow()
            else:
                new_doc = ClientDocument(
                    client_id=client_id,
                    document_type=doc_type,
                    received=received,
                    received_at=datetime.utcnow() if received else None,
                )
                db.add(new_doc)

        db.commit()
        return jsonify({"success": True, "message": "Documents updated"})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/documents", methods=["GET"])
def api_get_client_documents(client_id):
    """Get document receipt status for a client (LMR-style document tracking)"""
    db = get_db()
    try:
        documents = db.query(ClientDocument).filter_by(client_id=client_id).all()

        doc_types = [
            "agreement",
            "cr_login",
            "drivers_license",
            "ssn_card",
            "utility_bill",
            "poa",
        ]
        doc_labels = {
            "agreement": "Agreement Document",
            "cr_login": "Credit Report Login",
            "drivers_license": "Driver's License",
            "ssn_card": "Social Security Card",
            "utility_bill": "Utility Bill",
            "poa": "Power of Attorney",
        }

        doc_map = {d.document_type: d for d in documents}

        docs_data = []
        for doc_type in doc_types:
            doc = doc_map.get(doc_type)
            docs_data.append(
                {
                    "document_type": doc_type,
                    "label": doc_labels.get(doc_type, doc_type),
                    "received": doc.received if doc else False,
                    "received_at": (
                        doc.received_at.strftime("%Y-%m-%d")
                        if doc and doc.received_at
                        else None
                    ),
                }
            )

        received_count = sum(1 for d in docs_data if d["received"])
        total_count = len(docs_data)

        return jsonify(
            {
                "success": True,
                "documents": docs_data,
                "received_count": received_count,
                "total_count": total_count,
                "all_received": received_count == total_count,
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/documents/toggle", methods=["POST"])
def api_toggle_client_document(client_id):
    """Quick toggle a single document received status"""
    db = get_db()
    try:
        data = request.json
        doc_type = data.get("document_type")

        if not doc_type:
            return jsonify({"success": False, "error": "document_type required"}), 400

        existing = (
            db.query(ClientDocument)
            .filter_by(client_id=client_id, document_type=doc_type)
            .first()
        )

        if existing:
            existing.received = not existing.received
            existing.received_at = datetime.utcnow() if existing.received else None
            existing.updated_at = datetime.utcnow()
            new_status = existing.received
        else:
            new_doc = ClientDocument(
                client_id=client_id,
                document_type=doc_type,
                received=True,
                received_at=datetime.utcnow(),
            )
            db.add(new_doc)
            new_status = True

        db.commit()
        return jsonify(
            {
                "success": True,
                "received": new_status,
                "received_at": (
                    datetime.utcnow().strftime("%Y-%m-%d") if new_status else None
                ),
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# PHASE 8: TAG MANAGEMENT ENDPOINTS
# ============================================================


@app.route("/api/tags", methods=["GET"])
@require_staff()
def api_list_tags():
    """List all client tags"""
    db = get_db()
    try:
        tags = db.query(ClientTag).order_by(ClientTag.name).all()
        return jsonify(
            {
                "success": True,
                "tags": [
                    {
                        "id": t.id,
                        "name": t.name,
                        "color": t.color,
                        "created_at": (
                            t.created_at.strftime("%Y-%m-%d") if t.created_at else None
                        ),
                    }
                    for t in tags
                ],
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tags", methods=["POST"])
@require_staff()
def api_create_tag():
    """Create a new client tag"""
    db = get_db()
    try:
        data = request.json
        name = data.get("name", "").strip()
        color = data.get("color", "#6366f1")

        if not name:
            return jsonify({"success": False, "error": "Tag name is required"}), 400

        # Check for duplicate
        existing = db.query(ClientTag).filter_by(name=name).first()
        if existing:
            return jsonify({"success": False, "error": "Tag already exists"}), 400

        tag = ClientTag(name=name, color=color)
        db.add(tag)
        db.commit()

        return jsonify(
            {
                "success": True,
                "tag": {"id": tag.id, "name": tag.name, "color": tag.color},
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tags/<int:tag_id>", methods=["PUT"])
@require_staff()
def api_update_tag(tag_id):
    """Update a client tag"""
    db = get_db()
    try:
        data = request.json
        tag = db.query(ClientTag).filter_by(id=tag_id).first()
        if not tag:
            return jsonify({"success": False, "error": "Tag not found"}), 404

        if "name" in data:
            new_name = data["name"].strip()
            if new_name and new_name != tag.name:
                existing = db.query(ClientTag).filter_by(name=new_name).first()
                if existing:
                    return (
                        jsonify({"success": False, "error": "Tag name already exists"}),
                        400,
                    )
                tag.name = new_name

        if "color" in data:
            tag.color = data["color"]

        db.commit()
        return jsonify(
            {
                "success": True,
                "tag": {"id": tag.id, "name": tag.name, "color": tag.color},
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tags/<int:tag_id>", methods=["DELETE"])
@require_staff()
def api_delete_tag(tag_id):
    """Delete a client tag"""
    db = get_db()
    try:
        tag = db.query(ClientTag).filter_by(id=tag_id).first()
        if not tag:
            return jsonify({"success": False, "error": "Tag not found"}), 404

        # Delete all assignments first (cascade should handle this, but be explicit)
        db.query(ClientTagAssignment).filter_by(tag_id=tag_id).delete()
        db.delete(tag)
        db.commit()

        return jsonify({"success": True, "message": "Tag deleted"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/tags", methods=["GET"])
@require_staff()
def api_get_client_tags(client_id):
    """Get tags assigned to a client"""
    db = get_db()
    try:
        assignments = db.query(ClientTagAssignment).filter_by(client_id=client_id).all()
        tag_ids = [a.tag_id for a in assignments]
        tags = (
            db.query(ClientTag).filter(ClientTag.id.in_(tag_ids)).all()
            if tag_ids
            else []
        )

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "tags": [{"id": t.id, "name": t.name, "color": t.color} for t in tags],
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/tags", methods=["POST"])
@require_staff()
def api_add_client_tag(client_id):
    """Add a tag to a client"""
    db = get_db()
    try:
        data = request.json
        tag_id = data.get("tag_id")

        if not tag_id:
            return jsonify({"success": False, "error": "tag_id is required"}), 400

        # Verify client exists
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Verify tag exists
        tag = db.query(ClientTag).filter_by(id=tag_id).first()
        if not tag:
            return jsonify({"success": False, "error": "Tag not found"}), 404

        # Check if already assigned
        existing = (
            db.query(ClientTagAssignment)
            .filter_by(client_id=client_id, tag_id=tag_id)
            .first()
        )
        if existing:
            return jsonify({"success": True, "message": "Tag already assigned"})

        assignment = ClientTagAssignment(client_id=client_id, tag_id=tag_id)
        db.add(assignment)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Tag added",
                "tag": {"id": tag.id, "name": tag.name, "color": tag.color},
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/tags/<int:tag_id>", methods=["DELETE"])
@require_staff()
def api_remove_client_tag(client_id, tag_id):
    """Remove a tag from a client"""
    db = get_db()
    try:
        assignment = (
            db.query(ClientTagAssignment)
            .filter_by(client_id=client_id, tag_id=tag_id)
            .first()
        )

        if not assignment:
            return (
                jsonify({"success": False, "error": "Tag not assigned to client"}),
                404,
            )

        db.delete(assignment)
        db.commit()

        return jsonify({"success": True, "message": "Tag removed"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# LEAD SCORING ENDPOINTS
# ============================================================


@app.route("/api/clients/<int:client_id>/score", methods=["GET"])
@require_staff()
def api_get_client_score(client_id):
    """Get lead score for a client"""
    from services.lead_scoring_service import LeadScoringService

    result = LeadScoringService.calculate_score(client_id)
    if result["success"]:
        return jsonify(result)
    return jsonify(result), 404


@app.route("/api/clients/<int:client_id>/score", methods=["POST"])
@require_staff()
def api_update_client_score(client_id):
    """Calculate and save lead score for a client"""
    from services.lead_scoring_service import LeadScoringService

    result = LeadScoringService.update_client_score(client_id)
    if result["success"]:
        return jsonify(result)
    return jsonify(result), 500


@app.route("/api/leads/score-all", methods=["POST"])
@require_staff()
def api_score_all_leads():
    """Rescore all clients in the database"""
    from services.lead_scoring_service import LeadScoringService

    data = request.get_json() or {}
    limit = data.get("limit")  # Optional limit for batch processing

    result = LeadScoringService.score_all_clients(limit=limit)
    return jsonify(result)


@app.route("/api/leads/top", methods=["GET"])
@require_staff()
def api_get_top_leads():
    """Get top leads by score"""
    from services.lead_scoring_service import LeadScoringService

    limit = request.args.get("limit", 10, type=int)
    leads = LeadScoringService.get_top_leads(limit=limit)
    return jsonify({"success": True, "leads": leads})


@app.route("/api/leads/distribution", methods=["GET"])
@require_staff()
def api_get_lead_distribution():
    """Get distribution of lead scores"""
    from services.lead_scoring_service import LeadScoringService

    distribution = LeadScoringService.get_score_distribution()
    return jsonify({"success": True, "distribution": distribution})


# ============================================================
# PHASE 8: QUICK LINKS ENDPOINTS
# ============================================================


@app.route("/api/staff/quick-links", methods=["GET"])
@require_staff()
def api_get_quick_links():
    """Get current staff member's quick links"""
    db = get_db()
    try:
        staff_id = session.get("staff_id")
        if not staff_id:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        links = (
            db.query(UserQuickLink)
            .filter_by(staff_id=staff_id)
            .order_by(UserQuickLink.slot_number)
            .all()
        )

        # Return as dict with slot numbers as keys
        links_dict = {l.slot_number: {"label": l.label, "url": l.url} for l in links}

        return jsonify({"success": True, "quick_links": links_dict})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/staff/quick-links", methods=["POST"])
@require_staff()
def api_save_quick_link():
    """Save a quick link for current staff member"""
    db = get_db()
    try:
        staff_id = session.get("staff_id")
        if not staff_id:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        data = request.json
        slot_number = data.get("slot_number")
        label = data.get("label", "").strip()
        url = data.get("url", "").strip()

        if not slot_number or slot_number < 1 or slot_number > 8:
            return jsonify({"success": False, "error": "slot_number must be 1-8"}), 400

        if not label or not url:
            return (
                jsonify({"success": False, "error": "label and url are required"}),
                400,
            )

        # Find existing or create new
        existing = (
            db.query(UserQuickLink)
            .filter_by(staff_id=staff_id, slot_number=slot_number)
            .first()
        )

        if existing:
            existing.label = label
            existing.url = url
        else:
            link = UserQuickLink(
                staff_id=staff_id, slot_number=slot_number, label=label, url=url
            )
            db.add(link)

        db.commit()
        return jsonify({"success": True, "message": "Quick link saved"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/staff/quick-links/<int:slot_number>", methods=["DELETE"])
@require_staff()
def api_delete_quick_link(slot_number):
    """Delete a quick link"""
    db = get_db()
    try:
        staff_id = session.get("staff_id")
        if not staff_id:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        link = (
            db.query(UserQuickLink)
            .filter_by(staff_id=staff_id, slot_number=slot_number)
            .first()
        )

        if not link:
            return jsonify({"success": False, "error": "Quick link not found"}), 404

        db.delete(link)
        db.commit()

        return jsonify({"success": True, "message": "Quick link deleted"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# EMAIL TEMPLATES LIBRARY
# ============================================================

from services.email_template_service import (
    COMMON_VARIABLES,
    TEMPLATE_CATEGORIES,
    EmailTemplateService,
    seed_default_templates,
)


@app.route("/api/email-templates/library", methods=["GET"])
@require_staff()
def api_list_email_templates_library():
    """List all email templates with optional filtering"""
    category = request.args.get("category")
    is_active = request.args.get("is_active")
    is_custom = request.args.get("is_custom")
    search = request.args.get("search")

    # Convert string params to bool
    if is_active is not None:
        is_active = is_active.lower() == "true"
    if is_custom is not None:
        is_custom = is_custom.lower() == "true"

    templates = EmailTemplateService.list_templates(
        category=category,
        is_active=is_active,
        is_custom=is_custom,
        search=search,
    )

    return jsonify(
        {
            "success": True,
            "templates": templates,
            "categories": TEMPLATE_CATEGORIES,
        }
    )


@app.route("/api/email-templates/stats", methods=["GET"])
@require_staff()
def api_email_template_stats():
    """Get email template statistics"""
    stats = EmailTemplateService.get_template_stats()
    return jsonify({"success": True, "stats": stats})


@app.route("/api/email-templates/categories", methods=["GET"])
@require_staff()
def api_email_template_categories():
    """Get available template categories"""
    return jsonify(
        {
            "success": True,
            "categories": TEMPLATE_CATEGORIES,
        }
    )


@app.route("/api/email-templates/variables", methods=["GET"])
@require_staff()
def api_email_template_variables():
    """Get common template variables"""
    return jsonify(
        {
            "success": True,
            "variables": COMMON_VARIABLES,
        }
    )


@app.route("/api/email-templates/library/<int:template_id>", methods=["GET"])
@require_staff()
def api_get_email_template_by_id(template_id):
    """Get a specific email template by ID"""
    template = EmailTemplateService.get_template(template_id=template_id)

    if not template:
        return jsonify({"success": False, "error": "Template not found"}), 404

    return jsonify({"success": True, "template": template})


@app.route("/api/email-templates/library", methods=["POST"])
@require_staff()
def api_create_email_template_library():
    """Create a new email template"""
    data = request.json

    required = ["template_type", "name", "subject", "html_content"]
    for field in required:
        if not data.get(field):
            return (
                jsonify(
                    {"success": False, "error": f"Missing required field: {field}"}
                ),
                400,
            )

    result = EmailTemplateService.create_template(
        template_type=data["template_type"],
        name=data["name"],
        subject=data["subject"],
        html_content=data["html_content"],
        category=data.get("category", "general"),
        description=data.get("description"),
        plain_text_content=data.get("plain_text_content"),
        variables=data.get("variables", []),
        is_custom=True,
    )

    if result["success"]:
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/email-templates/library/<int:template_id>", methods=["PUT"])
@require_staff()
def api_update_email_template_library(template_id):
    """Update an email template"""
    data = request.json

    result = EmailTemplateService.update_template(
        template_id=template_id,
        name=data.get("name"),
        subject=data.get("subject"),
        html_content=data.get("html_content"),
        category=data.get("category"),
        description=data.get("description"),
        plain_text_content=data.get("plain_text_content"),
        variables=data.get("variables"),
        is_active=data.get("is_active"),
    )

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/email-templates/library/<int:template_id>", methods=["DELETE"])
@require_staff()
def api_delete_email_template_library(template_id):
    """Delete an email template"""
    result = EmailTemplateService.delete_template(template_id)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/email-templates/library/<int:template_id>/duplicate", methods=["POST"])
@require_staff()
def api_duplicate_email_template_library(template_id):
    """Duplicate an email template"""
    data = request.json or {}

    result = EmailTemplateService.duplicate_template(
        template_id=template_id,
        new_name=data.get("name"),
        new_type=data.get("template_type"),
    )

    if result["success"]:
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/email-templates/library/<int:template_id>/render", methods=["POST"])
@require_staff()
def api_render_email_template_library(template_id):
    """Render an email template with variable substitution"""
    data = request.json or {}
    variables = data.get("variables", {})

    result = EmailTemplateService.render_template(
        template_id=template_id,
        variables=variables,
    )

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/email-templates/seed", methods=["POST"])
@require_staff()
def api_seed_email_templates():
    """Seed default system templates"""
    result = seed_default_templates()

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 500


@app.route("/dashboard/email-templates")
@require_staff()
def email_templates_page():
    """Email templates management page"""
    return render_template("email_templates.html")


# ============================================================
# DRIP CAMPAIGNS - Automated Email Sequences
# ============================================================

from services.drip_campaign_service import DripCampaignService


@app.route("/api/drip-campaigns/trigger-types", methods=["GET"])
@require_staff()
def api_get_drip_trigger_types():
    """Get all available trigger types"""
    return jsonify(
        {"success": True, "trigger_types": DripCampaignService.get_trigger_types()}
    )


@app.route("/api/drip-campaigns/enrollment-statuses", methods=["GET"])
@require_staff()
def api_get_enrollment_statuses():
    """Get all enrollment status options"""
    return jsonify(
        {"success": True, "statuses": DripCampaignService.get_enrollment_statuses()}
    )


@app.route("/api/drip-campaigns", methods=["GET"])
@require_staff()
def api_list_drip_campaigns():
    """List all drip campaigns with optional filtering"""
    is_active = request.args.get("is_active")
    trigger_type = request.args.get("trigger_type")

    # Convert string to boolean
    if is_active is not None:
        is_active = is_active.lower() == "true"

    campaigns = DripCampaignService.list_campaigns(
        is_active=is_active, trigger_type=trigger_type
    )
    return jsonify({"success": True, "campaigns": campaigns})


@app.route("/api/drip-campaigns", methods=["POST"])
@require_staff()
def api_create_drip_campaign():
    """Create a new drip campaign"""
    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    name = data.get("name")
    trigger_type = data.get("trigger_type")

    if not name or not trigger_type:
        return (
            jsonify({"success": False, "error": "Name and trigger_type are required"}),
            400,
        )

    # Get current staff ID
    staff_id = session.get("staff_id")

    result = DripCampaignService.create_campaign(
        name=name,
        trigger_type=trigger_type,
        trigger_value=data.get("trigger_value"),
        description=data.get("description"),
        send_window_start=data.get("send_window_start", 9),
        send_window_end=data.get("send_window_end", 17),
        send_on_weekends=data.get("send_on_weekends", False),
        created_by_id=staff_id,
        steps=data.get("steps"),
    )

    if result["success"]:
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/drip-campaigns/<int:campaign_id>", methods=["GET"])
@require_staff()
def api_get_drip_campaign(campaign_id):
    """Get a drip campaign by ID"""
    include_steps = request.args.get("include_steps", "true").lower() == "true"
    campaign = DripCampaignService.get_campaign(
        campaign_id, include_steps=include_steps
    )

    if campaign:
        return jsonify({"success": True, "campaign": campaign})
    return jsonify({"success": False, "error": "Campaign not found"}), 404


@app.route("/api/drip-campaigns/<int:campaign_id>", methods=["PUT"])
@require_staff()
def api_update_drip_campaign(campaign_id):
    """Update a drip campaign"""
    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    result = DripCampaignService.update_campaign(campaign_id, **data)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/drip-campaigns/<int:campaign_id>", methods=["DELETE"])
@require_staff()
def api_delete_drip_campaign(campaign_id):
    """Delete a drip campaign"""
    result = DripCampaignService.delete_campaign(campaign_id)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), (
        404 if "not found" in result.get("error", "").lower() else 400
    )


@app.route("/api/drip-campaigns/<int:campaign_id>/stats", methods=["GET"])
@require_staff()
def api_get_drip_campaign_stats(campaign_id):
    """Get statistics for a drip campaign"""
    result = DripCampaignService.get_campaign_stats(campaign_id)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 404


# ============== DRIP CAMPAIGN STEPS ==============


@app.route("/api/drip-campaigns/<int:campaign_id>/steps", methods=["POST"])
@require_staff()
def api_add_drip_step(campaign_id):
    """Add a step to a drip campaign"""
    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    template_id = data.get("template_id")
    delay_days = data.get("delay_days")

    if template_id is None or delay_days is None:
        return (
            jsonify(
                {"success": False, "error": "template_id and delay_days are required"}
            ),
            400,
        )

    result = DripCampaignService.add_step(
        campaign_id=campaign_id,
        template_id=template_id,
        delay_days=delay_days,
        delay_hours=data.get("delay_hours", 0),
        subject_override=data.get("subject_override"),
        step_order=data.get("step_order"),
    )

    if result["success"]:
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/drip-campaigns/steps/<int:step_id>", methods=["PUT"])
@require_staff()
def api_update_drip_step(step_id):
    """Update a drip campaign step"""
    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    result = DripCampaignService.update_step(step_id, **data)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/drip-campaigns/steps/<int:step_id>", methods=["DELETE"])
@require_staff()
def api_delete_drip_step(step_id):
    """Delete a drip campaign step"""
    result = DripCampaignService.delete_step(step_id)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), (
        404 if "not found" in result.get("error", "").lower() else 400
    )


@app.route("/api/drip-campaigns/<int:campaign_id>/steps/reorder", methods=["POST"])
@require_staff()
def api_reorder_drip_steps(campaign_id):
    """Reorder steps in a drip campaign"""
    data = request.get_json()
    if not data or "step_ids" not in data:
        return jsonify({"success": False, "error": "step_ids array required"}), 400

    result = DripCampaignService.reorder_steps(campaign_id, data["step_ids"])

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


# ============== DRIP ENROLLMENTS ==============


@app.route("/api/drip-campaigns/enrollments", methods=["GET"])
@require_staff()
def api_list_drip_enrollments():
    """List drip campaign enrollments with optional filtering"""
    campaign_id = request.args.get("campaign_id", type=int)
    client_id = request.args.get("client_id", type=int)
    status = request.args.get("status")

    result = DripCampaignService.list_enrollments(
        campaign_id=campaign_id, client_id=client_id, status=status
    )
    return jsonify(result)


@app.route(
    "/api/drip-campaigns/<int:campaign_id>/enroll/<int:client_id>", methods=["POST"]
)
@require_staff()
def api_enroll_client_in_campaign(campaign_id, client_id):
    """Enroll a client in a drip campaign"""
    data = request.get_json() or {}

    result = DripCampaignService.enroll_client(
        campaign_id=campaign_id,
        client_id=client_id,
        trigger_source=data.get("trigger_source", "manual"),
        skip_if_enrolled=data.get("skip_if_enrolled", True),
    )

    if result["success"]:
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/drip-campaigns/enrollments/<int:enrollment_id>", methods=["GET"])
@require_staff()
def api_get_drip_enrollment(enrollment_id):
    """Get a specific enrollment"""
    enrollment = DripCampaignService.get_enrollment(enrollment_id)

    if enrollment:
        return jsonify({"success": True, "enrollment": enrollment})
    return jsonify({"success": False, "error": "Enrollment not found"}), 404


@app.route(
    "/api/drip-campaigns/enrollments/<int:enrollment_id>/pause", methods=["POST"]
)
@require_staff()
def api_pause_drip_enrollment(enrollment_id):
    """Pause an enrollment"""
    data = request.get_json() or {}
    result = DripCampaignService.pause_enrollment(
        enrollment_id, reason=data.get("reason")
    )

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route(
    "/api/drip-campaigns/enrollments/<int:enrollment_id>/resume", methods=["POST"]
)
@require_staff()
def api_resume_drip_enrollment(enrollment_id):
    """Resume a paused enrollment"""
    result = DripCampaignService.resume_enrollment(enrollment_id)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route(
    "/api/drip-campaigns/enrollments/<int:enrollment_id>/cancel", methods=["POST"]
)
@require_staff()
def api_cancel_drip_enrollment(enrollment_id):
    """Cancel an enrollment"""
    data = request.get_json() or {}
    result = DripCampaignService.cancel_enrollment(
        enrollment_id, reason=data.get("reason")
    )

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


# ============== DRIP PROCESSING ==============


@app.route("/api/drip-campaigns/process", methods=["POST"])
@require_staff()
def api_process_drip_emails():
    """Manually trigger drip email processing (admin use)"""
    result = DripCampaignService.process_due_emails()
    return jsonify(result)


@app.route("/dashboard/drip-campaigns")
@require_staff()
def drip_campaigns_page():
    """Drip campaigns management page"""
    return render_template("drip_campaigns.html")


# ============================================================
# SMS TEMPLATES - Client SMS Communications
# ============================================================

from services.sms_template_service import (
    SMS_CATEGORIES,
    SMS_VARIABLES,
    SMSTemplateService,
    seed_default_sms_templates,
)


@app.route("/api/sms-templates", methods=["GET"])
@require_staff()
def api_list_sms_templates():
    """List all SMS templates with optional filtering"""
    category = request.args.get("category")
    is_active = request.args.get("is_active")
    is_custom = request.args.get("is_custom")
    search = request.args.get("search")

    # Convert string params to bool
    if is_active is not None:
        is_active = is_active.lower() == "true"
    if is_custom is not None:
        is_custom = is_custom.lower() == "true"

    templates = SMSTemplateService.list_templates(
        category=category,
        is_active=is_active,
        is_custom=is_custom,
        search=search,
    )

    return jsonify(
        {
            "success": True,
            "templates": templates,
            "categories": SMS_CATEGORIES,
        }
    )


@app.route("/api/sms-templates/stats", methods=["GET"])
@require_staff()
def api_sms_template_stats():
    """Get SMS template statistics"""
    stats = SMSTemplateService.get_template_stats()
    return jsonify({"success": True, "stats": stats})


@app.route("/api/sms-templates/categories", methods=["GET"])
@require_staff()
def api_sms_template_categories():
    """Get available SMS template categories"""
    return jsonify(
        {
            "success": True,
            "categories": SMS_CATEGORIES,
        }
    )


@app.route("/api/sms-templates/variables", methods=["GET"])
@require_staff()
def api_sms_template_variables():
    """Get common SMS template variables"""
    return jsonify(
        {
            "success": True,
            "variables": SMS_VARIABLES,
        }
    )


@app.route("/api/sms-templates/<int:template_id>", methods=["GET"])
@require_staff()
def api_get_sms_template(template_id):
    """Get a specific SMS template by ID"""
    template = SMSTemplateService.get_template(template_id=template_id)

    if not template:
        return jsonify({"success": False, "error": "Template not found"}), 404

    return jsonify({"success": True, "template": template})


@app.route("/api/sms-templates", methods=["POST"])
@require_staff()
def api_create_sms_template():
    """Create a new SMS template"""
    data = request.json

    required = ["template_type", "name", "message"]
    for field in required:
        if not data.get(field):
            return (
                jsonify(
                    {"success": False, "error": f"Missing required field: {field}"}
                ),
                400,
            )

    result = SMSTemplateService.create_template(
        template_type=data["template_type"],
        name=data["name"],
        message=data["message"],
        category=data.get("category", "general"),
        description=data.get("description"),
        variables=data.get("variables", []),
        is_custom=True,
    )

    if result["success"]:
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/sms-templates/<int:template_id>", methods=["PUT"])
@require_staff()
def api_update_sms_template(template_id):
    """Update an SMS template"""
    data = request.json

    result = SMSTemplateService.update_template(
        template_id=template_id,
        name=data.get("name"),
        message=data.get("message"),
        category=data.get("category"),
        description=data.get("description"),
        variables=data.get("variables"),
        is_active=data.get("is_active"),
    )

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/sms-templates/<int:template_id>", methods=["DELETE"])
@require_staff()
def api_delete_sms_template(template_id):
    """Delete an SMS template"""
    result = SMSTemplateService.delete_template(template_id)

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/sms-templates/<int:template_id>/duplicate", methods=["POST"])
@require_staff()
def api_duplicate_sms_template(template_id):
    """Duplicate an SMS template"""
    data = request.json or {}

    result = SMSTemplateService.duplicate_template(
        template_id=template_id,
        new_name=data.get("name"),
        new_type=data.get("template_type"),
    )

    if result["success"]:
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/sms-templates/<int:template_id>/render", methods=["POST"])
@require_staff()
def api_render_sms_template(template_id):
    """Render an SMS template with variable substitution"""
    data = request.json or {}
    variables = data.get("variables", {})

    result = SMSTemplateService.render_template(
        template_id=template_id,
        variables=variables,
    )

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/sms-templates/seed", methods=["POST"])
@require_staff()
def api_seed_sms_templates():
    """Seed default SMS templates"""
    result = seed_default_sms_templates()

    if result["success"]:
        return jsonify(result)
    return jsonify(result), 500


@app.route("/api/sms-templates/send", methods=["POST"])
@require_staff()
def api_send_sms_from_template():
    """Send an SMS using a template"""
    data = request.json

    if not data.get("template_id") and not data.get("template_type"):
        return (
            jsonify(
                {"success": False, "error": "Must provide template_id or template_type"}
            ),
            400,
        )
    if not data.get("client_id") and not data.get("phone"):
        return (
            jsonify(
                {"success": False, "error": "Must provide client_id or phone number"}
            ),
            400,
        )

    # Get client info if client_id provided
    phone = data.get("phone")
    client_name = data.get("client_name", "")
    first_name = data.get("first_name", "")

    if data.get("client_id"):
        session = SessionLocal()
        try:
            client = (
                session.query(Client).filter(Client.id == data["client_id"]).first()
            )
            if client:
                phone = phone or client.phone
                client_name = client_name or client.name
                first_name = first_name or (
                    client.name.split()[0] if client.name else ""
                )
        finally:
            session.close()

    if not phone:
        return jsonify({"success": False, "error": "No phone number available"}), 400

    # Render the template
    variables = data.get("variables", {})
    variables.setdefault("client_name", client_name)
    variables.setdefault("first_name", first_name)
    variables.setdefault("phone", phone)

    result = SMSTemplateService.render_template(
        template_id=data.get("template_id"),
        template_type=data.get("template_type"),
        variables=variables,
    )

    if not result["success"]:
        return jsonify(result), 400

    # Send the SMS
    try:
        from services.sms_service import send_sms

        sms_result = send_sms(phone, result["message"])

        if sms_result.get("success"):
            return jsonify(
                {
                    "success": True,
                    "message": "SMS sent successfully",
                    "sms_sid": sms_result.get("sid"),
                    "char_count": result["char_count"],
                    "segments": result["segments"],
                }
            )
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": sms_result.get("error", "Failed to send SMS"),
                    }
                ),
                500,
            )

    except Exception as e:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f"SMS service error: {str(e)}",
                }
            ),
            500,
        )


@app.route("/dashboard/sms-templates")
@require_staff()
def sms_templates_page():
    """SMS templates management page"""
    return render_template("sms_templates.html")


# ============================================================
# DOCUMENT CENTER - Client Upload Management
# ============================================================

ALLOWED_EXTENSIONS = {"pdf", "jpg", "jpeg", "png", "gif", "doc", "docx", "txt", "csv"}
BLOCKED_EXTENSIONS = {
    "exe",
    "php",
    "sh",
    "bat",
    "cmd",
    "ps1",
    "js",
    "vbs",
    "py",
    "rb",
    "pl",
    "cgi",
    "asp",
    "aspx",
    "jsp",
    "war",
    "jar",
    "dll",
    "so",
    "dylib",
    "msi",
    "com",
    "scr",
    "pif",
    "hta",
    "wsf",
    "vbe",
    "jse",
}
UPLOAD_FOLDER = "static/client_uploads"


def allowed_file(filename):
    """Check if file extension is allowed (whitelist approach with explicit blocklist)"""
    if "." not in filename:
        return False
    ext = filename.rsplit(".", 1)[1].lower()
    # Explicitly block dangerous extensions first
    if ext in BLOCKED_EXTENSIONS:
        return False
    # Then check against whitelist
    return ext in ALLOWED_EXTENSIONS


def is_blocked_extension(filename):
    """Check if file has a blocked/dangerous extension"""
    if "." not in filename:
        return False
    ext = filename.rsplit(".", 1)[1].lower()
    return ext in BLOCKED_EXTENSIONS


@app.route("/api/client/upload", methods=["POST"])
def api_client_upload():
    """Handle document upload from client portal or admin"""
    db = get_db()
    try:
        if "file" not in request.files:
            return jsonify({"success": False, "error": "No file uploaded"}), 400

        file = request.files["file"]
        if file.filename == "":
            return jsonify({"success": False, "error": "No file selected"}), 400

        if not allowed_file(file.filename):
            return jsonify({"success": False, "error": "File type not allowed"}), 400

        client_id = request.form.get("client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Client ID required"}), 400

        client = db.query(Client).filter_by(id=int(client_id)).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        category = request.form.get("category", "other")
        document_type = request.form.get("document_type", "misc")

        filename = secure_filename(file.filename)
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        unique_filename = f"{client_id}_{timestamp}_{filename}"

        client_folder = os.path.join(UPLOAD_FOLDER, str(client_id))
        os.makedirs(client_folder, exist_ok=True)

        file_path = os.path.join(client_folder, unique_filename)
        file.save(file_path)
        file_size = os.path.getsize(file_path)
        file_ext = filename.rsplit(".", 1)[1].lower() if "." in filename else "unknown"

        upload = ClientUpload(
            client_id=int(client_id),
            case_id=(
                int(request.form.get("case_id"))
                if request.form.get("case_id")
                else None
            ),
            category=category,
            document_type=document_type,
            bureau=request.form.get("bureau"),
            dispute_round=(
                int(request.form.get("dispute_round"))
                if request.form.get("dispute_round")
                else None
            ),
            response_type=request.form.get("response_type"),
            sender_name=request.form.get("sender_name"),
            account_number=request.form.get("account_number"),
            amount_claimed=(
                float(request.form.get("amount_claimed"))
                if request.form.get("amount_claimed")
                else None
            ),
            file_path=file_path,
            file_name=filename,
            file_size=file_size,
            file_type=file_ext,
            notes=request.form.get("notes"),
            priority=request.form.get("priority", "normal"),
            requires_action=request.form.get("requires_action") == "true",
        )

        if request.form.get("document_date"):
            upload.document_date = datetime.strptime(
                request.form.get("document_date"), "%Y-%m-%d"
            ).date()
        if request.form.get("received_date"):
            upload.received_date = datetime.strptime(
                request.form.get("received_date"), "%Y-%m-%d"
            ).date()
        if request.form.get("action_deadline"):
            upload.action_deadline = datetime.strptime(
                request.form.get("action_deadline"), "%Y-%m-%d"
            ).date()

        db.add(upload)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Document uploaded successfully",
                "upload_id": upload.id,
                "file_path": file_path,
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client/<int:client_id>/uploads", methods=["GET"])
def api_get_client_uploads(client_id):
    """Get all document uploads for a client"""
    db = get_db()
    try:
        category = request.args.get("category")

        query = db.query(ClientUpload).filter_by(client_id=client_id)
        if category:
            query = query.filter_by(category=category)

        uploads = query.order_by(ClientUpload.uploaded_at.desc()).all()

        uploads_data = [
            {
                "id": u.id,
                "category": u.category,
                "document_type": u.document_type,
                "bureau": u.bureau,
                "dispute_round": u.dispute_round,
                "response_type": u.response_type,
                "sender_name": u.sender_name,
                "account_number": u.account_number,
                "amount_claimed": u.amount_claimed,
                "file_name": u.file_name,
                "file_size": u.file_size,
                "file_type": u.file_type,
                "file_path": u.file_path,
                "document_date": (
                    u.document_date.isoformat() if u.document_date else None
                ),
                "received_date": (
                    u.received_date.isoformat() if u.received_date else None
                ),
                "uploaded_at": (
                    u.uploaded_at.strftime("%Y-%m-%d %H:%M") if u.uploaded_at else None
                ),
                "reviewed": u.reviewed,
                "reviewed_by": u.reviewed_by,
                "reviewed_at": (
                    u.reviewed_at.strftime("%Y-%m-%d %H:%M") if u.reviewed_at else None
                ),
                "notes": u.notes,
                "requires_action": u.requires_action,
                "action_deadline": (
                    u.action_deadline.isoformat() if u.action_deadline else None
                ),
                "priority": u.priority,
            }
            for u in uploads
        ]

        return jsonify({"success": True, "uploads": uploads_data})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/upload/<int:upload_id>/review", methods=["POST"])
def api_review_upload(upload_id):
    """Mark document as reviewed"""
    db = get_db()
    try:
        data = request.json or {}

        upload = db.query(ClientUpload).filter_by(id=upload_id).first()
        if not upload:
            return jsonify({"success": False, "error": "Upload not found"}), 404

        upload.reviewed = True
        upload.reviewed_by = data.get("reviewed_by", "Admin")
        upload.reviewed_at = datetime.utcnow()

        if "notes" in data:
            upload.notes = data["notes"]
        if "requires_action" in data:
            upload.requires_action = data["requires_action"]
        if "priority" in data:
            upload.priority = data["priority"]
        if data.get("action_deadline"):
            upload.action_deadline = datetime.strptime(
                data["action_deadline"], "%Y-%m-%d"
            ).date()

        db.commit()

        return jsonify({"success": True, "message": "Document marked as reviewed"})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/upload/<int:upload_id>", methods=["DELETE"])
def api_delete_upload(upload_id):
    """Delete an uploaded document"""
    db = get_db()
    try:
        upload = db.query(ClientUpload).filter_by(id=upload_id).first()
        if not upload:
            return jsonify({"success": False, "error": "Upload not found"}), 404

        if upload.file_path and os.path.exists(upload.file_path):
            os.remove(upload.file_path)

        db.delete(upload)
        db.commit()

        return jsonify({"success": True, "message": "Document deleted"})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/documents")
@require_staff(roles=["admin", "paralegal", "attorney"])
def dashboard_documents():
    """Admin view of all client document uploads"""
    db = get_db()
    try:
        status_filter = request.args.get("status", "pending")
        category_filter = request.args.get("category", "all")

        query = db.query(ClientUpload, Client).join(
            Client, ClientUpload.client_id == Client.id
        )

        if status_filter == "pending":
            query = query.filter(ClientUpload.reviewed == False)
        elif status_filter == "reviewed":
            query = query.filter(ClientUpload.reviewed == True)
        elif status_filter == "urgent":
            query = query.filter(ClientUpload.priority == "urgent")
        elif status_filter == "action":
            query = query.filter(ClientUpload.requires_action == True)

        if category_filter != "all":
            query = query.filter(ClientUpload.category == category_filter)

        results = query.order_by(ClientUpload.uploaded_at.desc()).limit(100).all()

        uploads = [
            {
                "id": u.id,
                "client_id": u.client_id,
                "client_name": c.name,
                "category": u.category,
                "document_type": u.document_type,
                "bureau": u.bureau,
                "sender_name": u.sender_name,
                "file_name": u.file_name,
                "file_path": u.file_path,
                "uploaded_at": u.uploaded_at,
                "reviewed": u.reviewed,
                "requires_action": u.requires_action,
                "priority": u.priority,
                "action_deadline": u.action_deadline,
            }
            for u, c in results
        ]

        pending_count = (
            db.query(ClientUpload).filter(ClientUpload.reviewed == False).count()
        )
        urgent_count = (
            db.query(ClientUpload).filter(ClientUpload.priority == "urgent").count()
        )
        action_count = (
            db.query(ClientUpload).filter(ClientUpload.requires_action == True).count()
        )

        return render_template(
            "documents.html",
            uploads=uploads,
            status_filter=status_filter,
            category_filter=category_filter,
            pending_count=pending_count,
            urgent_count=urgent_count,
            action_count=action_count,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return render_template(
            "documents.html",
            uploads=[],
            status_filter="pending",
            category_filter="all",
            pending_count=0,
            urgent_count=0,
            action_count=0,
        )
    finally:
        db.close()


@app.route("/api/portal/<token>/upload", methods=["POST"])
def api_portal_upload(token):
    """Handle document upload from client portal"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(portal_token=token).first()
        if not client:
            return jsonify({"success": False, "error": "Invalid portal token"}), 404

        if "file" not in request.files:
            return jsonify({"success": False, "error": "No file uploaded"}), 400

        file = request.files["file"]
        if file.filename == "":
            return jsonify({"success": False, "error": "No file selected"}), 400

        if not allowed_file(file.filename):
            return jsonify({"success": False, "error": "File type not allowed"}), 400

        category = request.form.get("category", "other")
        document_type = request.form.get("document_type", "misc")

        filename = secure_filename(file.filename)
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        unique_filename = f"{client.id}_{timestamp}_{filename}"

        client_folder = os.path.join(UPLOAD_FOLDER, str(client.id))
        os.makedirs(client_folder, exist_ok=True)

        file_path = os.path.join(client_folder, unique_filename)
        file.save(file_path)
        file_size = os.path.getsize(file_path)
        file_ext = filename.rsplit(".", 1)[1].lower() if "." in filename else "unknown"

        upload = ClientUpload(
            client_id=client.id,
            category=category,
            document_type=document_type,
            bureau=request.form.get("bureau"),
            dispute_round=(
                int(request.form.get("dispute_round"))
                if request.form.get("dispute_round")
                else None
            ),
            response_type=(
                document_type
                if category == "cra_response"
                else request.form.get("response_type")
            ),
            sender_name=request.form.get("sender_name"),
            account_number=request.form.get("account_number"),
            amount_claimed=(
                float(request.form.get("amount_claimed"))
                if request.form.get("amount_claimed")
                else None
            ),
            file_path=file_path,
            file_name=filename,
            file_size=file_size,
            file_type=file_ext,
            notes=request.form.get("notes"),
            priority=(
                "high"
                if category == "legal"
                else request.form.get("priority", "normal")
            ),
            requires_action=category == "legal",
        )

        if request.form.get("document_date"):
            upload.document_date = datetime.strptime(
                request.form.get("document_date"), "%Y-%m-%d"
            ).date()
        if request.form.get("received_date"):
            upload.received_date = datetime.strptime(
                request.form.get("received_date"), "%Y-%m-%d"
            ).date()
        if request.form.get("action_deadline"):
            upload.action_deadline = datetime.strptime(
                request.form.get("action_deadline"), "%Y-%m-%d"
            ).date()

        db.add(upload)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Document uploaded successfully",
                "upload_id": upload.id,
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/<token>/uploads", methods=["GET"])
def api_portal_get_uploads(token):
    """Get uploaded documents for client portal"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(portal_token=token).first()
        if not client:
            return jsonify({"success": False, "error": "Invalid portal token"}), 404

        uploads = (
            db.query(ClientUpload)
            .filter_by(client_id=client.id)
            .order_by(ClientUpload.uploaded_at.desc())
            .all()
        )

        uploads_data = [
            {
                "id": u.id,
                "category": u.category,
                "document_type": u.document_type,
                "file_name": u.file_name,
                "file_type": u.file_type,
                "uploaded_at": (
                    u.uploaded_at.strftime("%Y-%m-%d %H:%M") if u.uploaded_at else None
                ),
                "reviewed": u.reviewed,
                "notes": u.notes,
            }
            for u in uploads
        ]

        return jsonify({"success": True, "uploads": uploads_data})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/<token>/avatar", methods=["POST"])
def api_portal_upload_avatar(token):
    """Upload avatar image for client"""
    MAX_AVATAR_SIZE = 5 * 1024 * 1024
    ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif", "webp"}
    ALLOWED_MIMETYPES = {"image/png", "image/jpeg", "image/gif", "image/webp"}

    db = get_db()
    try:
        client = db.query(Client).filter_by(portal_token=token).first()
        if not client:
            return jsonify({"success": False, "error": "Invalid portal token"}), 404

        if "avatar" not in request.files:
            return jsonify({"success": False, "error": "No image uploaded"}), 400

        file = request.files["avatar"]
        if file.filename == "":
            return jsonify({"success": False, "error": "No file selected"}), 400

        file.seek(0, os.SEEK_END)
        file_size = file.tell()
        file.seek(0)
        if file_size > MAX_AVATAR_SIZE:
            return (
                jsonify({"success": False, "error": "Image too large (max 5MB)"}),
                400,
            )

        ext = file.filename.rsplit(".", 1)[1].lower() if "." in file.filename else ""
        if ext not in ALLOWED_EXTENSIONS:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Only image files allowed (png, jpg, jpeg, gif, webp)",
                    }
                ),
                400,
            )

        if file.mimetype not in ALLOWED_MIMETYPES:
            return jsonify({"success": False, "error": "Invalid image type"}), 400

        if client.avatar_filename:
            old_path = os.path.join(
                "static", "avatars", secure_filename(client.avatar_filename)
            )
            if os.path.exists(old_path):
                os.remove(old_path)

        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        safe_filename = secure_filename(f"client_{client.id}_{timestamp}.{ext}")
        avatar_path = os.path.join("static", "avatars", safe_filename)

        os.makedirs(os.path.join("static", "avatars"), exist_ok=True)
        file.save(avatar_path)

        client.avatar_filename = safe_filename
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Avatar uploaded successfully",
                "avatar_url": f"/static/avatars/{safe_filename}",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/<token>/avatar", methods=["DELETE"])
def api_portal_delete_avatar(token):
    """Delete client avatar"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(portal_token=token).first()
        if not client:
            return jsonify({"success": False, "error": "Invalid portal token"}), 404

        if client.avatar_filename:
            old_path = os.path.join("static", "avatars", client.avatar_filename)
            if os.path.exists(old_path):
                os.remove(old_path)
            client.avatar_filename = None
            db.commit()

        return jsonify({"success": True, "message": "Avatar removed"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client/<int:client_id>/avatar", methods=["POST"])
def api_admin_upload_avatar(client_id):
    """Admin upload avatar for client"""
    MAX_AVATAR_SIZE = 5 * 1024 * 1024
    ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif", "webp"}
    ALLOWED_MIMETYPES = {"image/png", "image/jpeg", "image/gif", "image/webp"}

    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if "avatar" not in request.files:
            return jsonify({"success": False, "error": "No image uploaded"}), 400

        file = request.files["avatar"]
        if file.filename == "":
            return jsonify({"success": False, "error": "No file selected"}), 400

        file.seek(0, os.SEEK_END)
        file_size = file.tell()
        file.seek(0)
        if file_size > MAX_AVATAR_SIZE:
            return (
                jsonify({"success": False, "error": "Image too large (max 5MB)"}),
                400,
            )

        ext = file.filename.rsplit(".", 1)[1].lower() if "." in file.filename else ""
        if ext not in ALLOWED_EXTENSIONS:
            return jsonify({"success": False, "error": "Only image files allowed"}), 400

        if file.mimetype not in ALLOWED_MIMETYPES:
            return jsonify({"success": False, "error": "Invalid image type"}), 400

        if client.avatar_filename:
            old_path = os.path.join(
                "static", "avatars", secure_filename(client.avatar_filename)
            )
            if os.path.exists(old_path):
                os.remove(old_path)

        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        safe_filename = secure_filename(f"client_{client.id}_{timestamp}.{ext}")
        avatar_path = os.path.join("static", "avatars", safe_filename)

        os.makedirs(os.path.join("static", "avatars"), exist_ok=True)
        file.save(avatar_path)

        client.avatar_filename = safe_filename
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Avatar uploaded successfully",
                "avatar_url": f"/static/avatars/{safe_filename}",
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlement/client/<int:client_id>", methods=["GET"])
def api_get_client_settlements(client_id):
    """Get all settlement estimates for a client"""
    db = get_db()
    try:
        from database import SettlementEstimate

        estimates = (
            db.query(SettlementEstimate)
            .filter_by(client_id=client_id)
            .order_by(SettlementEstimate.created_at.desc())
            .all()
        )

        estimates_data = [
            {
                "id": e.id,
                "case_id": e.case_id,
                "total_violations": e.total_violations,
                "willful_violations": e.willful_violations,
                "total_low": e.total_low,
                "total_high": e.total_high,
                "settlement_likelihood": e.settlement_likelihood,
                "recommended_demand": e.recommended_demand,
                "created_at": e.created_at.isoformat() if e.created_at else None,
            }
            for e in estimates
        ]

        return jsonify({"success": True, "estimates": estimates_data})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# CLIENT DISPUTE TIMELINE API
# ==============================================================================


@app.route("/api/client/<int:client_id>/timeline", methods=["GET"])
def api_client_timeline(client_id):
    """Get complete dispute timeline for a client - merges data from multiple sources"""
    db = get_db()
    try:
        from datetime import date as date_type

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        events = []

        # 1. Client creation / round started events
        if client.created_at:
            events.append(
                {
                    "type": "milestone",
                    "event_type": "client_created",
                    "date": client.created_at.isoformat(),
                    "date_display": client.created_at.strftime("%b %d, %Y"),
                    "bureau": None,
                    "description": "Case opened",
                    "details": f"Client {client.name} enrolled in credit repair program",
                    "round": 0,
                    "icon": "üéØ",
                    "color": "gray",
                }
            )

        if client.round_started_at:
            events.append(
                {
                    "type": "milestone",
                    "event_type": "round_started",
                    "date": client.round_started_at.isoformat(),
                    "date_display": client.round_started_at.strftime("%b %d, %Y"),
                    "bureau": None,
                    "description": f"Round {client.current_dispute_round or 1} started",
                    "details": "Dispute round initiated",
                    "round": client.current_dispute_round or 1,
                    "icon": "üîÑ",
                    "color": "gray",
                }
            )

        # 2. Dispute Letters sent
        letters = db.query(DisputeLetter).filter_by(client_id=client_id).all()
        for letter in letters:
            letter_date = letter.sent_at or letter.created_at
            if letter_date:
                events.append(
                    {
                        "type": "dispute_sent",
                        "event_type": "letter_sent",
                        "date": letter_date.isoformat(),
                        "date_display": letter_date.strftime("%b %d, %Y"),
                        "bureau": letter.bureau,
                        "description": f"Dispute letter sent to {letter.bureau}",
                        "details": f"Round {letter.round_number} dispute letter generated and sent",
                        "round": letter.round_number or 1,
                        "icon": "üì§",
                        "color": "blue",
                        "file_path": letter.file_path,
                    }
                )

        # 3. CRA Responses received
        responses = db.query(CRAResponse).filter_by(client_id=client_id).all()
        for resp in responses:
            resp_date = resp.received_date or resp.response_date or resp.created_at
            if resp_date:
                if isinstance(resp_date, date_type) and not isinstance(
                    resp_date, datetime
                ):
                    resp_date = datetime.combine(resp_date, datetime.min.time())

                response_desc = f"{resp.bureau} responded"
                if resp.response_type:
                    response_desc = (
                        f'{resp.bureau}: {resp.response_type.replace("_", " ").title()}'
                    )

                details_parts = []
                if resp.items_verified:
                    details_parts.append(f"{resp.items_verified} items verified")
                if resp.items_deleted:
                    details_parts.append(f"{resp.items_deleted} items deleted")
                if resp.items_updated:
                    details_parts.append(f"{resp.items_updated} items updated")

                events.append(
                    {
                        "type": "response_received",
                        "event_type": "cra_response",
                        "date": resp_date.isoformat(),
                        "date_display": resp_date.strftime("%b %d, %Y"),
                        "bureau": resp.bureau,
                        "description": response_desc,
                        "details": (
                            ", ".join(details_parts)
                            if details_parts
                            else f"Response from {resp.bureau}"
                        ),
                        "round": resp.dispute_round or 1,
                        "icon": "üì¨",
                        "color": "orange",
                        "response_type": resp.response_type,
                    }
                )

        # 4. Dispute Items with status changes (deleted/updated items)
        items = db.query(DisputeItem).filter_by(client_id=client_id).all()
        for item in items:
            if item.status in ["deleted", "updated", "positive"]:
                item_date = item.response_date or item.updated_at or item.created_at
                if item_date:
                    if isinstance(item_date, date_type) and not isinstance(
                        item_date, datetime
                    ):
                        item_date = datetime.combine(item_date, datetime.min.time())

                    if item.status == "deleted":
                        events.append(
                            {
                                "type": "item_resolved",
                                "event_type": "item_deleted",
                                "date": item_date.isoformat(),
                                "date_display": item_date.strftime("%b %d, %Y"),
                                "bureau": item.bureau,
                                "description": f"Item deleted from {item.bureau}",
                                "details": f'{item.creditor_name or "Account"} ({item.item_type or "item"}) removed',
                                "round": item.dispute_round or 1,
                                "icon": "‚úÖ",
                                "color": "green",
                                "creditor": item.creditor_name,
                            }
                        )
                    elif item.status == "updated":
                        events.append(
                            {
                                "type": "item_updated",
                                "event_type": "item_updated",
                                "date": item_date.isoformat(),
                                "date_display": item_date.strftime("%b %d, %Y"),
                                "bureau": item.bureau,
                                "description": f"Item updated on {item.bureau}",
                                "details": f'{item.creditor_name or "Account"} information corrected',
                                "round": item.dispute_round or 1,
                                "icon": "üìù",
                                "color": "green",
                                "creditor": item.creditor_name,
                            }
                        )

            # Track when items were sent for dispute
            if item.sent_date:
                sent_date = item.sent_date
                if isinstance(sent_date, date_type) and not isinstance(
                    sent_date, datetime
                ):
                    sent_date = datetime.combine(sent_date, datetime.min.time())

                events.append(
                    {
                        "type": "dispute_sent",
                        "event_type": "item_disputed",
                        "date": sent_date.isoformat(),
                        "date_display": sent_date.strftime("%b %d, %Y"),
                        "bureau": item.bureau,
                        "description": f"Item disputed with {item.bureau}",
                        "details": f'{item.creditor_name or "Account"} ({item.item_type or "item"}) disputed',
                        "round": item.dispute_round or 1,
                        "icon": "üìã",
                        "color": "blue",
                        "creditor": item.creditor_name,
                    }
                )

        # 5. Deadlines (due and overdue)
        deadlines = db.query(CaseDeadline).filter_by(client_id=client_id).all()
        today = datetime.utcnow().date()
        for deadline in deadlines:
            if deadline.deadline_date:
                deadline_dt = deadline.deadline_date
                if isinstance(deadline_dt, date_type) and not isinstance(
                    deadline_dt, datetime
                ):
                    deadline_dt = datetime.combine(deadline_dt, datetime.min.time())

                is_overdue = (
                    deadline.deadline_date < today and deadline.status != "completed"
                )

                if is_overdue:
                    events.append(
                        {
                            "type": "overdue",
                            "event_type": "deadline_overdue",
                            "date": deadline_dt.isoformat(),
                            "date_display": deadline_dt.strftime("%b %d, %Y"),
                            "bureau": deadline.bureau,
                            "description": f'OVERDUE: {deadline.deadline_type.replace("_", " ").title()}',
                            "details": f'{deadline.bureau or "Bureau"} response deadline passed',
                            "round": deadline.dispute_round or 1,
                            "icon": "‚ö†Ô∏è",
                            "color": "red",
                            "days_overdue": (today - deadline.deadline_date).days,
                        }
                    )
                elif deadline.status == "completed":
                    events.append(
                        {
                            "type": "milestone",
                            "event_type": "deadline_met",
                            "date": deadline_dt.isoformat(),
                            "date_display": deadline_dt.strftime("%b %d, %Y"),
                            "bureau": deadline.bureau,
                            "description": f'Deadline met: {deadline.deadline_type.replace("_", " ").title()}',
                            "details": "Response received within required timeframe",
                            "round": deadline.dispute_round or 1,
                            "icon": "‚úì",
                            "color": "gray",
                        }
                    )
                else:
                    # Upcoming deadline
                    days_until = (deadline.deadline_date - today).days
                    if days_until <= 7:
                        events.append(
                            {
                                "type": "deadline_upcoming",
                                "event_type": "deadline_upcoming",
                                "date": deadline_dt.isoformat(),
                                "date_display": deadline_dt.strftime("%b %d, %Y"),
                                "bureau": deadline.bureau,
                                "description": f'Deadline in {days_until} days: {deadline.deadline_type.replace("_", " ").title()}',
                                "details": f'{deadline.bureau or "Bureau"} must respond by this date',
                                "round": deadline.dispute_round or 1,
                                "icon": "‚è∞",
                                "color": "orange",
                                "days_until": days_until,
                            }
                        )

        # Sort events by date (newest first for display, but we'll return both orders)
        events.sort(key=lambda x: x["date"], reverse=True)

        # Calculate summary stats
        summary = {
            "total_events": len(events),
            "letters_sent": len(
                [e for e in events if e["event_type"] == "letter_sent"]
            ),
            "responses_received": len(
                [e for e in events if e["event_type"] == "cra_response"]
            ),
            "items_deleted": len(
                [e for e in events if e["event_type"] == "item_deleted"]
            ),
            "items_updated": len(
                [e for e in events if e["event_type"] == "item_updated"]
            ),
            "overdue_deadlines": len(
                [e for e in events if e["event_type"] == "deadline_overdue"]
            ),
            "current_round": client.current_dispute_round or 1,
        }

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "client_name": client.name,
                "events": events,
                "summary": summary,
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# DEADLINE TRACKING API
# ==============================================================================


@app.route("/api/deadlines/create", methods=["POST"])
def api_create_deadline():
    """Create a new deadline for tracking"""
    db = get_db()
    try:
        data = request.json or {}
        client_id = data.get("client_id")

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400

        deadline_type = data.get("deadline_type", "cra_response")
        bureau = data.get("bureau")
        dispute_round = data.get("dispute_round")
        start_date = data.get("start_date")
        days_allowed = data.get("days_allowed", 30)

        if start_date:
            start_date = datetime.strptime(start_date, "%Y-%m-%d").date()
        else:
            start_date = datetime.utcnow().date()

        from services.deadline_service import create_deadline

        deadline = create_deadline(
            db,
            client_id,
            data.get("case_id"),
            deadline_type,
            bureau,
            dispute_round,
            start_date,
            days_allowed,
        )

        return jsonify(
            {
                "success": True,
                "deadline_id": deadline.id,
                "deadline_date": deadline.deadline_date.isoformat(),
                "message": f"Deadline created for {deadline.deadline_date}",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/deadlines/client/<int:client_id>", methods=["GET"])
def api_get_client_deadlines(client_id):
    """Get all deadlines for a client"""
    db = get_db()
    try:
        include_completed = (
            request.args.get("include_completed", "false").lower() == "true"
        )

        from services.deadline_service import get_client_deadlines

        deadlines = get_client_deadlines(db, client_id, include_completed)

        return jsonify({"success": True, "deadlines": deadlines})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/deadlines/check-reminders", methods=["POST"])
def api_check_deadline_reminders():
    """Check and send deadline reminders (for scheduled task)"""
    db = get_db()
    try:
        from services.deadline_service import check_and_send_reminders

        stats = check_and_send_reminders(db)

        return jsonify(
            {
                "success": True,
                "reminders_sent": stats.get("reminders_sent", 0),
                "overdue_notices_sent": stats.get("overdue_notices_sent", 0),
                "message": "Deadline reminders checked",
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# NOTARIZATION API (Proof.com Integration)
# ==============================================================================


@app.route("/api/notarization/create", methods=["POST"])
def api_create_notarization():
    """Create a new notarization order via Proof.com"""
    try:
        data = request.json or {}
        client_id = data.get("client_id")
        document_path = data.get("document_path")
        document_name = data.get("document_name", "Document")
        signer_email = data.get("signer_email")
        signer_name = data.get("signer_name")

        if not all([client_id, document_path, signer_email, signer_name]):
            return jsonify({"success": False, "error": "Missing required fields"}), 400

        from services.notarization_service import (
            create_notarization_order,
            is_proof_configured,
        )

        if not is_proof_configured():
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Proof.com API not configured. Please add PROOF_API_KEY.",
                    }
                ),
                400,
            )

        result = create_notarization_order(
            client_id, document_path, document_name, signer_email, signer_name
        )

        return jsonify(
            {
                "success": True,
                "order_id": result["order_id"],
                "session_link": result["session_link"],
                "message": "Notarization order created. Client will receive an email to complete the session.",
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/notarization/<int:order_id>/status", methods=["GET"])
def api_get_notarization_status(order_id):
    """Check status of a notarization order"""
    try:
        from services.notarization_service import get_notarization_status

        result = get_notarization_status(order_id)

        if result:
            return jsonify(
                {"success": True, "status": result["status"], "details": result}
            )
        else:
            return jsonify({"success": False, "error": "Order not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/notarization/client/<int:client_id>", methods=["GET"])
def api_get_client_notarizations(client_id):
    """Get all notarization orders for a client"""
    try:
        from services.notarization_service import get_orders_by_client

        orders = get_orders_by_client(client_id)

        orders_data = [
            {
                "id": o["id"],
                "document_name": o["document_name"],
                "status": o["status"],
                "session_link": o["session_link"],
                "notarized_at": o["notarized_at"],
                "created_at": o["created_at"],
            }
            for o in orders
        ]

        return jsonify({"success": True, "orders": orders_data})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/notarization/webhook", methods=["POST"])
def api_notarization_webhook():
    """Handle Proof.com webhook callbacks"""
    try:
        webhook_data = request.json

        from services.notarization_service import handle_webhook

        result = handle_webhook(webhook_data)

        return jsonify({"success": True})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


# ==============================================================================
# NOTARIZE.COM API (Class-based NotarizeService Integration)
# ==============================================================================


@app.route("/api/notarize/create", methods=["POST"])
@require_staff()
def api_notarize_create_transaction():
    """
    Create a new notarization transaction for a client document.

    Request JSON:
        - client_id: int (required)
        - document_url: str (required) - URL to the document to be notarized
        - signer_email: str (optional) - defaults to client email
        - signer_first_name: str (optional) - defaults to client first_name
        - signer_last_name: str (optional) - defaults to client last_name
        - document_name: str (optional)
        - requirement: str (optional) - 'notarization', 'esignature', or 'witness'

    Returns:
        - success: bool
        - transaction_id: str - External Notarize.com transaction ID
        - access_link: str - URL for signer to access notarization session
        - internal_id: int - Internal database record ID
    """
    db = get_db()
    try:
        data = request.json or {}
        client_id = data.get("client_id")
        document_url = data.get("document_url")

        if not client_id:
            return jsonify({"success": False, "error": "client_id is required"}), 400

        if not document_url:
            return jsonify({"success": False, "error": "document_url is required"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        signer_email = data.get("signer_email") or client.email
        signer_first_name = (
            data.get("signer_first_name") or client.first_name or client.name.split()[0]
        )
        signer_last_name = (
            data.get("signer_last_name")
            or client.last_name
            or (client.name.split()[-1] if len(client.name.split()) > 1 else "")
        )
        document_name = data.get("document_name", "Document for Notarization")
        requirement = data.get("requirement", "notarization")

        if not signer_email:
            return jsonify({"success": False, "error": "Signer email is required"}), 400

        from services.notarize_service import get_notarize_service

        service = get_notarize_service()

        if not service.is_configured:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Notarize.com API key not configured. Set NOTARIZE_API_KEY environment variable.",
                    }
                ),
                503,
            )

        result = service.create_transaction(
            signer_email=signer_email,
            signer_first_name=signer_first_name,
            signer_last_name=signer_last_name,
            document_url=document_url,
            requirement=requirement,
            client_id=client_id,
            document_name=document_name,
        )

        if not result["success"]:
            return jsonify(result), 500

        return jsonify(
            {
                "success": True,
                "transaction_id": result["transaction_id"],
                "access_link": result["access_link"],
                "internal_id": result["internal_id"],
                "message": "Notarization transaction created. Signer will receive an email to complete the session.",
            }
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/notarize/<int:transaction_id>/status", methods=["GET"])
@require_staff()
def api_notarize_get_status(transaction_id):
    """
    Get the current status of a notarization transaction.

    Args:
        transaction_id: Internal database transaction ID

    Returns:
        - success: bool
        - status: str - Current transaction status
        - events: list - Status change events
        - transaction_data: dict - Full API response data
    """
    try:
        from services.notarize_service import get_notarize_service

        service = get_notarize_service()

        if not service.is_configured:
            db = get_db()
            try:
                transaction = (
                    db.query(NotarizeTransaction).filter_by(id=transaction_id).first()
                )
                if not transaction:
                    return (
                        jsonify({"success": False, "error": "Transaction not found"}),
                        404,
                    )

                return jsonify(
                    {
                        "success": True,
                        "status": transaction.status,
                        "events": transaction.webhook_events or [],
                        "transaction_data": None,
                        "internal_id": transaction.id,
                        "note": "API key not configured - showing cached status only",
                    }
                )
            finally:
                db.close()

        result = service.get_transaction_status(transaction_id)

        if (
            not result["success"]
            and result.get("error", "").startswith("Transaction")
            and "not found" in result.get("error", "")
        ):
            return jsonify(result), 404

        return jsonify(result)

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/notarize/<int:transaction_id>/download", methods=["GET"])
@require_staff()
def api_notarize_download_document(transaction_id):
    """
    Download the completed notarized document.

    Args:
        transaction_id: Internal database transaction ID

    Returns:
        PDF file or error JSON
    """
    try:
        from services.notarize_service import get_notarize_service

        service = get_notarize_service()

        if not service.is_configured:
            return (
                jsonify(
                    {"success": False, "error": "Notarize.com API key not configured"}
                ),
                503,
            )

        result = service.download_completed_document(transaction_id)

        if isinstance(result, dict) and not result.get("success"):
            status_code = 400
            if "not completed" in result.get("error", "").lower():
                status_code = 400
            elif "not found" in result.get("error", "").lower():
                status_code = 404
            return jsonify(result), status_code

        if isinstance(result, bytes):
            db = get_db()
            try:
                transaction = (
                    db.query(NotarizeTransaction).filter_by(id=transaction_id).first()
                )
                filename = f"notarized_document_{transaction_id}.pdf"
                if transaction and transaction.document_name:
                    safe_name = "".join(
                        c
                        for c in transaction.document_name
                        if c.isalnum() or c in (" ", "_", "-")
                    ).strip()
                    safe_name = safe_name.replace(" ", "_")[:50]
                    filename = f"{safe_name}_notarized.pdf"
            finally:
                db.close()

            return send_file(
                io.BytesIO(result),
                mimetype="application/pdf",
                as_attachment=True,
                download_name=filename,
            )

        return (
            jsonify({"success": False, "error": "Unexpected response from download"}),
            500,
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/webhooks/notarize", methods=["POST"])
def webhooks_notarize():
    """
    Handle Notarize.com webhook callbacks.

    This endpoint receives notifications about transaction status changes
    from Notarize.com and updates the local database accordingly.
    """
    try:
        raw_payload = request.get_data()
        signature = request.headers.get("X-Notarize-Signature") or request.headers.get(
            "X-Webhook-Signature"
        )
        webhook_data = request.json

        if not webhook_data:
            return jsonify({"success": False, "error": "No webhook data received"}), 400

        from services.notarize_service import get_notarize_service

        service = get_notarize_service()

        result = service.handle_webhook(
            webhook_data=webhook_data, raw_payload=raw_payload, signature=signature
        )

        if not result["success"] and "signature" in result.get("error", "").lower():
            return jsonify(result), 401

        if not result["success"]:
            return jsonify(result), 400

        return jsonify(
            {
                "success": True,
                "internal_id": result.get("internal_id"),
                "action_taken": result.get("action_taken"),
            }
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/notarize/test-connection", methods=["GET"])
@require_staff(["admin"])
def api_notarize_test_connection():
    """Test connection to Notarize.com API (admin only)"""
    try:
        from services.notarize_service import (
            get_notarize_service,
            is_notarize_configured,
        )

        if not is_notarize_configured():
            return jsonify(
                {
                    "success": False,
                    "configured": False,
                    "connected": False,
                    "error": "Notarize.com API key not configured. Set NOTARIZE_API_KEY environment variable.",
                }
            )

        service = get_notarize_service()
        connected = service.test_connection()

        return jsonify(
            {
                "success": True,
                "configured": True,
                "connected": connected,
                "sandbox": service.sandbox,
                "message": (
                    "Connection successful" if connected else "Connection failed"
                ),
            }
        )

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/notarize/client/<int:client_id>", methods=["GET"])
@require_staff()
def api_notarize_client_transactions(client_id):
    """Get all notarize transactions for a client"""
    db = get_db()
    try:
        transactions = (
            db.query(NotarizeTransaction)
            .filter_by(client_id=client_id)
            .order_by(NotarizeTransaction.created_at.desc())
            .all()
        )

        transactions_data = [
            {
                "id": t.id,
                "external_transaction_id": t.external_transaction_id,
                "document_name": t.document_name,
                "status": t.status,
                "access_link": t.access_link,
                "signer_email": t.signer_email,
                "signer_name": t.signer_name,
                "completed_at": t.completed_at.isoformat() if t.completed_at else None,
                "created_at": t.created_at.isoformat() if t.created_at else None,
            }
            for t in transactions
        ]

        return jsonify({"success": True, "transactions": transactions_data})

    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# CERTIFIED MAIL API (SendCertifiedMail.com Integration)
# ==============================================================================


@app.route("/api/certified-mail/send", methods=["POST"])
def api_send_certified_mail():
    """Send a document via certified mail"""
    try:
        data = request.json or {}
        client_id = data.get("client_id")
        recipient_name = data.get("recipient_name")
        recipient_address = data.get("recipient_address")
        document_path = data.get("document_path")
        letter_type = data.get("letter_type", "dispute")
        bureau = data.get("bureau")
        dispute_round = data.get("dispute_round")

        if not all([client_id, recipient_name, recipient_address, document_path]):
            return jsonify({"success": False, "error": "Missing required fields"}), 400

        from services.certified_mail_service import (
            is_certified_mail_configured,
            send_certified_letter,
        )

        result = send_certified_letter(
            client_id,
            recipient_name,
            recipient_address,
            document_path,
            letter_type,
            bureau,
            dispute_round,
        )

        if not result.get("success"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": result.get("error", "Failed to send letter"),
                    }
                ),
                400,
            )

        # Fire dispute_sent trigger for automation
        if bureau and dispute_round:
            try:
                client = db.query(Client).filter(Client.id == client_id).first()
                if client:
                    WorkflowTriggersService.evaluate_triggers(
                        "dispute_sent",
                        {
                            "client_id": client_id,
                            "client_name": client.name,
                            "bureau": bureau,
                            "round_number": dispute_round,
                            "tracking_number": result.get("tracking_number"),
                        },
                    )
            except Exception as trigger_error:
                print(f"‚ö†Ô∏è  Workflow trigger error (non-fatal): {trigger_error}")

        return jsonify(
            {
                "success": True,
                "order_id": result["order_id"],
                "tracking_number": result["tracking_number"],
                "cost": result.get("estimated_cost"),
                "mock_mode": not is_certified_mail_configured(),
                "message": "Certified mail order created",
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/certified-mail/<int:order_id>/status", methods=["GET"])
def api_get_certified_mail_status(order_id):
    """Check status of a certified mail order"""
    try:
        from services.certified_mail_service import check_delivery_status

        result = check_delivery_status(order_id)

        if result:
            return jsonify(
                {"success": True, "status": result["status"], "details": result}
            )
        else:
            return jsonify({"success": False, "error": "Order not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/certified-mail/client/<int:client_id>", methods=["GET"])
def api_get_client_certified_mail(client_id):
    """Get all certified mail orders for a client"""
    try:
        from services.certified_mail_service import get_orders_by_client

        orders = get_orders_by_client(client_id)

        return jsonify({"success": True, "orders": orders})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/certified-mail/cost", methods=["GET"])
def api_get_certified_mail_cost():
    """Get estimated cost for certified mail"""
    try:
        pages = int(request.args.get("pages", 1))
        mail_class = request.args.get("class", "certified")

        from services.certified_mail_service import get_mailing_cost

        cost = get_mailing_cost(pages, mail_class)

        return jsonify({"success": True, "cost": cost})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/certified-mail/webhook", methods=["POST"])
def api_certified_mail_webhook():
    """Handle SendCertifiedMail.com webhook callbacks"""
    try:
        webhook_data = request.json

        from services.certified_mail_service import handle_webhook

        result = handle_webhook(webhook_data)

        return jsonify({"success": True})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


# ==============================================================================
# OCR / DOCUMENT EXTRACTION API
# ==============================================================================


@app.route("/api/ocr/extract-cra-response", methods=["POST"])
def api_extract_cra_response():
    """Extract data from a CRA response document using AI"""
    db = get_db()
    try:
        data = request.json or {}
        upload_id = data.get("upload_id")
        file_path = data.get("file_path")
        file_type = data.get("file_type", "pdf")
        bureau = data.get("bureau")

        if not upload_id and not file_path:
            return (
                jsonify({"success": False, "error": "upload_id or file_path required"}),
                400,
            )

        if upload_id:
            upload = db.query(ClientUpload).filter_by(id=upload_id).first()
            if not upload:
                return jsonify({"success": False, "error": "Upload not found"}), 404
            file_path = upload.file_path
            file_type = upload.file_type
            bureau = upload.bureau

        from services.ocr_service import (
            extract_cra_response_data,
            update_client_upload_ocr,
        )

        result = extract_cra_response_data(file_path, file_type, bureau)

        if upload_id and result.get("success"):
            update_client_upload_ocr(upload_id, result.get("data", {}))

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/ocr/analyze-collection-letter", methods=["POST"])
def api_analyze_collection_letter():
    """Analyze a collection letter for FDCPA violations"""
    db = get_db()
    try:
        data = request.json or {}
        upload_id = data.get("upload_id")
        file_path = data.get("file_path")
        file_type = data.get("file_type", "pdf")

        if not upload_id and not file_path:
            return (
                jsonify({"success": False, "error": "upload_id or file_path required"}),
                400,
            )

        if upload_id:
            upload = db.query(ClientUpload).filter_by(id=upload_id).first()
            if not upload:
                return jsonify({"success": False, "error": "Upload not found"}), 404
            file_path = upload.file_path
            file_type = upload.file_type

        from services.ocr_service import (
            analyze_collection_letter,
            update_client_upload_ocr,
        )

        result = analyze_collection_letter(file_path, file_type)

        if upload_id and result.get("success"):
            update_client_upload_ocr(upload_id, result.get("data", {}))

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/ocr/detect-violations", methods=["POST"])
def api_detect_fcra_violations():
    """Detect FCRA violations from document data"""
    try:
        data = request.json or {}
        document_data = data.get("document_data", {})
        document_type = data.get("document_type", "cra_response")

        if not document_data:
            return jsonify({"success": False, "error": "document_data required"}), 400

        from services.ocr_service import detect_fcra_violations

        result = detect_fcra_violations(document_data, document_type)

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ocr/process-upload/<int:upload_id>", methods=["POST"])
def api_process_upload_ocr(upload_id):
    """Process a client upload with AI extraction based on category"""
    db = get_db()
    try:
        upload = db.query(ClientUpload).filter_by(id=upload_id).first()
        if not upload:
            return jsonify({"success": False, "error": "Upload not found"}), 404

        category = upload.category

        from services.ocr_service import process_upload_for_ocr

        result = process_upload_for_ocr(upload_id, category)

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/ocr/batch-process", methods=["POST"])
def api_batch_process_ocr():
    """Batch process multiple uploads with AI extraction"""
    try:
        data = request.json or {}
        upload_ids = data.get("upload_ids", [])
        category = data.get("category", "cra_response")

        if not upload_ids:
            return jsonify({"success": False, "error": "upload_ids required"}), 400

        from services.ocr_service import batch_process_uploads

        result = batch_process_uploads(upload_ids, category)

        return jsonify(
            {
                "success": True,
                "processed": result.get("processed", 0),
                "failed": result.get("failed", 0),
                "results": result.get("results", []),
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


# ==============================================================================
# LIMITED POA MANAGEMENT API
# ==============================================================================


@app.route("/api/poa/generate", methods=["POST"])
def api_generate_poa():
    """Generate a Limited Power of Attorney document for a client"""
    db = get_db()
    try:
        data = request.json or {}
        client_id = data.get("client_id")

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400

        client = db.query(Client).filter_by(id=int(client_id)).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        from database import LimitedPOA

        poa = LimitedPOA(
            client_id=client.id,
            poa_type=data.get("poa_type", "credit_dispute"),
            effective_date=datetime.utcnow().date(),
            expiration_date=(datetime.utcnow() + timedelta(days=365)).date(),
            scope=data.get(
                "scope",
                {
                    "dispute_credit_reports": True,
                    "communicate_with_cras": True,
                    "request_credit_freezes": True,
                    "obtain_credit_reports": True,
                },
            ),
            status="draft",
        )

        db.add(poa)
        db.commit()

        return jsonify(
            {
                "success": True,
                "poa_id": poa.id,
                "message": "Limited POA created. Ready for signature and notarization.",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/poa/client/<int:client_id>", methods=["GET"])
def api_get_client_poa(client_id):
    """Get all Limited POA documents for a client"""
    db = get_db()
    try:
        from database import LimitedPOA

        poas = (
            db.query(LimitedPOA)
            .filter_by(client_id=client_id)
            .order_by(LimitedPOA.created_at.desc())
            .all()
        )

        poas_data = [
            {
                "id": p.id,
                "poa_type": p.poa_type,
                "status": p.status,
                "signed": p.signed,
                "signed_at": p.signed_at.isoformat() if p.signed_at else None,
                "notarized": p.notarized,
                "notarized_at": p.notarized_at.isoformat() if p.notarized_at else None,
                "effective_date": (
                    p.effective_date.isoformat() if p.effective_date else None
                ),
                "expiration_date": (
                    p.expiration_date.isoformat() if p.expiration_date else None
                ),
                "scope": p.scope,
                "created_at": p.created_at.isoformat() if p.created_at else None,
            }
            for p in poas
        ]

        return jsonify({"success": True, "poas": poas_data})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# ATTORNEY REFERRAL API
# ==============================================================================


@app.route("/api/attorney-referral/create", methods=["POST"])
def api_create_attorney_referral():
    """Create an attorney referral for a high-value case"""
    db = get_db()
    try:
        data = request.json or {}
        client_id = data.get("client_id")
        case_id = data.get("case_id")

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400

        from database import AttorneyReferral

        referral = AttorneyReferral(
            client_id=client_id,
            case_id=case_id,
            attorney_name=data.get("attorney_name"),
            attorney_firm=data.get("attorney_firm"),
            attorney_email=data.get("attorney_email"),
            attorney_phone=data.get("attorney_phone"),
            referral_reason=data.get("referral_reason"),
            case_summary=data.get("case_summary"),
            estimated_value=data.get("estimated_value"),
            fee_arrangement=data.get("fee_arrangement", "contingency"),
            referral_fee_percent=data.get("referral_fee_percent", 25.0),
            status="pending",
        )

        db.add(referral)
        db.commit()

        return jsonify(
            {
                "success": True,
                "referral_id": referral.id,
                "message": "Attorney referral created",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/attorney-referral/<int:referral_id>", methods=["PUT"])
def api_update_attorney_referral(referral_id):
    """Update attorney referral status and outcome"""
    db = get_db()
    try:
        data = request.json or {}

        from database import AttorneyReferral

        referral = db.query(AttorneyReferral).filter_by(id=referral_id).first()

        if not referral:
            return jsonify({"success": False, "error": "Referral not found"}), 404

        if "status" in data:
            referral.status = data["status"]
        if "attorney_accepted" in data:
            referral.attorney_accepted = data["attorney_accepted"]
            referral.attorney_response_at = datetime.utcnow()
        if "outcome" in data:
            referral.outcome = data["outcome"]
        if "settlement_amount" in data:
            referral.settlement_amount = data["settlement_amount"]
        if "referral_fee_received" in data:
            referral.referral_fee_received = data["referral_fee_received"]

        referral.updated_at = datetime.utcnow()
        db.commit()

        return jsonify({"success": True, "message": "Referral updated"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/attorney-referrals", methods=["GET"])
def api_list_attorney_referrals():
    """List all attorney referrals"""
    db = get_db()
    try:
        status_filter = request.args.get("status")

        from database import AttorneyReferral

        query = db.query(AttorneyReferral, Client).join(
            Client, AttorneyReferral.client_id == Client.id
        )

        if status_filter:
            query = query.filter(AttorneyReferral.status == status_filter)

        results = query.order_by(AttorneyReferral.created_at.desc()).all()

        referrals_data = [
            {
                "id": r.id,
                "client_id": r.client_id,
                "client_name": c.name,
                "attorney_name": r.attorney_name,
                "attorney_firm": r.attorney_firm,
                "estimated_value": r.estimated_value,
                "status": r.status,
                "attorney_accepted": r.attorney_accepted,
                "settlement_amount": r.settlement_amount,
                "created_at": r.created_at.isoformat() if r.created_at else None,
            }
            for r, c in results
        ]

        return jsonify({"success": True, "referrals": referrals_data})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# E-SIGNATURE API
# ==============================================================================


@app.route("/api/esignature/create", methods=["POST"])
def api_create_signature_request():
    """Create a new e-signature request"""
    try:
        data = request.json or {}
        client_id = data.get("client_id")
        document_type = data.get("document_type", "client_agreement")
        document_name = data.get("document_name")
        document_path = data.get("document_path")
        signer_email = data.get("signer_email")
        signer_name = data.get("signer_name")

        if not all([client_id, document_name, signer_email, signer_name]):
            return jsonify({"success": False, "error": "Missing required fields"}), 400

        from services.esignature_service import create_signature_request

        result = create_signature_request(
            client_id,
            document_type,
            document_name,
            document_path,
            signer_email,
            signer_name,
        )

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/sign/<token>")
def signature_page(token):
    """Display signature capture page for client"""
    from services.esignature_service import verify_signing_token

    result = verify_signing_token(token)

    if not result.get("success"):
        return render_template(
            "signature_error.html", error=result.get("error", "Invalid or expired link")
        )

    return render_template("signature_capture.html", request_data=result, token=token)


@app.route("/api/esignature/capture", methods=["POST"])
def api_capture_signature():
    """Capture and save signature"""
    try:
        data = request.json or {}
        token = data.get("token")
        signature_data = data.get("signature_data")

        if not token or not signature_data:
            return (
                jsonify(
                    {"success": False, "error": "Token and signature_data required"}
                ),
                400,
            )

        from services.esignature_service import capture_signature, verify_signing_token

        verify_result = verify_signing_token(token)
        if not verify_result.get("success"):
            return jsonify(verify_result), 400

        request_id = verify_result.get("request_id")
        result = capture_signature(request_id, signature_data)

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esignature/<int:request_id>/status", methods=["GET"])
def api_get_signature_status(request_id):
    """Get status of a signature request"""
    try:
        from services.esignature_service import get_signature_status

        result = get_signature_status(request_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esignature/client/<int:client_id>/pending", methods=["GET"])
def api_get_pending_signatures(client_id):
    """Get pending signature requests for a client"""
    try:
        from services.esignature_service import get_pending_signatures

        result = get_pending_signatures(client_id)
        return jsonify({"success": True, "pending": result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esignature/<int:request_id>/remind", methods=["POST"])
def api_send_signature_reminder(request_id):
    """Send reminder for pending signature"""
    try:
        from services.esignature_service import send_signature_reminder

        result = send_signature_reminder(request_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esignature/types", methods=["GET"])
def api_get_signature_types():
    """Get supported document types for e-signature"""
    try:
        from services.esignature_service import list_document_types

        types = list_document_types()
        return jsonify({"success": True, "types": types})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ==============================================================================
# E-SIGNATURE SESSION API - Full ESIGN Act, UETA, CROA Compliance
# ==============================================================================


@app.route("/api/esign/session/initiate", methods=["POST"])
def api_esign_initiate_session():
    """Initiate a new e-signature session with documents (staff only)"""
    # Staff authentication check
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.esignature_service import initiate_signing_session

        data = request.json or {}
        client_id = data.get("client_id")
        documents = data.get("documents", [])
        signer_email = data.get("signer_email")
        signer_name = data.get("signer_name")
        return_url = data.get("return_url")

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400
        if not documents:
            return jsonify({"success": False, "error": "documents required"}), 400
        if not signer_email or not signer_name:
            return (
                jsonify(
                    {"success": False, "error": "signer_email and signer_name required"}
                ),
                400,
            )

        result = initiate_signing_session(
            client_id=client_id,
            documents=documents,
            signer_email=signer_email,
            signer_name=signer_name,
            return_url=return_url,
            ip_address=request.remote_addr,
            user_agent=request.user_agent.string if request.user_agent else None,
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/session/<session_uuid>", methods=["GET"])
def api_esign_get_session(session_uuid):
    """Get signing session details by UUID"""
    try:
        from services.esignature_service import get_session_by_uuid

        result = get_session_by_uuid(session_uuid)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), (
            404 if "not found" in result.get("error", "").lower() else 400
        )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/session/<session_uuid>/consent", methods=["POST"])
def api_esign_submit_consent(session_uuid):
    """Submit ESIGN Act consent with 3 required acknowledgments"""
    try:
        from services.esignature_service import submit_esign_consent

        data = request.json or {}

        result = submit_esign_consent(
            session_uuid=session_uuid,
            hardware_software_acknowledged=data.get(
                "hardware_software_acknowledged", False
            ),
            paper_copy_right_acknowledged=data.get(
                "paper_copy_right_acknowledged", False
            ),
            consent_withdrawal_acknowledged=data.get(
                "consent_withdrawal_acknowledged", False
            ),
            ip_address=request.remote_addr,
            user_agent=request.user_agent.string if request.user_agent else None,
            device_fingerprint=data.get("device_fingerprint"),
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route(
    "/api/esign/session/<session_uuid>/document/<document_uuid>", methods=["GET"]
)
def api_esign_get_document(session_uuid, document_uuid):
    """Get a document for review"""
    try:
        from services.esignature_service import get_document_for_review

        result = get_document_for_review(session_uuid, document_uuid)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route(
    "/api/esign/session/<session_uuid>/document/<document_uuid>/progress",
    methods=["POST"],
)
def api_esign_record_progress(session_uuid, document_uuid):
    """Record document review progress (scroll, duration)"""
    try:
        from services.esignature_service import record_document_review_progress

        data = request.json or {}

        result = record_document_review_progress(
            session_uuid=session_uuid,
            document_uuid=document_uuid,
            scroll_percentage=data.get("scroll_percentage", 0),
            review_duration_seconds=data.get("review_duration_seconds", 0),
            ip_address=request.remote_addr,
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route(
    "/api/esign/session/<session_uuid>/document/<document_uuid>/sign", methods=["POST"]
)
def api_esign_sign_document(session_uuid, document_uuid):
    """Sign a document with full legal compliance"""
    try:
        from services.esignature_service import sign_document

        data = request.json or {}

        if not data.get("intent_confirmed"):
            return (
                jsonify({"success": False, "error": "Intent confirmation required"}),
                400,
            )
        if not data.get("typed_name"):
            return jsonify({"success": False, "error": "Typed name required"}), 400

        result = sign_document(
            session_uuid=session_uuid,
            document_uuid=document_uuid,
            signature_type=data.get("signature_type", "typed"),
            signature_value=data.get("signature_value", ""),
            intent_confirmed=data.get("intent_confirmed", False),
            typed_name=data.get("typed_name", ""),
            ip_address=request.remote_addr,
            user_agent=request.user_agent.string if request.user_agent else None,
            device_fingerprint=data.get("device_fingerprint"),
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/session/<session_uuid>/complete", methods=["POST"])
def api_esign_complete_session(session_uuid):
    """Complete a signing session after all documents are signed"""
    try:
        from services.esignature_service import complete_signing_session

        result = complete_signing_session(
            session_uuid=session_uuid,
            ip_address=request.remote_addr,
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/session/<session_uuid>/cancel", methods=["POST"])
def api_esign_cancel_session(session_uuid):
    """Cancel a pending signing session"""
    try:
        from services.esignature_service import cancel_signing_session

        data = request.json or {}

        result = cancel_signing_session(
            session_uuid=session_uuid,
            reason=data.get("reason"),
            ip_address=request.remote_addr,
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/session/<session_uuid>/regenerate-link", methods=["POST"])
def api_esign_regenerate_link(session_uuid):
    """Regenerate signing link for an expired session"""
    try:
        from services.esignature_service import regenerate_signing_link

        result = regenerate_signing_link(session_uuid)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/session/<session_uuid>/audit-trail", methods=["GET"])
def api_esign_get_audit_trail(session_uuid):
    """Get complete audit trail for a signing session (staff only)"""
    # Staff authentication check
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.esignature_service import get_session_audit_trail

        result = get_session_audit_trail(session_uuid)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 404

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/document/<document_uuid>/verify", methods=["GET"])
def api_esign_verify_document(document_uuid):
    """Verify document integrity (tamper-evidence check)"""
    try:
        from services.esignature_service import verify_document_integrity

        result = verify_document_integrity(document_uuid)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 404

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/client/<int:client_id>/history", methods=["GET"])
def api_esign_client_history(client_id):
    """Get all signing sessions and documents for a client (staff only)"""
    # Staff authentication check
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.esignature_service import get_client_signing_history

        result = get_client_signing_history(client_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/client/<int:client_id>/croa-status", methods=["GET"])
def api_esign_croa_status(client_id):
    """Get CROA compliance status for a client (staff only)"""
    # Staff authentication check
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.esignature_service import get_croa_compliance_status

        result = get_croa_compliance_status(client_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/client/<int:client_id>/croa-cancel", methods=["POST"])
def api_esign_croa_cancel(client_id):
    """Cancel service during CROA 3-business-day cancellation period"""
    try:
        from services.esignature_service import cancel_service_during_croa_period

        data = request.json or {}

        result = cancel_service_during_croa_period(
            client_id=client_id,
            reason=data.get("reason"),
            ip_address=request.remote_addr,
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/client/<int:client_id>/croa-waive", methods=["POST"])
def api_esign_croa_waive(client_id):
    """Waive CROA cancellation period to begin work immediately"""
    try:
        from services.esignature_service import waive_cancellation_period

        data = request.json or {}

        if not data.get("waiver_signature"):
            return (
                jsonify({"success": False, "error": "waiver_signature required"}),
                400,
            )

        result = waive_cancellation_period(
            client_id=client_id,
            waiver_signature=data.get("waiver_signature"),
            ip_address=request.remote_addr,
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/esign/consent-disclosure", methods=["GET"])
def api_esign_consent_disclosure():
    """Get the ESIGN Act consent disclosure HTML"""
    try:
        from services.esignature_service import get_esign_consent_disclosure

        disclosure = get_esign_consent_disclosure()
        return jsonify({"success": True, "disclosure_html": disclosure})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# E-Sign Page Route (for signing flow)
@app.route("/esign/<session_uuid>")
def esign_signing_page(session_uuid):
    """Render the e-signature signing page"""
    try:
        from services.esignature_service import get_session_by_uuid

        result = get_session_by_uuid(session_uuid)

        if not result.get("success"):
            return (
                render_template(
                    "error.html",
                    error_title="Session Not Found",
                    error_message=result.get(
                        "error",
                        "The signing session could not be found or has expired.",
                    ),
                ),
                404,
            )

        return render_template(
            "esign/signing_page.html",
            session=result.get("session"),
            documents=result.get("documents"),
            consent_disclosure=result.get("consent_disclosure"),
            session_uuid=session_uuid,
        )

    except Exception as e:
        return (
            render_template("error.html", error_title="Error", error_message=str(e)),
            500,
        )


# ==============================================================================
# INVOICE API - Client Invoicing and Billing
# ==============================================================================


@app.route("/api/invoices", methods=["GET"])
def api_list_invoices():
    """List invoices with optional filters"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from datetime import datetime

        from services.invoice_service import list_invoices

        client_id = request.args.get("client_id", type=int)
        status = request.args.get("status")
        tenant_id = request.args.get("tenant_id", type=int)
        from_date_str = request.args.get("from_date")
        to_date_str = request.args.get("to_date")
        limit = request.args.get("limit", 100, type=int)
        offset = request.args.get("offset", 0, type=int)

        from_date = (
            datetime.strptime(from_date_str, "%Y-%m-%d").date()
            if from_date_str
            else None
        )
        to_date = (
            datetime.strptime(to_date_str, "%Y-%m-%d").date() if to_date_str else None
        )

        result = list_invoices(
            client_id=client_id,
            status=status,
            tenant_id=tenant_id,
            from_date=from_date,
            to_date=to_date,
            limit=limit,
            offset=offset,
        )

        return jsonify(result)

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices", methods=["POST"])
def api_create_invoice():
    """Create a new invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from datetime import datetime

        from services.invoice_service import create_invoice

        data = request.json or {}
        client_id = data.get("client_id")
        items = data.get("items", [])

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400
        if not items:
            return jsonify({"success": False, "error": "items required"}), 400

        # Parse dates
        invoice_date = None
        if data.get("invoice_date"):
            invoice_date = datetime.strptime(data["invoice_date"], "%Y-%m-%d").date()

        due_date = None
        if data.get("due_date"):
            due_date = datetime.strptime(data["due_date"], "%Y-%m-%d").date()

        result = create_invoice(
            client_id=client_id,
            items=items,
            invoice_date=invoice_date,
            due_date=due_date,
            title=data.get("title"),
            notes=data.get("notes"),
            internal_notes=data.get("internal_notes"),
            tax_rate=data.get("tax_rate"),
            company_name=data.get("company_name"),
            company_address=data.get("company_address"),
            company_phone=data.get("company_phone"),
            company_email=data.get("company_email"),
            company_logo_url=data.get("company_logo_url"),
            tenant_id=data.get("tenant_id"),
            created_by_id=session.get("staff_id"),
            status=data.get("status", "draft"),
        )

        if result.get("success"):
            return jsonify(result), 201
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>", methods=["GET"])
def api_get_invoice(invoice_id):
    """Get invoice by ID"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import get_invoice

        include_payments = (
            request.args.get("include_payments", "false").lower() == "true"
        )
        result = get_invoice(invoice_id, include_payments=include_payments)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 404

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>", methods=["PUT"])
def api_update_invoice(invoice_id):
    """Update invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from datetime import datetime

        from services.invoice_service import update_invoice

        data = request.json or {}

        due_date = None
        if data.get("due_date"):
            due_date = datetime.strptime(data["due_date"], "%Y-%m-%d").date()

        result = update_invoice(
            invoice_id=invoice_id,
            title=data.get("title"),
            notes=data.get("notes"),
            internal_notes=data.get("internal_notes"),
            due_date=due_date,
            tax_rate=data.get("tax_rate"),
            status=data.get("status"),
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>", methods=["DELETE"])
def api_delete_invoice(invoice_id):
    """Delete a draft invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import delete_invoice

        result = delete_invoice(invoice_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>/items", methods=["POST"])
def api_add_invoice_item(invoice_id):
    """Add a line item to an invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import add_item

        data = request.json or {}

        if not data.get("description"):
            return jsonify({"success": False, "error": "description required"}), 400
        if data.get("unit_price") is None:
            return jsonify({"success": False, "error": "unit_price required"}), 400

        result = add_item(
            invoice_id=invoice_id,
            description=data["description"],
            unit_price=int(data["unit_price"]),
            quantity=float(data.get("quantity", 1.0)),
            item_type=data.get("item_type", "service"),
            reference_type=data.get("reference_type"),
            reference_id=data.get("reference_id"),
        )

        if result.get("success"):
            return jsonify(result), 201
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>/items/<int:item_id>", methods=["DELETE"])
def api_remove_invoice_item(invoice_id, item_id):
    """Remove a line item from an invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import remove_item

        result = remove_item(invoice_id, item_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>/payments", methods=["POST"])
def api_record_invoice_payment(invoice_id):
    """Record a payment against an invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from datetime import datetime

        from services.invoice_service import record_payment

        data = request.json or {}

        if data.get("amount") is None:
            return jsonify({"success": False, "error": "amount required"}), 400

        paid_at = None
        if data.get("paid_at"):
            paid_at = datetime.fromisoformat(data["paid_at"].replace("Z", "+00:00"))

        result = record_payment(
            invoice_id=invoice_id,
            amount=int(data["amount"]),
            payment_method=data.get("payment_method", "other"),
            stripe_payment_intent_id=data.get("stripe_payment_intent_id"),
            stripe_charge_id=data.get("stripe_charge_id"),
            transaction_id=data.get("transaction_id"),
            notes=data.get("notes"),
            recorded_by_id=session.get("staff_id"),
            paid_at=paid_at,
        )

        if result.get("success"):
            return jsonify(result), 201
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>/void", methods=["POST"])
def api_void_invoice(invoice_id):
    """Void/cancel an invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import void_invoice

        data = request.json or {}
        result = void_invoice(invoice_id, reason=data.get("reason"))

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>/send", methods=["POST"])
def api_send_invoice(invoice_id):
    """Send invoice to client via email"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import send_invoice_email

        result = send_invoice_email(invoice_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>/pdf", methods=["POST"])
def api_generate_invoice_pdf(invoice_id):
    """Generate PDF for an invoice"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import generate_invoice_pdf

        result = generate_invoice_pdf(invoice_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/<int:invoice_id>/pdf", methods=["GET"])
def api_download_invoice_pdf(invoice_id):
    """Download invoice PDF"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        import os

        from services.invoice_service import INVOICE_PDF_DIR, get_invoice

        result = get_invoice(invoice_id)
        if not result.get("success"):
            return jsonify(result), 404

        invoice = result["invoice"]
        if not invoice.get("pdf_filename"):
            return jsonify({"success": False, "error": "PDF not generated yet"}), 404

        pdf_path = os.path.join(INVOICE_PDF_DIR, invoice["pdf_filename"])
        if not os.path.exists(pdf_path):
            return jsonify({"success": False, "error": "PDF file not found"}), 404

        return send_file(
            pdf_path, as_attachment=True, download_name=invoice["pdf_filename"]
        )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/stats", methods=["GET"])
def api_invoice_stats():
    """Get invoice statistics"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import get_invoice_stats

        client_id = request.args.get("client_id", type=int)
        tenant_id = request.args.get("tenant_id", type=int)

        result = get_invoice_stats(client_id=client_id, tenant_id=tenant_id)
        return jsonify(result)

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/invoices/check-overdue", methods=["POST"])
def api_check_overdue_invoices():
    """Check and update overdue invoices"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import check_overdue_invoices

        result = check_overdue_invoices()
        return jsonify(result)

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/clients/<int:client_id>/invoices", methods=["GET"])
def api_client_invoices(client_id):
    """Get all invoices for a client"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import get_client_invoices

        result = get_client_invoices(client_id)
        return jsonify(result)

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/clients/<int:client_id>/invoices/create-for-round", methods=["POST"])
def api_create_invoice_for_round(client_id):
    """Create an invoice for a dispute round"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import create_invoice_for_round

        data = request.json or {}

        if data.get("round_number") is None:
            return jsonify({"success": False, "error": "round_number required"}), 400
        if data.get("amount") is None:
            return jsonify({"success": False, "error": "amount required"}), 400

        result = create_invoice_for_round(
            client_id=client_id,
            round_number=int(data["round_number"]),
            amount=int(data["amount"]),
            created_by_id=session.get("staff_id"),
        )

        if result.get("success"):
            return jsonify(result), 201
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route(
    "/api/clients/<int:client_id>/invoices/create-for-analysis", methods=["POST"]
)
def api_create_invoice_for_analysis(client_id):
    """Create an invoice for credit analysis"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    try:
        from services.invoice_service import create_invoice_for_analysis

        data = request.json or {}

        result = create_invoice_for_analysis(
            client_id=client_id,
            analysis_id=data.get("analysis_id", 0),
            amount=int(data.get("amount", 19900)),
            created_by_id=session.get("staff_id"),
        )

        if result.get("success"):
            return jsonify(result), 201
        return jsonify(result), 400

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# Invoice page route
@app.route("/dashboard/invoices")
def dashboard_invoices():
    """Invoice management page"""
    if not session.get("staff_id"):
        return redirect("/staff/login")

    return render_template("invoices.html")


# ==============================================================================
# PUSH NOTIFICATIONS API (P17)
# ==============================================================================


@app.route("/api/push/vapid-public-key", methods=["GET"])
def api_push_vapid_public_key():
    """Get VAPID public key for push subscription"""
    from services.push_notification_service import get_vapid_keys, is_push_configured

    if not is_push_configured():
        return (
            jsonify({"success": False, "error": "Push notifications not configured"}),
            503,
        )

    keys = get_vapid_keys()
    return jsonify(
        {
            "success": True,
            "publicKey": keys["public_key"],
        }
    )


@app.route("/api/push/subscribe", methods=["POST"])
def api_push_subscribe():
    """Subscribe to push notifications"""
    from services.push_notification_service import subscribe

    data = request.json or {}

    endpoint = data.get("endpoint")
    keys = data.get("keys", {})
    p256dh = keys.get("p256dh")
    auth = keys.get("auth")

    if not endpoint or not p256dh or not auth:
        return jsonify({"success": False, "error": "Invalid subscription data"}), 400

    # Determine if client or staff
    client_id = None
    staff_id = None

    if session.get("client_id"):
        client_id = session.get("client_id")
    elif session.get("staff_id"):
        staff_id = session.get("staff_id")
    else:
        return jsonify({"success": False, "error": "Authentication required"}), 401

    result = subscribe(
        endpoint=endpoint,
        p256dh_key=p256dh,
        auth_key=auth,
        client_id=client_id,
        staff_id=staff_id,
        user_agent=request.headers.get("User-Agent"),
        device_name=data.get("device_name"),
    )

    if result.get("success"):
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/push/unsubscribe", methods=["POST"])
def api_push_unsubscribe():
    """Unsubscribe from push notifications"""
    from services.push_notification_service import unsubscribe

    data = request.json or {}
    endpoint = data.get("endpoint")

    if not endpoint:
        return jsonify({"success": False, "error": "endpoint required"}), 400

    result = unsubscribe(endpoint)
    return jsonify(result)


@app.route("/api/push/subscriptions", methods=["GET"])
def api_push_subscriptions():
    """Get user's push subscriptions"""
    from services.push_notification_service import get_subscriptions

    client_id = session.get("client_id")
    staff_id = session.get("staff_id")

    if not client_id and not staff_id:
        return jsonify({"success": False, "error": "Authentication required"}), 401

    subscriptions = get_subscriptions(client_id=client_id, staff_id=staff_id)

    return jsonify(
        {
            "success": True,
            "subscriptions": subscriptions,
        }
    )


@app.route("/api/push/subscriptions/<int:subscription_id>/preferences", methods=["PUT"])
def api_push_update_preferences(subscription_id):
    """Update notification preferences for a subscription"""
    from services.push_notification_service import update_preferences

    data = request.json or {}

    result = update_preferences(subscription_id, data)
    return jsonify(result)


@app.route("/api/push/test", methods=["POST"])
def api_push_test():
    """Send a test push notification (staff only)"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    from services.push_notification_service import send_to_staff

    result = send_to_staff(
        staff_id=session.get("staff_id"),
        notification_type="case_update",
        body="This is a test notification from Brightpath Ascend",
        url="/dashboard",
        title="Test Notification",
    )

    return jsonify(result)


@app.route("/api/push/send-to-client/<int:client_id>", methods=["POST"])
def api_push_send_to_client(client_id):
    """Send a push notification to a client (staff only)"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    from services.push_notification_service import send_to_client

    data = request.json or {}

    notification_type = data.get("type", "case_update")
    body = data.get("body", "")
    title = data.get("title")
    url = data.get("url")

    if not body:
        return jsonify({"success": False, "error": "body required"}), 400

    result = send_to_client(
        client_id=client_id,
        notification_type=notification_type,
        body=body,
        title=title,
        url=url,
    )

    return jsonify(result)


@app.route("/api/push/logs", methods=["GET"])
def api_push_logs():
    """Get push notification logs (staff only)"""
    if not session.get("staff_id"):
        return (
            jsonify({"success": False, "error": "Staff authentication required"}),
            401,
        )

    from services.push_notification_service import get_notification_logs

    client_id = request.args.get("client_id", type=int)
    status = request.args.get("status")
    limit = request.args.get("limit", 50, type=int)

    logs = get_notification_logs(
        client_id=client_id,
        status=status,
        limit=limit,
    )

    return jsonify(
        {
            "success": True,
            "logs": logs,
        }
    )


# ==============================================================================
# METRO2 VIOLATION DETECTION API
# ==============================================================================


@app.route("/api/metro2/detect-violations", methods=["POST"])
def api_detect_metro2_violations():
    """Detect Metro2 format violations in tradeline data"""
    try:
        data = request.json or {}
        tradeline_data = data.get("tradeline_data", {})

        if not tradeline_data:
            return jsonify({"success": False, "error": "tradeline_data required"}), 400

        from services.metro2_service import detect_metro2_violations

        violations = detect_metro2_violations(tradeline_data)

        return jsonify(
            {
                "success": True,
                "violations": violations,
                "violation_count": len(violations),
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/metro2/analyze-collection", methods=["POST"])
def api_analyze_collection_account():
    """Analyze a collection account for Metro2 violations"""
    try:
        data = request.json or {}
        collection_data = data.get("collection_data", {})

        if not collection_data:
            return jsonify({"success": False, "error": "collection_data required"}), 400

        from services.metro2_service import analyze_collection_account

        violations = analyze_collection_account(collection_data)

        return jsonify(
            {
                "success": True,
                "violations": violations,
                "violation_count": len(violations),
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/metro2/calculate-damages", methods=["POST"])
def api_calculate_metro2_damages():
    """Calculate potential damages from Metro2 violations"""
    try:
        data = request.json or {}
        violations = data.get("violations", [])

        from services.metro2_service import calculate_violation_damages

        damage_info = calculate_violation_damages(violations)

        return jsonify({"success": True, "damages": damage_info})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/metro2/generate-dispute-points", methods=["POST"])
def api_generate_metro2_dispute_points():
    """Generate dispute language for Metro2 violations"""
    try:
        data = request.json or {}
        violations = data.get("violations", [])

        from services.metro2_service import generate_metro2_dispute_points

        dispute_points = generate_metro2_dispute_points(violations)

        return jsonify({"success": True, "dispute_points": dispute_points})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/metro2/payment-codes", methods=["GET"])
def api_get_payment_codes():
    """Get Metro2 payment status code reference"""
    try:
        from services.metro2_service import PAYMENT_HISTORY_CODES, PAYMENT_STATUS_CODES

        return jsonify(
            {
                "success": True,
                "status_codes": PAYMENT_STATUS_CODES,
                "history_codes": PAYMENT_HISTORY_CODES,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ==============================================================================
# DEBT VALIDATION LETTERS API
# ==============================================================================


@app.route("/api/validation-letters/generate", methods=["POST"])
def api_generate_validation_letters():
    """Generate debt validation letters for collection accounts"""
    try:
        data = request.json or {}
        client_id = data.get("client_id")
        collections = data.get("collections", [])
        case_id = data.get("case_id")

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400

        from services.debt_validation_service import generate_validation_letters

        if collections:
            result = generate_validation_letters(client_id, collections=collections)
        elif case_id:
            result = generate_validation_letters(client_id, case_id=case_id)
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Either collections or case_id required",
                    }
                ),
                400,
            )

        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/validation-letters/auto-generate/<int:case_id>", methods=["POST"])
def api_auto_generate_validation_letters(case_id):
    """Auto-generate validation letters from case analysis"""
    try:
        from services.debt_validation_service import (
            auto_generate_validation_letters_from_analysis,
        )

        result = auto_generate_validation_letters_from_analysis(case_id)
        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/validation-letters/agencies", methods=["GET"])
def api_get_collection_agencies():
    """Get list of common collection agencies with addresses"""
    try:
        from services.debt_validation_service import get_common_collection_agencies

        agencies = get_common_collection_agencies()
        return jsonify({"success": True, "agencies": agencies})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/validation-letters/single", methods=["POST"])
def api_generate_single_validation_letter():
    """Generate a single debt validation letter"""
    try:
        data = request.json or {}
        client_id = data.get("client_id")
        collection_info = data.get("collection_info", {})

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400
        if not collection_info.get("creditor_name"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "creditor_name required in collection_info",
                    }
                ),
                400,
            )

        from services.debt_validation_service import generate_validation_letter_single

        result = generate_validation_letter_single(client_id, collection_info)
        return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


# ==============================================================================
# PWA MANIFEST AND SERVICE WORKER
# ==============================================================================


@app.route("/manifest.json")
def pwa_manifest():
    """Serve PWA manifest for installable web app"""
    manifest = {
        "name": "Brightpath Ascend FCRA Platform",
        "short_name": "Brightpath FCRA",
        "description": "Comprehensive FCRA litigation automation platform",
        "start_url": "/dashboard",
        "display": "standalone",
        "background_color": "#1a1a2e",
        "theme_color": "#319795",
        "orientation": "any",
        "icons": [
            {
                "src": "/static/images/icon-192.png",
                "sizes": "192x192",
                "type": "image/png",
            },
            {
                "src": "/static/images/icon-512.png",
                "sizes": "512x512",
                "type": "image/png",
            },
        ],
        "categories": ["business", "productivity"],
        "shortcuts": [
            {
                "name": "Dashboard",
                "short_name": "Dashboard",
                "description": "View dashboard",
                "url": "/dashboard",
                "icons": [{"src": "/static/images/icon-192.png", "sizes": "192x192"}],
            },
            {
                "name": "Contacts",
                "short_name": "Contacts",
                "description": "Manage contacts",
                "url": "/dashboard/contacts",
                "icons": [{"src": "/static/images/icon-192.png", "sizes": "192x192"}],
            },
        ],
    }
    return jsonify(manifest)


@app.route("/sw.js")
def service_worker():
    """Serve service worker for offline functionality and push notifications"""
    sw_content = """
// Brightpath Ascend FCRA Platform Service Worker
const CACHE_NAME = 'brightpath-fcra-v1';
const urlsToCache = [
    '/',
    '/dashboard',
    '/static/images/logo.png',
    'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap'
];

// Install event
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(urlsToCache))
    );
    self.skipWaiting();
});

// Activate event
self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.filter(name => name !== CACHE_NAME)
                    .map(name => caches.delete(name))
            );
        })
    );
    self.clients.claim();
});

// Fetch event - network first, cache fallback
self.addEventListener('fetch', event => {
    if (event.request.method !== 'GET') return;
    
    event.respondWith(
        fetch(event.request)
            .then(response => {
                if (response.status === 200) {
                    const responseClone = response.clone();
                    caches.open(CACHE_NAME)
                        .then(cache => cache.put(event.request, responseClone));
                }
                return response;
            })
            .catch(() => caches.match(event.request))
    );
});

// Push notification event
self.addEventListener('push', event => {
    const data = event.data ? event.data.json() : {};
    const title = data.title || 'Brightpath Ascend';
    const options = {
        body: data.body || 'You have a new notification',
        icon: '/static/images/icon-192.png',
        badge: '/static/images/icon-192.png',
        data: data.url || '/dashboard',
        actions: [
            { action: 'open', title: 'Open' },
            { action: 'dismiss', title: 'Dismiss' }
        ]
    };
    
    event.waitUntil(
        self.registration.showNotification(title, options)
    );
});

// Notification click event
self.addEventListener('notificationclick', event => {
    event.notification.close();
    
    if (event.action === 'dismiss') return;
    
    event.waitUntil(
        clients.openWindow(event.notification.data)
    );
});
"""
    response = app.response_class(
        response=sw_content, status=200, mimetype="application/javascript"
    )
    response.headers["Cache-Control"] = "no-cache"
    return response


# ============================================================
# CREDIT SCORE IMPROVEMENT TRACKING
# ============================================================


@app.route("/api/credit-score/snapshot", methods=["POST"])
def add_credit_score_snapshot():
    """Add a new credit score snapshot for a client"""
    from services.credit_score_calculator import add_score_snapshot

    data = request.json
    client_id = data.get("client_id")

    if not client_id:
        return jsonify({"success": False, "error": "client_id required"}), 400

    result = add_score_snapshot(
        client_id=client_id,
        equifax=data.get("equifax"),
        experian=data.get("experian"),
        transunion=data.get("transunion"),
        negatives=data.get("negatives", 0),
        removed=data.get("removed", 0),
        milestone=data.get("milestone"),
        dispute_round=data.get("dispute_round", 0),
        snapshot_type=data.get("snapshot_type", "manual"),
        source=data.get("source"),
        notes=data.get("notes"),
    )

    return jsonify(result)


@app.route("/api/credit-score/projection/<int:client_id>")
def get_credit_score_projection(client_id):
    """Get comprehensive credit score projection for a client"""
    from services.credit_score_calculator import calculate_client_projection

    projection = calculate_client_projection(client_id)
    if not projection:
        return jsonify({"success": False, "error": "Client not found"}), 404

    return jsonify({"success": True, "data": projection})


@app.route("/api/credit-score/summary/<int:client_id>")
def get_credit_score_summary(client_id):
    """Get quick summary of client's credit improvement"""
    from services.credit_score_calculator import get_improvement_summary

    summary = get_improvement_summary(client_id)
    return jsonify({"success": True, "data": summary})


@app.route("/api/credit-score/timeline/<int:client_id>")
def get_credit_score_timeline(client_id):
    """Get score history timeline for charts"""
    from services.credit_score_calculator import get_score_timeline

    timeline = get_score_timeline(client_id)
    return jsonify({"success": True, "data": timeline})


@app.route("/api/credit-score/estimate", methods=["POST"])
def estimate_score_improvement():
    """Quick estimate of potential score improvement"""
    from services.credit_score_calculator import quick_estimate

    data = request.json
    current_score = data.get("current_score", 550)
    num_negatives = data.get("num_negatives", 0)

    estimate = quick_estimate(current_score, num_negatives)
    return jsonify({"success": True, "data": estimate})


@app.route("/api/credit-score/item-types")
def get_credit_score_item_types():
    """Get all negative item types with their score impact data"""
    from services.credit_score_calculator import SEVERITY_LEVELS, get_all_item_types

    item_types = get_all_item_types()
    return jsonify(
        {
            "success": True,
            "data": {"categories": item_types, "severity_levels": SEVERITY_LEVELS},
        }
    )


@app.route("/api/credit-score/estimate-detailed", methods=["POST"])
def estimate_score_detailed():
    """Detailed estimate based on specific item types"""
    from services.credit_score_calculator import estimate_by_item_types

    data = request.json
    current_score = data.get("current_score", 550)
    selected_items = data.get("items", [])

    estimate = estimate_by_item_types(current_score, selected_items)
    return jsonify({"success": True, "data": estimate})


@app.route("/api/credit-score/history/<int:client_id>")
def get_credit_score_history(client_id):
    """Get all score snapshots for a client"""
    db = get_db()
    try:
        snapshots = (
            db.query(CreditScoreSnapshot)
            .filter_by(client_id=client_id)
            .order_by(CreditScoreSnapshot.created_at.desc())
            .all()
        )

        history = []
        for s in snapshots:
            history.append(
                {
                    "id": s.id,
                    "equifax": s.equifax_score,
                    "experian": s.experian_score,
                    "transunion": s.transunion_score,
                    "average": s.average_score,
                    "negatives": s.total_negatives,
                    "removed": s.total_removed,
                    "milestone": s.milestone,
                    "dispute_round": s.dispute_round,
                    "snapshot_type": s.snapshot_type,
                    "source": s.source,
                    "notes": s.notes,
                    "created_at": s.created_at.isoformat() if s.created_at else None,
                }
            )

        return jsonify({"success": True, "data": history})
    finally:
        db.close()


@app.route("/dashboard/credit-tracker")
@require_staff(roles=["admin", "paralegal", "attorney"])
def credit_tracker_dashboard():
    """Credit score improvement tracker dashboard page"""
    return render_template("credit_tracker.html")


@app.route("/dashboard/credit-tracker/<int:client_id>")
@require_staff(roles=["admin", "paralegal", "attorney"])
def credit_tracker_client(client_id):
    """Credit score tracker for specific client"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return "Client not found", 404
        return render_template("credit_tracker_client.html", client=client)
    finally:
        db.close()


# =============================================================
# CALENDAR VIEW FOR DEADLINES
# =============================================================


@app.route("/dashboard/calendar")
@require_staff()
def calendar_dashboard():
    """Calendar view showing all case deadlines"""
    return render_template("calendar.html")


@app.route("/dashboard/booking-management")
@require_staff()
def booking_management():
    """Staff page to manage Q&A call bookings and time slots"""
    return render_template("booking_management.html")


@app.route("/dashboard/messaging")
@require_staff()
def messaging_dashboard():
    """Staff page to respond to client messages"""
    return render_template("messaging.html")


@app.route("/api/calendar/events")
def get_calendar_events():
    """
    API endpoint returning deadlines in FullCalendar format.
    Supports filtering by client_name, bureau, deadline_type.
    """
    from datetime import date, timedelta

    db = get_db()
    try:
        client_filter = request.args.get("client", "").strip()
        bureau_filter = request.args.get("bureau", "").strip()
        type_filter = request.args.get("type", "").strip()

        query = db.query(CaseDeadline, Client).join(
            Client, CaseDeadline.client_id == Client.id
        )

        if client_filter:
            query = query.filter(Client.name.ilike(f"%{client_filter}%"))

        if bureau_filter:
            query = query.filter(CaseDeadline.bureau == bureau_filter)

        if type_filter:
            query = query.filter(CaseDeadline.deadline_type == type_filter)

        results = query.all()

        color_map = {
            "cra_response": "#3498db",
            "reinvestigation": "#f39c12",
            "data_furnisher": "#27ae60",
            "client_action": "#f1c40f",
            "legal_filing": "#e74c3c",
        }

        type_labels = {
            "cra_response": "CRA Response",
            "reinvestigation": "Reinvestigation",
            "data_furnisher": "Data Furnisher",
            "client_action": "Client Action",
            "legal_filing": "Legal Filing",
        }

        events = []
        today = date.today()

        for deadline, client in results:
            is_overdue = deadline.deadline_date < today and deadline.status == "active"
            base_color = color_map.get(deadline.deadline_type, "#95a5a6")
            event_color = "#e74c3c" if is_overdue else base_color

            type_label = type_labels.get(
                deadline.deadline_type, deadline.deadline_type.replace("_", " ").title()
            )
            bureau_suffix = f" ({deadline.bureau})" if deadline.bureau else ""

            events.append(
                {
                    "id": deadline.id,
                    "title": f"{type_label} - {client.name}{bureau_suffix}",
                    "start": deadline.deadline_date.isoformat(),
                    "color": event_color,
                    "textColor": "#ffffff",
                    "extendedProps": {
                        "client_id": client.id,
                        "client_name": client.name,
                        "client_email": client.email or "",
                        "deadline_type": deadline.deadline_type,
                        "deadline_type_label": type_label,
                        "bureau": deadline.bureau or "N/A",
                        "dispute_round": deadline.dispute_round or 1,
                        "start_date": (
                            deadline.start_date.isoformat()
                            if deadline.start_date
                            else ""
                        ),
                        "days_allowed": deadline.days_allowed or 30,
                        "status": deadline.status,
                        "is_overdue": is_overdue,
                        "notes": deadline.notes or "",
                    },
                }
            )

        return jsonify(events)

    except Exception as e:
        print(f"Error fetching calendar events: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/calendar/stats")
def get_calendar_stats():
    """
    Get calendar statistics: upcoming this week, overdue count.
    """
    from datetime import date, timedelta

    db = get_db()
    try:
        today = date.today()
        week_from_now = today + timedelta(days=7)

        upcoming_this_week = (
            db.query(CaseDeadline)
            .filter(
                CaseDeadline.status == "active",
                CaseDeadline.deadline_date >= today,
                CaseDeadline.deadline_date <= week_from_now,
            )
            .count()
        )

        overdue_count = (
            db.query(CaseDeadline)
            .filter(CaseDeadline.status == "active", CaseDeadline.deadline_date < today)
            .count()
        )

        total_active = (
            db.query(CaseDeadline).filter(CaseDeadline.status == "active").count()
        )

        completed_this_month = (
            db.query(CaseDeadline)
            .filter(
                CaseDeadline.status == "completed",
                CaseDeadline.completed_at >= today.replace(day=1),
            )
            .count()
        )

        return jsonify(
            {
                "success": True,
                "upcoming_this_week": upcoming_this_week,
                "overdue_count": overdue_count,
                "total_active": total_active,
                "completed_this_month": completed_this_month,
            }
        )

    except Exception as e:
        print(f"Error fetching calendar stats: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# SETTLEMENT TRACKING MODULE
# ==============================================================================


@app.route("/dashboard/settlements")
@require_staff(roles=["admin", "attorney", "paralegal"])
def dashboard_settlements():
    """Settlement tracking dashboard with pipeline view"""
    db = get_db()
    try:
        settlements = db.query(Settlement).order_by(Settlement.created_at.desc()).all()

        status_counts = {
            "pending": 0,
            "demand_sent": 0,
            "negotiating": 0,
            "accepted": 0,
            "rejected": 0,
            "litigated": 0,
        }

        total_settled = 0
        total_pending_value = 0
        total_contingency = 0
        settlement_amounts = []

        settlement_list = []
        for s in settlements:
            case = db.query(Case).filter_by(id=s.case_id).first()
            client = None
            if case:
                client = db.query(Client).filter_by(id=case.client_id).first()

            status = s.status or "pending"
            if status in status_counts:
                status_counts[status] += 1

            if status == "accepted" and s.final_amount:
                total_settled += s.final_amount
                settlement_amounts.append(s.final_amount)
            elif status in ["pending", "demand_sent", "negotiating"]:
                total_pending_value += s.target_amount or 0

            if s.contingency_earned:
                total_contingency += s.contingency_earned

            settlement_list.append(
                {
                    "id": s.id,
                    "case_id": s.case_id,
                    "client_name": client.name if client else "Unknown",
                    "client_id": client.id if client else None,
                    "target_amount": s.target_amount or 0,
                    "minimum_acceptable": s.minimum_acceptable or 0,
                    "initial_demand": s.initial_demand or 0,
                    "counter_offer_1": s.counter_offer_1,
                    "counter_offer_2": s.counter_offer_2,
                    "final_amount": s.final_amount,
                    "status": status,
                    "settled_at": s.settled_at,
                    "payment_received": s.payment_received,
                    "payment_amount": s.payment_amount,
                    "contingency_earned": s.contingency_earned,
                    "created_at": s.created_at,
                }
            )

        avg_settlement = (
            sum(settlement_amounts) / len(settlement_amounts)
            if settlement_amounts
            else 0
        )

        stats = {
            "total_settled": total_settled,
            "total_pending_value": total_pending_value,
            "avg_settlement": avg_settlement,
            "total_contingency": total_contingency,
            "count_settled": len(settlement_amounts),
            "count_pending": status_counts["pending"]
            + status_counts["demand_sent"]
            + status_counts["negotiating"],
        }

        return render_template(
            "settlements.html",
            settlements=settlement_list,
            status_counts=status_counts,
            stats=stats,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/api/settlements", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_list_settlements():
    """List all settlements with optional filters"""
    db = get_db()
    try:
        query = db.query(Settlement)

        status = request.args.get("status")
        if status:
            query = query.filter(Settlement.status == status)

        client_id = request.args.get("client_id")
        if client_id:
            case_ids = [
                c.id for c in db.query(Case).filter_by(client_id=client_id).all()
            ]
            query = query.filter(Settlement.case_id.in_(case_ids))

        date_from = request.args.get("date_from")
        if date_from:
            query = query.filter(
                Settlement.created_at >= datetime.strptime(date_from, "%Y-%m-%d")
            )

        date_to = request.args.get("date_to")
        if date_to:
            query = query.filter(
                Settlement.created_at <= datetime.strptime(date_to, "%Y-%m-%d")
            )

        settlements = query.order_by(Settlement.created_at.desc()).all()

        result = []
        for s in settlements:
            case = db.query(Case).filter_by(id=s.case_id).first()
            client = None
            if case:
                client = db.query(Client).filter_by(id=case.client_id).first()

            result.append(
                {
                    "id": s.id,
                    "case_id": s.case_id,
                    "client_name": client.name if client else "Unknown",
                    "client_id": client.id if client else None,
                    "target_amount": s.target_amount,
                    "minimum_acceptable": s.minimum_acceptable,
                    "initial_demand": s.initial_demand,
                    "initial_demand_date": (
                        s.initial_demand_date.isoformat()
                        if s.initial_demand_date
                        else None
                    ),
                    "counter_offer_1": s.counter_offer_1,
                    "counter_offer_1_date": (
                        s.counter_offer_1_date.isoformat()
                        if s.counter_offer_1_date
                        else None
                    ),
                    "counter_offer_2": s.counter_offer_2,
                    "counter_offer_2_date": (
                        s.counter_offer_2_date.isoformat()
                        if s.counter_offer_2_date
                        else None
                    ),
                    "final_amount": s.final_amount,
                    "status": s.status,
                    "settled_at": s.settled_at.isoformat() if s.settled_at else None,
                    "settlement_notes": s.settlement_notes,
                    "payment_received": s.payment_received,
                    "payment_amount": s.payment_amount,
                    "payment_date": (
                        s.payment_date.isoformat() if s.payment_date else None
                    ),
                    "contingency_earned": s.contingency_earned,
                    "transunion_target": s.transunion_target,
                    "experian_target": s.experian_target,
                    "equifax_target": s.equifax_target,
                    "created_at": s.created_at.isoformat() if s.created_at else None,
                }
            )

        return jsonify({"success": True, "settlements": result})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_create_settlement():
    """Create a new settlement from a case"""
    db = get_db()
    try:
        data = request.json
        case_id = data.get("case_id")

        if not case_id:
            return jsonify({"success": False, "error": "case_id is required"}), 400

        case = db.query(Case).filter_by(id=case_id).first()
        if not case:
            return jsonify({"success": False, "error": "Case not found"}), 404

        existing = db.query(Settlement).filter_by(case_id=case_id).first()
        if existing:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Settlement already exists for this case",
                        "settlement_id": existing.id,
                    }
                ),
                400,
            )

        damages = None
        if case.analysis_id:
            damages = db.query(Damages).filter_by(analysis_id=case.analysis_id).first()

        target_amount = data.get("target_amount") or (
            damages.settlement_target if damages else 0
        )
        minimum_acceptable = data.get("minimum_acceptable") or (
            damages.minimum_acceptable if damages else 0
        )

        settlement = Settlement(
            case_id=case_id,
            target_amount=target_amount,
            minimum_acceptable=minimum_acceptable,
            transunion_target=data.get("transunion_target", 0),
            experian_target=data.get("experian_target", 0),
            equifax_target=data.get("equifax_target", 0),
            status="pending",
            initial_demand=data.get("initial_demand", target_amount),
            initial_demand_date=(
                datetime.utcnow() if data.get("initial_demand") else None
            ),
            settlement_notes=data.get("notes"),
        )

        db.add(settlement)
        db.commit()

        return jsonify(
            {
                "success": True,
                "settlement_id": settlement.id,
                "message": "Settlement created successfully",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements/<int:settlement_id>", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_get_settlement(settlement_id):
    """Get settlement details"""
    db = get_db()
    try:
        s = db.query(Settlement).filter_by(id=settlement_id).first()
        if not s:
            return jsonify({"success": False, "error": "Settlement not found"}), 404

        case = db.query(Case).filter_by(id=s.case_id).first()
        client = None
        analysis = None
        damages = None
        score = None

        if case:
            client = db.query(Client).filter_by(id=case.client_id).first()
            if case.analysis_id:
                analysis = db.query(Analysis).filter_by(id=case.analysis_id).first()
                damages = (
                    db.query(Damages).filter_by(analysis_id=case.analysis_id).first()
                )
                score = (
                    db.query(CaseScore).filter_by(analysis_id=case.analysis_id).first()
                )

        return jsonify(
            {
                "success": True,
                "settlement": {
                    "id": s.id,
                    "case_id": s.case_id,
                    "client_name": client.name if client else "Unknown",
                    "client_id": client.id if client else None,
                    "target_amount": s.target_amount,
                    "minimum_acceptable": s.minimum_acceptable,
                    "initial_demand": s.initial_demand,
                    "initial_demand_date": (
                        s.initial_demand_date.isoformat()
                        if s.initial_demand_date
                        else None
                    ),
                    "counter_offer_1": s.counter_offer_1,
                    "counter_offer_1_date": (
                        s.counter_offer_1_date.isoformat()
                        if s.counter_offer_1_date
                        else None
                    ),
                    "counter_offer_2": s.counter_offer_2,
                    "counter_offer_2_date": (
                        s.counter_offer_2_date.isoformat()
                        if s.counter_offer_2_date
                        else None
                    ),
                    "final_amount": s.final_amount,
                    "status": s.status,
                    "settled_at": s.settled_at.isoformat() if s.settled_at else None,
                    "settlement_notes": s.settlement_notes,
                    "payment_received": s.payment_received,
                    "payment_amount": s.payment_amount,
                    "payment_date": (
                        s.payment_date.isoformat() if s.payment_date else None
                    ),
                    "contingency_earned": s.contingency_earned,
                    "transunion_target": s.transunion_target,
                    "experian_target": s.experian_target,
                    "equifax_target": s.equifax_target,
                    "created_at": s.created_at.isoformat() if s.created_at else None,
                    "updated_at": s.updated_at.isoformat() if s.updated_at else None,
                },
                "case": (
                    {
                        "id": case.id if case else None,
                        "case_number": case.case_number if case else None,
                        "contingency_percent": case.contingency_percent if case else 0,
                    }
                    if case
                    else None
                ),
                "damages": (
                    {
                        "total_exposure": damages.total_exposure if damages else 0,
                        "settlement_target": (
                            damages.settlement_target if damages else 0
                        ),
                        "minimum_acceptable": (
                            damages.minimum_acceptable if damages else 0
                        ),
                    }
                    if damages
                    else None
                ),
                "score": (
                    {
                        "total_score": score.total_score if score else 0,
                        "case_strength": score.case_strength if score else None,
                        "settlement_probability": (
                            score.settlement_probability if score else 0
                        ),
                    }
                    if score
                    else None
                ),
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements/<int:settlement_id>", methods=["PUT"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_update_settlement(settlement_id):
    """Update settlement details"""
    db = get_db()
    try:
        s = db.query(Settlement).filter_by(id=settlement_id).first()
        if not s:
            return jsonify({"success": False, "error": "Settlement not found"}), 404

        data = request.json

        updatable = [
            "target_amount",
            "minimum_acceptable",
            "initial_demand",
            "status",
            "settlement_notes",
            "transunion_target",
            "experian_target",
            "equifax_target",
        ]

        for field in updatable:
            if field in data:
                setattr(s, field, data[field])

        if (
            "initial_demand" in data
            and data["initial_demand"]
            and not s.initial_demand_date
        ):
            s.initial_demand_date = datetime.utcnow()

        if (
            "status" in data
            and data["status"] == "demand_sent"
            and not s.initial_demand_date
        ):
            s.initial_demand_date = datetime.utcnow()

        db.commit()

        return jsonify({"success": True, "message": "Settlement updated"})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements/<int:settlement_id>/offer", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_add_counter_offer(settlement_id):
    """Add a counter-offer to settlement"""
    db = get_db()
    try:
        s = db.query(Settlement).filter_by(id=settlement_id).first()
        if not s:
            return jsonify({"success": False, "error": "Settlement not found"}), 404

        data = request.json
        amount = data.get("amount")

        if not amount:
            return jsonify({"success": False, "error": "Offer amount is required"}), 400

        if not s.counter_offer_1:
            s.counter_offer_1 = amount
            s.counter_offer_1_date = datetime.utcnow()
            s.status = "negotiating"
            offer_num = 1
        elif not s.counter_offer_2:
            s.counter_offer_2 = amount
            s.counter_offer_2_date = datetime.utcnow()
            offer_num = 2
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Maximum of 2 counter-offers allowed. Use settle endpoint to finalize.",
                    }
                ),
                400,
            )

        if data.get("notes"):
            current_notes = s.settlement_notes or ""
            s.settlement_notes = f"[Counter-Offer {offer_num}: ${amount:,.2f}] {data.get('notes')}\n{current_notes}"

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Counter-offer {offer_num} recorded",
                "offer_number": offer_num,
                "amount": amount,
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements/<int:settlement_id>/settle", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_mark_settled(settlement_id):
    """Mark settlement as accepted/settled with final amount"""
    db = get_db()
    try:
        s = db.query(Settlement).filter_by(id=settlement_id).first()
        if not s:
            return jsonify({"success": False, "error": "Settlement not found"}), 404

        data = request.json
        final_amount = data.get("final_amount")

        if not final_amount:
            return (
                jsonify(
                    {"success": False, "error": "Final settlement amount is required"}
                ),
                400,
            )

        s.final_amount = final_amount
        s.status = "accepted"
        s.settled_at = datetime.utcnow()

        if data.get("notes"):
            current_notes = s.settlement_notes or ""
            s.settlement_notes = (
                f"[SETTLED ${final_amount:,.2f}] {data.get('notes')}\n{current_notes}"
            )

        case = db.query(Case).filter_by(id=s.case_id).first()
        if case:
            contingency_percent = case.contingency_percent or 0
            s.contingency_earned = final_amount * (contingency_percent / 100)
            case.status = "settled"

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Settlement marked as accepted",
                "final_amount": final_amount,
                "contingency_earned": s.contingency_earned,
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements/<int:settlement_id>/reject", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_mark_rejected(settlement_id):
    """Mark settlement as rejected"""
    db = get_db()
    try:
        s = db.query(Settlement).filter_by(id=settlement_id).first()
        if not s:
            return jsonify({"success": False, "error": "Settlement not found"}), 404

        data = request.json

        s.status = "rejected"

        if data.get("notes"):
            current_notes = s.settlement_notes or ""
            s.settlement_notes = f"[REJECTED] {data.get('notes')}\n{current_notes}"

        if data.get("move_to_litigation"):
            s.status = "litigated"

        db.commit()

        return jsonify({"success": True, "message": "Settlement marked as rejected"})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements/<int:settlement_id>/payment", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_record_payment(settlement_id):
    """Record payment received for settlement"""
    db = get_db()
    try:
        s = db.query(Settlement).filter_by(id=settlement_id).first()
        if not s:
            return jsonify({"success": False, "error": "Settlement not found"}), 404

        data = request.json
        payment_amount = data.get("amount")

        if not payment_amount:
            return (
                jsonify({"success": False, "error": "Payment amount is required"}),
                400,
            )

        s.payment_received = True
        s.payment_amount = payment_amount
        s.payment_date = datetime.utcnow()

        case = db.query(Case).filter_by(id=s.case_id).first()
        if case:
            contingency_percent = case.contingency_percent or 0
            s.contingency_earned = payment_amount * (contingency_percent / 100)

        if data.get("notes"):
            current_notes = s.settlement_notes or ""
            s.settlement_notes = f"[PAYMENT RECEIVED ${payment_amount:,.2f}] {data.get('notes')}\n{current_notes}"

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Payment recorded",
                "payment_amount": payment_amount,
                "contingency_earned": s.contingency_earned,
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/settlements/stats", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_settlement_stats():
    """Get settlement statistics for analytics"""
    db = get_db()
    try:
        from datetime import date, timedelta

        from sqlalchemy import func

        today = date.today()
        first_of_month = today.replace(day=1)
        first_of_last_month = (first_of_month - timedelta(days=1)).replace(day=1)

        all_settlements = db.query(Settlement).all()

        total_settled = 0
        total_pending = 0
        total_contingency = 0
        settled_amounts = []
        this_month_settled = 0
        last_month_settled = 0

        status_counts = {
            "pending": 0,
            "demand_sent": 0,
            "negotiating": 0,
            "accepted": 0,
            "rejected": 0,
            "litigated": 0,
        }

        for s in all_settlements:
            status = s.status or "pending"
            if status in status_counts:
                status_counts[status] += 1

            if status == "accepted":
                if s.final_amount:
                    total_settled += s.final_amount
                    settled_amounts.append(s.final_amount)

                    if s.settled_at and s.settled_at.date() >= first_of_month:
                        this_month_settled += s.final_amount
                    elif (
                        s.settled_at
                        and s.settled_at.date() >= first_of_last_month
                        and s.settled_at.date() < first_of_month
                    ):
                        last_month_settled += s.final_amount
            else:
                total_pending += s.target_amount or 0

            if s.contingency_earned:
                total_contingency += s.contingency_earned

        total_count = len(all_settlements)
        accepted_count = status_counts["accepted"]
        success_rate = (accepted_count / total_count * 100) if total_count > 0 else 0
        avg_settlement = (
            sum(settled_amounts) / len(settled_amounts) if settled_amounts else 0
        )

        return jsonify(
            {
                "success": True,
                "stats": {
                    "total_settled": total_settled,
                    "total_pending_value": total_pending,
                    "total_contingency": total_contingency,
                    "avg_settlement": avg_settlement,
                    "success_rate": round(success_rate, 1),
                    "total_count": total_count,
                    "accepted_count": accepted_count,
                    "status_counts": status_counts,
                    "this_month_settled": this_month_settled,
                    "last_month_settled": last_month_settled,
                    "month_change": this_month_settled - last_month_settled,
                },
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/case/<int:case_id>/settlement", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_get_case_settlement(case_id):
    """Get settlement for a specific case"""
    db = get_db()
    try:
        settlement = db.query(Settlement).filter_by(case_id=case_id).first()

        if not settlement:
            case = db.query(Case).filter_by(id=case_id).first()
            damages = None
            score = None

            if case and case.analysis_id:
                damages = (
                    db.query(Damages).filter_by(analysis_id=case.analysis_id).first()
                )
                score = (
                    db.query(CaseScore).filter_by(analysis_id=case.analysis_id).first()
                )

            return jsonify(
                {
                    "success": True,
                    "exists": False,
                    "can_create": score.total_score >= 6 if score else False,
                    "suggested_target": damages.settlement_target if damages else 0,
                    "suggested_minimum": damages.minimum_acceptable if damages else 0,
                }
            )

        return jsonify(
            {
                "success": True,
                "exists": True,
                "settlement": {
                    "id": settlement.id,
                    "status": settlement.status,
                    "target_amount": settlement.target_amount,
                    "initial_demand": settlement.initial_demand,
                    "counter_offer_1": settlement.counter_offer_1,
                    "counter_offer_2": settlement.counter_offer_2,
                    "final_amount": settlement.final_amount,
                    "settled_at": (
                        settlement.settled_at.isoformat()
                        if settlement.settled_at
                        else None
                    ),
                    "payment_received": settlement.payment_received,
                    "contingency_earned": settlement.contingency_earned,
                },
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# FURNISHER INTELLIGENCE DATABASE API
# ============================================================


@app.route("/api/furnishers", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_list_furnishers():
    """List all furnishers with optional filters"""
    db = get_db()
    try:
        query = db.query(Furnisher)

        industry = request.args.get("industry")
        if industry:
            query = query.filter(Furnisher.industry == industry)

        search = request.args.get("search", "").strip()
        if search:
            query = query.filter(Furnisher.name.ilike(f"%{search}%"))

        furnishers = query.order_by(Furnisher.name).all()

        result = []
        for f in furnishers:
            stats = f.stats
            result.append(
                {
                    "id": f.id,
                    "name": f.name,
                    "industry": f.industry,
                    "parent_company": f.parent_company,
                    "total_disputes": stats.total_disputes if stats else 0,
                    "round_1_delete_rate": round(
                        (
                            (stats.round_1_deleted / stats.total_disputes * 100)
                            if stats and stats.total_disputes > 0
                            else 0
                        ),
                        1,
                    ),
                    "round_2_delete_rate": round(
                        (
                            (
                                stats.round_2_deleted
                                / (stats.round_1_verified or 1)
                                * 100
                            )
                            if stats and stats.round_1_verified > 0
                            else 0
                        ),
                        1,
                    ),
                    "avg_response_days": (
                        round(stats.avg_response_days, 1) if stats else 0
                    ),
                    "settlement_count": stats.settlement_count if stats else 0,
                    "settlement_avg": round(stats.settlement_avg, 2) if stats else 0,
                    "created_at": f.created_at.isoformat() if f.created_at else None,
                }
            )

        return jsonify({"success": True, "furnishers": result})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_create_furnisher():
    """Create a new furnisher"""
    db = get_db()
    try:
        data = request.get_json() or {}

        name = data.get("name", "").strip()
        if not name:
            return (
                jsonify({"success": False, "error": "Furnisher name is required"}),
                400,
            )

        existing = db.query(Furnisher).filter(Furnisher.name.ilike(name)).first()
        if existing:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Furnisher with this name already exists",
                        "existing_id": existing.id,
                    }
                ),
                400,
            )

        furnisher = Furnisher(
            name=name,
            alternate_names=data.get("alternate_names", []),
            industry=data.get("industry"),
            parent_company=data.get("parent_company"),
            address=data.get("address"),
            phone=data.get("phone"),
            fax=data.get("fax"),
            email=data.get("email"),
            website=data.get("website"),
            dispute_address=data.get("dispute_address"),
            notes=data.get("notes"),
        )
        db.add(furnisher)
        db.flush()

        stats = FurnisherStats(furnisher_id=furnisher.id)
        db.add(stats)
        db.commit()

        return jsonify(
            {
                "success": True,
                "furnisher": {
                    "id": furnisher.id,
                    "name": furnisher.name,
                    "industry": furnisher.industry,
                },
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers/<int:furnisher_id>", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_get_furnisher(furnisher_id):
    """Get furnisher details with stats"""
    db = get_db()
    try:
        furnisher = db.query(Furnisher).filter_by(id=furnisher_id).first()
        if not furnisher:
            return jsonify({"success": False, "error": "Furnisher not found"}), 404

        stats = furnisher.stats

        related_items = (
            db.query(DisputeItem)
            .filter(DisputeItem.creditor_name.ilike(f"%{furnisher.name}%"))
            .order_by(DisputeItem.created_at.desc())
            .limit(20)
            .all()
        )

        related_clients = []
        seen_clients = set()
        for item in related_items:
            if item.client_id not in seen_clients:
                client = db.query(Client).filter_by(id=item.client_id).first()
                if client:
                    related_clients.append(
                        {
                            "id": client.id,
                            "name": client.name,
                            "status": item.status,
                            "dispute_round": item.dispute_round,
                        }
                    )
                    seen_clients.add(item.client_id)

        return jsonify(
            {
                "success": True,
                "furnisher": {
                    "id": furnisher.id,
                    "name": furnisher.name,
                    "alternate_names": furnisher.alternate_names or [],
                    "industry": furnisher.industry,
                    "parent_company": furnisher.parent_company,
                    "address": furnisher.address,
                    "phone": furnisher.phone,
                    "fax": furnisher.fax,
                    "email": furnisher.email,
                    "website": furnisher.website,
                    "dispute_address": furnisher.dispute_address,
                    "notes": furnisher.notes,
                    "created_at": (
                        furnisher.created_at.isoformat()
                        if furnisher.created_at
                        else None
                    ),
                    "updated_at": (
                        furnisher.updated_at.isoformat()
                        if furnisher.updated_at
                        else None
                    ),
                },
                "stats": {
                    "total_disputes": stats.total_disputes if stats else 0,
                    "round_1": {
                        "verified": stats.round_1_verified if stats else 0,
                        "deleted": stats.round_1_deleted if stats else 0,
                        "updated": stats.round_1_updated if stats else 0,
                        "delete_rate": round(
                            (
                                (stats.round_1_deleted / stats.total_disputes * 100)
                                if stats and stats.total_disputes > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "round_2": {
                        "verified": stats.round_2_verified if stats else 0,
                        "deleted": stats.round_2_deleted if stats else 0,
                        "updated": stats.round_2_updated if stats else 0,
                        "delete_rate": round(
                            (
                                (
                                    stats.round_2_deleted
                                    / (stats.round_1_verified or 1)
                                    * 100
                                )
                                if stats and stats.round_1_verified > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "round_3": {
                        "verified": stats.round_3_verified if stats else 0,
                        "deleted": stats.round_3_deleted if stats else 0,
                        "updated": stats.round_3_updated if stats else 0,
                        "delete_rate": round(
                            (
                                (
                                    stats.round_3_deleted
                                    / (stats.round_2_verified or 1)
                                    * 100
                                )
                                if stats and stats.round_2_verified > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "mov": {
                        "requests_sent": stats.mov_requests_sent if stats else 0,
                        "provided": stats.mov_provided if stats else 0,
                        "failed": stats.mov_failed if stats else 0,
                        "failure_rate": round(
                            (
                                (
                                    stats.mov_failed
                                    / (stats.mov_requests_sent or 1)
                                    * 100
                                )
                                if stats and stats.mov_requests_sent > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "avg_response_days": (
                        round(stats.avg_response_days, 1) if stats else 0
                    ),
                    "settlement": {
                        "count": stats.settlement_count if stats else 0,
                        "total": stats.settlement_total if stats else 0,
                        "avg": round(stats.settlement_avg, 2) if stats else 0,
                    },
                    "violation_count": stats.violation_count if stats else 0,
                    "reinsertion_count": stats.reinsertion_count if stats else 0,
                },
                "related_clients": related_clients[:10],
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers/<int:furnisher_id>", methods=["PUT"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_update_furnisher(furnisher_id):
    """Update furnisher info"""
    db = get_db()
    try:
        furnisher = db.query(Furnisher).filter_by(id=furnisher_id).first()
        if not furnisher:
            return jsonify({"success": False, "error": "Furnisher not found"}), 404

        data = request.get_json() or {}

        if "name" in data:
            name = data["name"].strip()
            existing = (
                db.query(Furnisher)
                .filter(Furnisher.name.ilike(name), Furnisher.id != furnisher_id)
                .first()
            )
            if existing:
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "Furnisher with this name already exists",
                        }
                    ),
                    400,
                )
            furnisher.name = name

        if "alternate_names" in data:
            furnisher.alternate_names = data["alternate_names"]
        if "industry" in data:
            furnisher.industry = data["industry"]
        if "parent_company" in data:
            furnisher.parent_company = data["parent_company"]
        if "address" in data:
            furnisher.address = data["address"]
        if "phone" in data:
            furnisher.phone = data["phone"]
        if "fax" in data:
            furnisher.fax = data["fax"]
        if "email" in data:
            furnisher.email = data["email"]
        if "website" in data:
            furnisher.website = data["website"]
        if "dispute_address" in data:
            furnisher.dispute_address = data["dispute_address"]
        if "notes" in data:
            furnisher.notes = data["notes"]

        furnisher.updated_at = datetime.utcnow()
        db.commit()

        return jsonify({"success": True, "message": "Furnisher updated"})
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers/<int:furnisher_id>/stats", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_get_furnisher_stats(furnisher_id):
    """Get detailed stats for a furnisher"""
    db = get_db()
    try:
        furnisher = db.query(Furnisher).filter_by(id=furnisher_id).first()
        if not furnisher:
            return jsonify({"success": False, "error": "Furnisher not found"}), 404

        stats = furnisher.stats
        if not stats:
            return jsonify(
                {
                    "success": True,
                    "stats": None,
                    "message": "No stats available for this furnisher",
                }
            )

        total = stats.total_disputes or 1
        r1_total = (
            stats.round_1_verified + stats.round_1_deleted + stats.round_1_updated
        )
        r2_total = (
            stats.round_2_verified + stats.round_2_deleted + stats.round_2_updated
        )
        r3_total = (
            stats.round_3_verified + stats.round_3_deleted + stats.round_3_updated
        )

        overall_delete_rate = 0
        if total > 0:
            total_deleted = (
                stats.round_1_deleted + stats.round_2_deleted + stats.round_3_deleted
            )
            overall_delete_rate = round(total_deleted / total * 100, 1)

        strategy = "Standard dispute approach"
        if stats.round_1_deleted > stats.round_1_verified and overall_delete_rate > 30:
            strategy = "High success rate - Strong first-round dispute recommended"
        elif stats.mov_failed > stats.mov_provided:
            strategy = "Focus on MOV demands - This furnisher often fails to provide verification"
        elif stats.round_2_deleted > stats.round_1_deleted:
            strategy = "Push to Round 2 - Better success after initial dispute"
        elif stats.settlement_count > 0:
            strategy = f"Settlement possible - Average ${stats.settlement_avg:,.0f}"
        elif stats.violation_count > 0:
            strategy = "Document violations - History of FCRA violations detected"

        return jsonify(
            {
                "success": True,
                "stats": {
                    "total_disputes": stats.total_disputes,
                    "round_1": {
                        "verified": stats.round_1_verified,
                        "deleted": stats.round_1_deleted,
                        "updated": stats.round_1_updated,
                        "total": r1_total,
                        "delete_rate": round(
                            (
                                (stats.round_1_deleted / r1_total * 100)
                                if r1_total > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "round_2": {
                        "verified": stats.round_2_verified,
                        "deleted": stats.round_2_deleted,
                        "updated": stats.round_2_updated,
                        "total": r2_total,
                        "delete_rate": round(
                            (
                                (stats.round_2_deleted / r2_total * 100)
                                if r2_total > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "round_3": {
                        "verified": stats.round_3_verified,
                        "deleted": stats.round_3_deleted,
                        "updated": stats.round_3_updated,
                        "total": r3_total,
                        "delete_rate": round(
                            (
                                (stats.round_3_deleted / r3_total * 100)
                                if r3_total > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "mov": {
                        "requests_sent": stats.mov_requests_sent,
                        "provided": stats.mov_provided,
                        "failed": stats.mov_failed,
                        "failure_rate": round(
                            (
                                (
                                    stats.mov_failed
                                    / (stats.mov_requests_sent or 1)
                                    * 100
                                )
                                if stats.mov_requests_sent > 0
                                else 0
                            ),
                            1,
                        ),
                    },
                    "avg_response_days": round(stats.avg_response_days, 1),
                    "settlement": {
                        "count": stats.settlement_count,
                        "total": stats.settlement_total,
                        "avg": round(stats.settlement_avg, 2),
                    },
                    "violation_count": stats.violation_count,
                    "reinsertion_count": stats.reinsertion_count,
                    "overall_delete_rate": overall_delete_rate,
                    "recommended_strategy": strategy,
                },
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers/<int:furnisher_id>/record-outcome", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_record_furnisher_outcome(furnisher_id):
    """Record a dispute outcome and update furnisher stats"""
    db = get_db()
    try:
        furnisher = db.query(Furnisher).filter_by(id=furnisher_id).first()
        if not furnisher:
            return jsonify({"success": False, "error": "Furnisher not found"}), 404

        data = request.get_json() or {}
        outcome_type = data.get("outcome_type")
        dispute_round = data.get("dispute_round", 1)
        response_days = data.get("response_days")
        settlement_amount = data.get("settlement_amount")
        is_violation = data.get("is_violation", False)
        is_reinsertion = data.get("is_reinsertion", False)
        is_mov_request = data.get("is_mov_request", False)
        mov_provided = data.get("mov_provided")

        if not outcome_type:
            return jsonify({"success": False, "error": "outcome_type is required"}), 400

        stats = furnisher.stats
        if not stats:
            stats = FurnisherStats(furnisher_id=furnisher.id)
            db.add(stats)

        stats.total_disputes = (stats.total_disputes or 0) + 1

        if dispute_round == 1:
            if outcome_type == "verified":
                stats.round_1_verified = (stats.round_1_verified or 0) + 1
            elif outcome_type == "deleted":
                stats.round_1_deleted = (stats.round_1_deleted or 0) + 1
            elif outcome_type == "updated":
                stats.round_1_updated = (stats.round_1_updated or 0) + 1
        elif dispute_round == 2:
            if outcome_type == "verified":
                stats.round_2_verified = (stats.round_2_verified or 0) + 1
            elif outcome_type == "deleted":
                stats.round_2_deleted = (stats.round_2_deleted or 0) + 1
            elif outcome_type == "updated":
                stats.round_2_updated = (stats.round_2_updated or 0) + 1
        elif dispute_round >= 3:
            if outcome_type == "verified":
                stats.round_3_verified = (stats.round_3_verified or 0) + 1
            elif outcome_type == "deleted":
                stats.round_3_deleted = (stats.round_3_deleted or 0) + 1
            elif outcome_type == "updated":
                stats.round_3_updated = (stats.round_3_updated or 0) + 1

        if response_days is not None:
            current_avg = stats.avg_response_days or 0
            current_count = stats.total_disputes - 1
            if current_count > 0:
                stats.avg_response_days = (
                    current_avg * current_count + response_days
                ) / stats.total_disputes
            else:
                stats.avg_response_days = response_days

        if is_mov_request:
            stats.mov_requests_sent = (stats.mov_requests_sent or 0) + 1
            if mov_provided is True:
                stats.mov_provided = (stats.mov_provided or 0) + 1
            elif mov_provided is False:
                stats.mov_failed = (stats.mov_failed or 0) + 1

        if settlement_amount and settlement_amount > 0:
            stats.settlement_count = (stats.settlement_count or 0) + 1
            stats.settlement_total = (stats.settlement_total or 0) + settlement_amount
            stats.settlement_avg = stats.settlement_total / stats.settlement_count

        if is_violation:
            stats.violation_count = (stats.violation_count or 0) + 1

        if is_reinsertion:
            stats.reinsertion_count = (stats.reinsertion_count or 0) + 1

        stats.updated_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Outcome recorded",
                "stats": {
                    "total_disputes": stats.total_disputes,
                    "round_1_deleted": stats.round_1_deleted,
                    "round_2_deleted": stats.round_2_deleted,
                    "round_3_deleted": stats.round_3_deleted,
                },
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers/leaderboard", methods=["GET"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_furnisher_leaderboard():
    """Get furnisher leaderboard - top/bottom performers"""
    db = get_db()
    try:
        metric = request.args.get("metric", "deletion_rate")
        limit = int(request.args.get("limit", 10))
        order = request.args.get("order", "desc")

        furnishers = (
            db.query(Furnisher)
            .join(FurnisherStats)
            .filter(FurnisherStats.total_disputes >= 1)
            .all()
        )

        results = []
        for f in furnishers:
            stats = f.stats
            if not stats:
                continue

            total = stats.total_disputes or 1
            total_deleted = (
                (stats.round_1_deleted or 0)
                + (stats.round_2_deleted or 0)
                + (stats.round_3_deleted or 0)
            )
            deletion_rate = total_deleted / total * 100

            r1_total = (
                (stats.round_1_verified or 0)
                + (stats.round_1_deleted or 0)
                + (stats.round_1_updated or 0)
            )
            r1_delete_rate = (
                (stats.round_1_deleted / r1_total * 100) if r1_total > 0 else 0
            )

            mov_failure_rate = (
                (stats.mov_failed / (stats.mov_requests_sent or 1) * 100)
                if (stats.mov_requests_sent or 0) > 0
                else 0
            )

            results.append(
                {
                    "id": f.id,
                    "name": f.name,
                    "industry": f.industry,
                    "total_disputes": stats.total_disputes,
                    "deletion_rate": round(deletion_rate, 1),
                    "r1_delete_rate": round(r1_delete_rate, 1),
                    "avg_response_days": round(stats.avg_response_days or 0, 1),
                    "settlement_avg": round(stats.settlement_avg or 0, 2),
                    "settlement_count": stats.settlement_count or 0,
                    "mov_failure_rate": round(mov_failure_rate, 1),
                    "violation_count": stats.violation_count or 0,
                }
            )

        sort_key = {
            "deletion_rate": lambda x: x["deletion_rate"],
            "r1_delete_rate": lambda x: x["r1_delete_rate"],
            "response_time": lambda x: x["avg_response_days"],
            "settlement_avg": lambda x: x["settlement_avg"],
            "total_disputes": lambda x: x["total_disputes"],
            "mov_failure_rate": lambda x: x["mov_failure_rate"],
            "violations": lambda x: x["violation_count"],
        }.get(metric, lambda x: x["deletion_rate"])

        reverse_order = order == "desc" if metric != "response_time" else order == "asc"
        results.sort(key=sort_key, reverse=reverse_order)

        return jsonify(
            {
                "success": True,
                "leaderboard": results[:limit],
                "metric": metric,
                "order": order,
                "total_furnishers": len(results),
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers/populate", methods=["POST"])
@require_staff(roles=["admin"])
def api_populate_furnishers():
    """Populate furnisher database from existing dispute items"""
    db = get_db()
    try:
        from sqlalchemy import func

        creditor_counts = (
            db.query(
                DisputeItem.creditor_name, func.count(DisputeItem.id).label("count")
            )
            .filter(DisputeItem.creditor_name != None, DisputeItem.creditor_name != "")
            .group_by(DisputeItem.creditor_name)
            .all()
        )

        created = 0
        updated = 0

        for creditor_name, count in creditor_counts:
            if not creditor_name or len(creditor_name.strip()) < 2:
                continue

            name = creditor_name.strip()

            existing = db.query(Furnisher).filter(Furnisher.name.ilike(name)).first()

            if not existing:
                furnisher = Furnisher(name=name)
                db.add(furnisher)
                db.flush()

                stats = FurnisherStats(furnisher_id=furnisher.id)
                db.add(stats)
                created += 1
            else:
                furnisher = existing
                stats = furnisher.stats
                if not stats:
                    stats = FurnisherStats(furnisher_id=furnisher.id)
                    db.add(stats)
                updated += 1

            items = (
                db.query(DisputeItem)
                .filter(DisputeItem.creditor_name.ilike(name))
                .all()
            )

            stats.total_disputes = len(items)

            for item in items:
                round_num = item.dispute_round or 1
                status = item.status or ""

                if round_num == 1:
                    if status == "deleted":
                        stats.round_1_deleted = (stats.round_1_deleted or 0) + 1
                    elif status == "updated":
                        stats.round_1_updated = (stats.round_1_updated or 0) + 1
                    elif status in ["sent", "no_change", "no_answer"]:
                        stats.round_1_verified = (stats.round_1_verified or 0) + 1
                elif round_num == 2:
                    if status == "deleted":
                        stats.round_2_deleted = (stats.round_2_deleted or 0) + 1
                    elif status == "updated":
                        stats.round_2_updated = (stats.round_2_updated or 0) + 1
                    elif status in ["sent", "no_change", "no_answer"]:
                        stats.round_2_verified = (stats.round_2_verified or 0) + 1
                elif round_num >= 3:
                    if status == "deleted":
                        stats.round_3_deleted = (stats.round_3_deleted or 0) + 1
                    elif status == "updated":
                        stats.round_3_updated = (stats.round_3_updated or 0) + 1
                    elif status in ["sent", "no_change", "no_answer"]:
                        stats.round_3_verified = (stats.round_3_verified or 0) + 1

            stats.updated_at = datetime.utcnow()

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Populated furnisher database",
                "created": created,
                "updated": updated,
                "total": created + updated,
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/furnishers/match", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_match_furnisher():
    """Match a creditor name to an existing furnisher"""
    db = get_db()
    try:
        data = request.get_json() or {}
        creditor_name = data.get("creditor_name", "").strip()

        if not creditor_name:
            return (
                jsonify({"success": False, "error": "creditor_name is required"}),
                400,
            )

        exact = db.query(Furnisher).filter(Furnisher.name.ilike(creditor_name)).first()
        if exact:
            return jsonify(
                {
                    "success": True,
                    "match_type": "exact",
                    "furnisher": {
                        "id": exact.id,
                        "name": exact.name,
                        "industry": exact.industry,
                    },
                }
            )

        partial = (
            db.query(Furnisher)
            .filter(Furnisher.name.ilike(f"%{creditor_name}%"))
            .limit(5)
            .all()
        )

        if partial:
            return jsonify(
                {
                    "success": True,
                    "match_type": "partial",
                    "matches": [
                        {"id": f.id, "name": f.name, "industry": f.industry}
                        for f in partial
                    ],
                }
            )

        return jsonify(
            {
                "success": True,
                "match_type": "none",
                "message": "No matching furnisher found. Consider creating a new one.",
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/furnishers")
@require_staff(roles=["admin", "attorney", "paralegal"])
def dashboard_furnishers():
    """Furnisher intelligence database dashboard"""
    db = get_db()
    try:
        furnishers = db.query(Furnisher).order_by(Furnisher.name).all()

        total_furnishers = len(furnishers)
        total_disputes = 0
        best_deletion = None
        best_deletion_rate = 0
        worst_response = None
        worst_response_days = 0
        most_common = None
        most_common_count = 0

        for f in furnishers:
            stats = f.stats
            if stats:
                total_disputes += stats.total_disputes or 0

                if stats.total_disputes and stats.total_disputes > most_common_count:
                    most_common = f.name
                    most_common_count = stats.total_disputes

                if stats.total_disputes and stats.total_disputes > 0:
                    del_rate = (stats.round_1_deleted or 0) / stats.total_disputes * 100
                    if del_rate > best_deletion_rate:
                        best_deletion = f.name
                        best_deletion_rate = del_rate

                if (stats.avg_response_days or 0) > worst_response_days:
                    worst_response = f.name
                    worst_response_days = stats.avg_response_days or 0

        industries = [
            "bank",
            "collection_agency",
            "credit_card",
            "auto_loan",
            "mortgage",
            "medical",
            "utility",
            "student_loan",
            "other",
        ]

        return render_template(
            "furnishers.html",
            furnishers=furnishers,
            total_furnishers=total_furnishers,
            total_disputes=total_disputes,
            best_deletion=best_deletion,
            best_deletion_rate=round(best_deletion_rate, 1),
            worst_response=worst_response,
            worst_response_days=round(worst_response_days, 1),
            most_common=most_common,
            most_common_count=most_common_count,
            industries=industries,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error loading furnishers: {e}", 500
    finally:
        db.close()


@app.route("/dashboard/furnisher/<int:furnisher_id>")
@require_staff(roles=["admin", "attorney", "paralegal"])
def dashboard_furnisher_detail(furnisher_id):
    """Furnisher profile page"""
    db = get_db()
    try:
        furnisher = db.query(Furnisher).filter_by(id=furnisher_id).first()
        if not furnisher:
            return (
                render_template(
                    "error.html", error="Not Found", message="Furnisher not found"
                ),
                404,
            )

        stats = furnisher.stats

        related_items = (
            db.query(DisputeItem)
            .filter(DisputeItem.creditor_name.ilike(f"%{furnisher.name}%"))
            .order_by(DisputeItem.created_at.desc())
            .limit(50)
            .all()
        )

        related_clients = []
        seen_clients = set()
        for item in related_items:
            if item.client_id not in seen_clients:
                client = db.query(Client).filter_by(id=item.client_id).first()
                if client:
                    related_clients.append(
                        {
                            "id": client.id,
                            "name": client.name,
                            "status": item.status,
                            "dispute_round": item.dispute_round,
                            "created_at": item.created_at,
                        }
                    )
                    seen_clients.add(item.client_id)

        strategy = "Standard dispute approach"
        if stats:
            total = stats.total_disputes or 1
            total_deleted = (
                (stats.round_1_deleted or 0)
                + (stats.round_2_deleted or 0)
                + (stats.round_3_deleted or 0)
            )
            overall_delete_rate = total_deleted / total * 100

            if (
                stats.round_1_deleted
                and stats.round_1_deleted > (stats.round_1_verified or 0)
                and overall_delete_rate > 30
            ):
                strategy = "High success rate - Strong first-round dispute recommended"
            elif (stats.mov_failed or 0) > (stats.mov_provided or 0):
                strategy = "Focus on MOV demands - This furnisher often fails to provide verification"
            elif (stats.round_2_deleted or 0) > (stats.round_1_deleted or 0):
                strategy = "Push to Round 2 - Better success after initial dispute"
            elif stats.settlement_count and stats.settlement_count > 0:
                strategy = f"Settlement possible - Average ${stats.settlement_avg:,.0f}"
            elif stats.violation_count and stats.violation_count > 0:
                strategy = "Document violations - History of FCRA violations detected"

        industries = [
            "bank",
            "collection_agency",
            "credit_card",
            "auto_loan",
            "mortgage",
            "medical",
            "utility",
            "student_loan",
            "other",
        ]

        return render_template(
            "furnisher_detail.html",
            furnisher=furnisher,
            stats=stats,
            related_clients=related_clients[:20],
            strategy=strategy,
            industries=industries,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error loading furnisher: {e}", 500
    finally:
        db.close()


# ============================================================
# PATTERN DOCUMENTATION (Systemic Violations)
# ============================================================


@app.route("/dashboard/patterns")
@require_staff(roles=["admin", "attorney"])
def dashboard_patterns():
    """Violation patterns dashboard - track systemic violations"""
    db = get_db()
    try:
        patterns = (
            db.query(ViolationPattern)
            .order_by(ViolationPattern.created_at.desc())
            .all()
        )

        total_patterns = len(patterns)
        total_clients_affected = sum(p.clients_affected or 0 for p in patterns)
        total_damages = sum(p.total_damages_estimate or 0 for p in patterns)
        ready_for_action = sum(1 for p in patterns if p.status == "ready_for_action")

        furnishers = db.query(Furnisher).order_by(Furnisher.name).all()
        furnisher_names = [f.name for f in furnishers]

        return render_template(
            "violation_patterns.html",
            patterns=patterns,
            total_patterns=total_patterns,
            total_clients_affected=total_clients_affected,
            total_damages=total_damages,
            ready_for_action=ready_for_action,
            furnisher_names=furnisher_names,
            cras=["Equifax", "Experian", "TransUnion"],
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error loading patterns: {e}", 500
    finally:
        db.close()


@app.route("/api/patterns/create", methods=["POST"])
@require_staff(roles=["admin", "attorney"])
def api_patterns_create():
    """Create a new violation pattern"""
    db = get_db()
    try:
        data = request.get_json() or {}

        pattern_name = data.get("pattern_name", "").strip()
        if not pattern_name:
            return jsonify({"success": False, "error": "Pattern name is required"}), 400

        pattern = ViolationPattern(
            pattern_name=pattern_name,
            pattern_type=data.get("pattern_type", "furnisher_practice"),
            target_type=data.get("target_type", "furnisher"),
            furnisher_name=data.get("furnisher_name"),
            cra_name=data.get("cra_name"),
            violation_code=data.get("violation_code"),
            violation_type=data.get("violation_type"),
            violation_description=data.get("violation_description"),
            evidence_strength=data.get("evidence_strength", "moderate"),
            recommended_strategy=data.get("recommended_strategy", "individual_suits"),
            strategy_notes=data.get("strategy_notes"),
            status=data.get("status", "monitoring"),
            priority=data.get("priority", "medium"),
            admin_notes=data.get("admin_notes"),
            created_by_staff_id=session.get("staff_id"),
        )

        db.add(pattern)
        db.commit()

        return jsonify(
            {
                "success": True,
                "pattern_id": pattern.id,
                "message": "Pattern created successfully",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/patterns/<int:pattern_id>")
@require_staff(roles=["admin", "attorney"])
def api_pattern_details(pattern_id):
    """Get pattern details with linked violations"""
    db = get_db()
    try:
        pattern = db.query(ViolationPattern).filter_by(id=pattern_id).first()
        if not pattern:
            return jsonify({"success": False, "error": "Pattern not found"}), 404

        instances = db.query(PatternInstance).filter_by(pattern_id=pattern_id).all()

        linked_violations = []
        for inst in instances:
            violation = db.query(Violation).filter_by(id=inst.violation_id).first()
            client = db.query(Client).filter_by(id=inst.client_id).first()

            linked_violations.append(
                {
                    "instance_id": inst.id,
                    "violation_id": inst.violation_id,
                    "client_id": inst.client_id,
                    "client_name": client.name if client else "Unknown",
                    "occurrence_date": (
                        inst.occurrence_date.isoformat()
                        if inst.occurrence_date
                        else None
                    ),
                    "instance_description": inst.instance_description,
                    "damages_for_instance": inst.damages_for_instance or 0,
                    "included_in_packet": inst.included_in_packet,
                    "violation_type": violation.violation_type if violation else None,
                    "bureau": violation.bureau if violation else None,
                    "account_name": violation.account_name if violation else None,
                }
            )

        return jsonify(
            {
                "success": True,
                "pattern": pattern.to_dict(),
                "pattern_full": {
                    "id": pattern.id,
                    "pattern_name": pattern.pattern_name,
                    "pattern_type": pattern.pattern_type,
                    "target_type": pattern.target_type,
                    "furnisher_name": pattern.furnisher_name,
                    "cra_name": pattern.cra_name,
                    "violation_code": pattern.violation_code,
                    "violation_type": pattern.violation_type,
                    "violation_description": pattern.violation_description,
                    "occurrences_count": pattern.occurrences_count,
                    "clients_affected": pattern.clients_affected,
                    "total_damages_estimate": pattern.total_damages_estimate,
                    "avg_damages_per_client": pattern.avg_damages_per_client,
                    "earliest_occurrence": (
                        pattern.earliest_occurrence.isoformat()
                        if pattern.earliest_occurrence
                        else None
                    ),
                    "latest_occurrence": (
                        pattern.latest_occurrence.isoformat()
                        if pattern.latest_occurrence
                        else None
                    ),
                    "evidence_packet_path": pattern.evidence_packet_path,
                    "evidence_summary": pattern.evidence_summary,
                    "evidence_strength": pattern.evidence_strength,
                    "recommended_strategy": pattern.recommended_strategy,
                    "strategy_notes": pattern.strategy_notes,
                    "case_law_citations": pattern.case_law_citations,
                    "status": pattern.status,
                    "priority": pattern.priority,
                    "cfpb_complaint_filed": pattern.cfpb_complaint_filed,
                    "cfpb_complaint_date": (
                        pattern.cfpb_complaint_date.isoformat()
                        if pattern.cfpb_complaint_date
                        else None
                    ),
                    "cfpb_complaint_id": pattern.cfpb_complaint_id,
                    "litigation_filed": pattern.litigation_filed,
                    "litigation_date": (
                        pattern.litigation_date.isoformat()
                        if pattern.litigation_date
                        else None
                    ),
                    "litigation_case_number": pattern.litigation_case_number,
                    "admin_notes": pattern.admin_notes,
                    "created_at": (
                        pattern.created_at.isoformat() if pattern.created_at else None
                    ),
                },
                "linked_violations": linked_violations,
                "total_linked": len(linked_violations),
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/patterns/<int:pattern_id>/add-instance", methods=["POST"])
@require_staff(roles=["admin", "attorney"])
def api_pattern_add_instance(pattern_id):
    """Link a violation to a pattern"""
    db = get_db()
    try:
        pattern = db.query(ViolationPattern).filter_by(id=pattern_id).first()
        if not pattern:
            return jsonify({"success": False, "error": "Pattern not found"}), 404

        data = request.get_json() or {}
        violation_id = data.get("violation_id")
        client_id = data.get("client_id")

        if not violation_id:
            return jsonify({"success": False, "error": "violation_id is required"}), 400

        violation = db.query(Violation).filter_by(id=violation_id).first()
        if not violation:
            return jsonify({"success": False, "error": "Violation not found"}), 404

        if not client_id:
            client_id = violation.client_id

        existing = (
            db.query(PatternInstance)
            .filter_by(pattern_id=pattern_id, violation_id=violation_id)
            .first()
        )
        if existing:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Violation already linked to this pattern",
                    }
                ),
                400,
            )

        occurrence_date = None
        if data.get("occurrence_date"):
            try:
                occurrence_date = datetime.fromisoformat(
                    data["occurrence_date"].replace("Z", "+00:00")
                ).date()
            except:
                pass
        elif violation.violation_date:
            occurrence_date = violation.violation_date

        instance = PatternInstance(
            pattern_id=pattern_id,
            violation_id=violation_id,
            client_id=client_id,
            occurrence_date=occurrence_date,
            instance_description=data.get(
                "instance_description", violation.description
            ),
            damages_for_instance=data.get(
                "damages_for_instance", violation.statutory_damages_min or 0
            ),
            evidence_notes=data.get("evidence_notes"),
        )
        db.add(instance)

        pattern.occurrences_count = (pattern.occurrences_count or 0) + 1

        existing_clients = (
            db.query(PatternInstance.client_id)
            .filter_by(pattern_id=pattern_id)
            .distinct()
            .count()
        )
        is_new_client = (
            not db.query(PatternInstance)
            .filter_by(pattern_id=pattern_id, client_id=client_id)
            .filter(PatternInstance.id != instance.id)
            .first()
        )
        if is_new_client:
            pattern.clients_affected = existing_clients + 1

        pattern.total_damages_estimate = (pattern.total_damages_estimate or 0) + (
            instance.damages_for_instance or 0
        )

        if pattern.clients_affected and pattern.clients_affected > 0:
            pattern.avg_damages_per_client = (
                pattern.total_damages_estimate / pattern.clients_affected
            )

        if occurrence_date:
            if (
                not pattern.earliest_occurrence
                or occurrence_date < pattern.earliest_occurrence
            ):
                pattern.earliest_occurrence = occurrence_date
            if (
                not pattern.latest_occurrence
                or occurrence_date > pattern.latest_occurrence
            ):
                pattern.latest_occurrence = occurrence_date

        db.commit()

        return jsonify(
            {
                "success": True,
                "instance_id": instance.id,
                "message": "Violation linked to pattern successfully",
                "pattern_stats": {
                    "occurrences_count": pattern.occurrences_count,
                    "clients_affected": pattern.clients_affected,
                    "total_damages_estimate": pattern.total_damages_estimate,
                },
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/patterns/<int:pattern_id>/generate-packet", methods=["POST"])
@require_staff(roles=["admin", "attorney"])
def api_pattern_generate_packet(pattern_id):
    """Generate evidence packet PDF for a pattern"""
    db = get_db()
    try:
        pattern = db.query(ViolationPattern).filter_by(id=pattern_id).first()
        if not pattern:
            return jsonify({"success": False, "error": "Pattern not found"}), 404

        instances = db.query(PatternInstance).filter_by(pattern_id=pattern_id).all()

        evidence_data = []
        for inst in instances:
            violation = db.query(Violation).filter_by(id=inst.violation_id).first()
            client = db.query(Client).filter_by(id=inst.client_id).first()

            evidence_data.append(
                {
                    "client_name": client.name if client else "Unknown",
                    "client_id": inst.client_id,
                    "violation_type": (
                        violation.violation_type if violation else "Unknown"
                    ),
                    "bureau": violation.bureau if violation else "Unknown",
                    "account_name": violation.account_name if violation else "Unknown",
                    "occurrence_date": (
                        inst.occurrence_date.strftime("%Y-%m-%d")
                        if inst.occurrence_date
                        else "Unknown"
                    ),
                    "description": inst.instance_description
                    or (violation.description if violation else ""),
                    "damages": inst.damages_for_instance or 0,
                    "evidence_notes": inst.evidence_notes,
                }
            )

            inst.included_in_packet = True
            inst.included_date = datetime.utcnow()

        os.makedirs("static/generated_letters", exist_ok=True)
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        safe_name = (
            re.sub(r"[^\w\s-]", "", pattern.pattern_name).strip().replace(" ", "_")[:30]
        )
        filename = f"evidence_packet_{safe_name}_{timestamp}.pdf"
        filepath = os.path.join("static/generated_letters", filename)

        try:
            from reportlab.lib import colors
            from reportlab.lib.pagesizes import letter
            from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
            from reportlab.lib.units import inch
            from reportlab.platypus import (
                Paragraph,
                SimpleDocTemplate,
                Spacer,
                Table,
                TableStyle,
            )

            doc = SimpleDocTemplate(
                filepath, pagesize=letter, topMargin=0.5 * inch, bottomMargin=0.5 * inch
            )
            styles = getSampleStyleSheet()

            title_style = ParagraphStyle(
                "TitleStyle",
                parent=styles["Heading1"],
                fontSize=18,
                spaceAfter=20,
                textColor=colors.HexColor("#1a1a2e"),
            )
            heading_style = ParagraphStyle(
                "HeadingStyle",
                parent=styles["Heading2"],
                fontSize=14,
                spaceAfter=12,
                textColor=colors.HexColor("#319795"),
            )
            body_style = ParagraphStyle(
                "BodyStyle", parent=styles["Normal"], fontSize=11, spaceAfter=8
            )

            story = []

            story.append(
                Paragraph("FCRA VIOLATION PATTERN EVIDENCE PACKET", title_style)
            )
            story.append(Paragraph(f"Pattern: {pattern.pattern_name}", heading_style))
            story.append(Spacer(1, 0.2 * inch))

            story.append(Paragraph("PATTERN SUMMARY", heading_style))

            summary_data = [
                [
                    "Pattern Type:",
                    pattern.pattern_type or "N/A",
                    "Target:",
                    pattern.furnisher_name or pattern.cra_name or "N/A",
                ],
                [
                    "Occurrences:",
                    str(pattern.occurrences_count or 0),
                    "Clients Affected:",
                    str(pattern.clients_affected or 0),
                ],
                [
                    "Total Damages:",
                    f"${pattern.total_damages_estimate or 0:,.2f}",
                    "Evidence Strength:",
                    (pattern.evidence_strength or "N/A").title(),
                ],
                [
                    "Status:",
                    (pattern.status or "N/A").replace("_", " ").title(),
                    "Priority:",
                    (pattern.priority or "N/A").title(),
                ],
            ]

            summary_table = Table(
                summary_data, colWidths=[1.5 * inch, 2 * inch, 1.5 * inch, 2 * inch]
            )
            summary_table.setStyle(
                TableStyle(
                    [
                        ("FONTNAME", (0, 0), (-1, -1), "Helvetica"),
                        ("FONTSIZE", (0, 0), (-1, -1), 10),
                        ("FONTNAME", (0, 0), (0, -1), "Helvetica-Bold"),
                        ("FONTNAME", (2, 0), (2, -1), "Helvetica-Bold"),
                        ("BOTTOMPADDING", (0, 0), (-1, -1), 8),
                        ("TOPPADDING", (0, 0), (-1, -1), 8),
                    ]
                )
            )
            story.append(summary_table)
            story.append(Spacer(1, 0.3 * inch))

            if pattern.recommended_strategy:
                strategy_labels = {
                    "class_action": "Class Action Lawsuit",
                    "individual_suits": "Individual Lawsuits",
                    "regulatory_complaint": "Regulatory Complaint (CFPB)",
                }
                strategy = strategy_labels.get(
                    pattern.recommended_strategy,
                    pattern.recommended_strategy.replace("_", " ").title(),
                )
                story.append(
                    Paragraph(f"RECOMMENDED STRATEGY: {strategy}", heading_style)
                )
                if pattern.strategy_notes:
                    story.append(Paragraph(pattern.strategy_notes, body_style))
                story.append(Spacer(1, 0.2 * inch))

            story.append(
                Paragraph(
                    f"LINKED VIOLATIONS ({len(evidence_data)} instances)", heading_style
                )
            )

            if evidence_data:
                table_data = [["Client", "Violation Type", "Bureau", "Date", "Damages"]]
                for ev in evidence_data:
                    table_data.append(
                        [
                            ev["client_name"][:20],
                            (
                                ev["violation_type"][:25]
                                if ev["violation_type"]
                                else "N/A"
                            ),
                            ev["bureau"] or "N/A",
                            ev["occurrence_date"],
                            f"${ev['damages']:,.0f}",
                        ]
                    )

                evidence_table = Table(
                    table_data,
                    colWidths=[1.5 * inch, 2 * inch, 1 * inch, 1 * inch, 1 * inch],
                )
                evidence_table.setStyle(
                    TableStyle(
                        [
                            ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor("#319795")),
                            ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
                            ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                            ("FONTSIZE", (0, 0), (-1, -1), 9),
                            ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                            ("ALIGN", (4, 0), (4, -1), "RIGHT"),
                            ("BOTTOMPADDING", (0, 0), (-1, -1), 6),
                            ("TOPPADDING", (0, 0), (-1, -1), 6),
                            ("GRID", (0, 0), (-1, -1), 0.5, colors.HexColor("#e2e8f0")),
                            (
                                "ROWBACKGROUNDS",
                                (0, 1),
                                (-1, -1),
                                [colors.white, colors.HexColor("#f8fafc")],
                            ),
                        ]
                    )
                )
                story.append(evidence_table)
            else:
                story.append(
                    Paragraph("No violations linked to this pattern yet.", body_style)
                )

            story.append(Spacer(1, 0.3 * inch))
            story.append(
                Paragraph(
                    f"Generated: {datetime.utcnow().strftime('%B %d, %Y at %I:%M %p UTC')}",
                    body_style,
                )
            )
            story.append(
                Paragraph(
                    "This document is confidential attorney work product.", body_style
                )
            )

            doc.build(story)

        except ImportError:
            with open(filepath, "w") as f:
                f.write(f"EVIDENCE PACKET: {pattern.pattern_name}\n")
                f.write(f"Generated: {datetime.utcnow()}\n\n")
                f.write(f"Occurrences: {pattern.occurrences_count}\n")
                f.write(f"Clients Affected: {pattern.clients_affected}\n")
                f.write(
                    f"Total Damages: ${pattern.total_damages_estimate or 0:,.2f}\n\n"
                )
                for ev in evidence_data:
                    f.write(
                        f"- {ev['client_name']}: {ev['violation_type']} ({ev['occurrence_date']}) - ${ev['damages']:,.0f}\n"
                    )

        pattern.evidence_packet_path = filepath
        db.commit()

        return jsonify(
            {
                "success": True,
                "filepath": f"/static/generated_letters/{filename}",
                "filename": filename,
                "instances_included": len(evidence_data),
                "message": "Evidence packet generated successfully",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/patterns/<int:pattern_id>/update", methods=["POST"])
@require_staff(roles=["admin", "attorney"])
def api_pattern_update(pattern_id):
    """Update pattern status and details"""
    db = get_db()
    try:
        pattern = db.query(ViolationPattern).filter_by(id=pattern_id).first()
        if not pattern:
            return jsonify({"success": False, "error": "Pattern not found"}), 404

        data = request.get_json() or {}

        updatable_fields = [
            "pattern_name",
            "pattern_type",
            "target_type",
            "furnisher_name",
            "cra_name",
            "violation_code",
            "violation_type",
            "violation_description",
            "evidence_strength",
            "evidence_summary",
            "recommended_strategy",
            "strategy_notes",
            "status",
            "priority",
            "admin_notes",
        ]

        for field in updatable_fields:
            if field in data:
                setattr(pattern, field, data[field])

        if data.get("cfpb_complaint_filed"):
            pattern.cfpb_complaint_filed = True
            if data.get("cfpb_complaint_date"):
                try:
                    pattern.cfpb_complaint_date = datetime.fromisoformat(
                        data["cfpb_complaint_date"].replace("Z", "+00:00")
                    ).date()
                except:
                    pass
            pattern.cfpb_complaint_id = data.get("cfpb_complaint_id")

        if data.get("litigation_filed"):
            pattern.litigation_filed = True
            if data.get("litigation_date"):
                try:
                    pattern.litigation_date = datetime.fromisoformat(
                        data["litigation_date"].replace("Z", "+00:00")
                    ).date()
                except:
                    pass
            pattern.litigation_case_number = data.get("litigation_case_number")

        if data.get("case_law_citations"):
            pattern.case_law_citations = data["case_law_citations"]

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Pattern updated successfully",
                "pattern": pattern.to_dict(),
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/patterns/<int:pattern_id>/available-violations")
@require_staff(roles=["admin", "attorney"])
def api_pattern_available_violations(pattern_id):
    """Get violations that can be linked to a pattern"""
    db = get_db()
    try:
        pattern = db.query(ViolationPattern).filter_by(id=pattern_id).first()
        if not pattern:
            return jsonify({"success": False, "error": "Pattern not found"}), 404

        linked_ids = [
            inst.violation_id
            for inst in db.query(PatternInstance).filter_by(pattern_id=pattern_id).all()
        ]

        query = db.query(Violation)

        if pattern.furnisher_name:
            query = query.filter(
                Violation.account_name.ilike(f"%{pattern.furnisher_name}%")
            )
        if pattern.cra_name:
            query = query.filter(Violation.bureau.ilike(f"%{pattern.cra_name}%"))
        if pattern.violation_type:
            query = query.filter(
                Violation.violation_type.ilike(f"%{pattern.violation_type}%")
            )

        if linked_ids:
            query = query.filter(~Violation.id.in_(linked_ids))

        violations = query.order_by(Violation.created_at.desc()).limit(100).all()

        result = []
        for v in violations:
            client = db.query(Client).filter_by(id=v.client_id).first()
            result.append(
                {
                    "id": v.id,
                    "client_id": v.client_id,
                    "client_name": client.name if client else "Unknown",
                    "bureau": v.bureau,
                    "account_name": v.account_name,
                    "violation_type": v.violation_type,
                    "description": v.description[:100] if v.description else "",
                    "statutory_damages_min": v.statutory_damages_min or 0,
                    "violation_date": (
                        v.violation_date.isoformat() if v.violation_date else None
                    ),
                }
            )

        return jsonify({"success": True, "violations": result, "total": len(result)})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# STATUTE OF LIMITATIONS (SOL) CALCULATOR API
# FCRA ¬ß 1681p: Earlier of 2 years from discovery or 5 years from occurrence
# ============================================================

from services.sol_calculator import (
    calculate_sol,
    check_sol_deadlines,
    format_sol_for_display,
    get_expired_claims,
    get_remaining_days,
    get_sol_statistics,
    get_sol_warning_level,
    get_upcoming_expirations,
    get_violations_with_sol_status,
    is_expired,
    update_violation_sol_dates,
)


@app.route("/api/sol/calculate", methods=["POST"])
@require_staff()
def api_sol_calculate():
    """Calculate SOL for given violation/discovery dates"""
    data = request.get_json() or {}

    violation_date_str = data.get("violation_date")
    discovery_date_str = data.get("discovery_date")

    if not violation_date_str:
        return jsonify({"success": False, "error": "violation_date is required"}), 400

    try:
        violation_date = datetime.fromisoformat(
            violation_date_str.replace("Z", "+00:00")
        ).date()
        discovery_date = None
        if discovery_date_str:
            discovery_date = datetime.fromisoformat(
                discovery_date_str.replace("Z", "+00:00")
            ).date()

        sol_info = calculate_sol(violation_date, discovery_date)
        formatted = format_sol_for_display(sol_info)

        return jsonify({"success": True, **formatted})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 400


@app.route("/api/sol/client/<int:client_id>", methods=["GET"])
@require_staff()
def api_sol_client(client_id):
    """Get SOL status for all violations belonging to a client"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        violations = get_violations_with_sol_status(db, client_id)

        formatted_violations = [format_sol_for_display(v) for v in violations]

        critical_count = sum(
            1 for v in violations if v.get("warning_level") == "critical"
        )
        warning_count = sum(
            1 for v in violations if v.get("warning_level") == "warning"
        )
        expired_count = sum(1 for v in violations if v.get("is_expired", False))

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "client_name": client.name,
                "violations": formatted_violations,
                "summary": {
                    "total": len(violations),
                    "critical": critical_count,
                    "warning": warning_count,
                    "expired": expired_count,
                },
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/sol/upcoming", methods=["GET"])
@require_staff()
def api_sol_upcoming():
    """Get all violations with SOL expiring within the specified days"""
    days = request.args.get("days", 90, type=int)

    db = get_db()
    try:
        upcoming = get_upcoming_expirations(db, days)
        formatted = [format_sol_for_display(v) for v in upcoming]

        stats = get_sol_statistics(db)

        return jsonify(
            {"success": True, "days": days, "violations": formatted, "stats": stats}
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/sol/statistics", methods=["GET"])
@require_staff()
def api_sol_statistics():
    """Get overall SOL statistics"""
    db = get_db()
    try:
        stats = get_sol_statistics(db)

        return jsonify({"success": True, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/sol/violation/<int:violation_id>/update", methods=["POST"])
@require_staff()
def api_sol_violation_update(violation_id):
    """Update SOL dates for a specific violation"""
    data = request.get_json() or {}

    violation_date_str = data.get("violation_date")
    discovery_date_str = data.get("discovery_date")

    db = get_db()
    try:
        violation_date = None
        discovery_date = None

        if violation_date_str:
            violation_date = datetime.fromisoformat(
                violation_date_str.replace("Z", "+00:00")
            ).date()
        if discovery_date_str:
            discovery_date = datetime.fromisoformat(
                discovery_date_str.replace("Z", "+00:00")
            ).date()

        result = update_violation_sol_dates(
            db, violation_id, violation_date, discovery_date
        )

        if result.get("error"):
            return jsonify({"success": False, "error": result["error"]}), 400

        return jsonify({"success": True, **format_sol_for_display(result)})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/sol/check-deadlines", methods=["POST"])
@require_staff(roles=["admin"])
def api_sol_check_deadlines():
    """Manually trigger SOL deadline check (creates alerts)"""
    db = get_db()
    try:
        result = check_sol_deadlines(db)

        return jsonify({"success": True, **result})
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/sol")
@require_staff()
def dashboard_sol():
    """SOL Tracker Dashboard"""
    db = get_db()
    try:
        stats = get_sol_statistics(db)

        upcoming_30 = get_upcoming_expirations(db, 30)
        upcoming_60 = get_upcoming_expirations(db, 60)
        upcoming_90 = get_upcoming_expirations(db, 90)
        expired = get_expired_claims(db)

        formatted_30 = [format_sol_for_display(v) for v in upcoming_30]
        formatted_60 = [format_sol_for_display(v) for v in upcoming_60]
        formatted_90 = [format_sol_for_display(v) for v in upcoming_90]
        formatted_expired = [format_sol_for_display(v) for v in expired[:20]]

        return render_template(
            "sol_dashboard.html",
            stats=stats,
            upcoming_30=formatted_30,
            upcoming_60=formatted_60,
            upcoming_90=formatted_90,
            expired=formatted_expired,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error loading SOL dashboard: {e}", 500
    finally:
        db.close()


# ============================================================
# CFPB COMPLAINT GENERATOR
# ============================================================

CFPB_TEMPLATES = {
    "credit_reporting": {
        "product_type": "Credit reporting, credit repair services, or other personal consumer reports",
        "issues": {
            "incorrect_info": {
                "label": "Incorrect information on your report",
                "sub_issues": [
                    "Information belongs to someone else",
                    "Account status incorrect",
                    "Account information incorrect",
                    "Personal information incorrect",
                    "Public record information inaccurate",
                    "Information is outdated",
                    "Information is missing that should be on the report",
                ],
            },
            "investigation": {
                "label": "Problem with a credit reporting company's investigation into an existing problem",
                "sub_issues": [
                    "Their investigation did not fix an error on your report",
                    "Investigation took more than 30 days",
                    "Was not notified of investigation status or results",
                    "Difficulty submitting a dispute or getting information about a dispute over the phone",
                ],
            },
            "improper_use": {
                "label": "Improper use of your report",
                "sub_issues": [
                    "Report provided to employer without your written authorization",
                    "Credit inquiries on your report that you don't recognize",
                    "Received unsolicited financial product or insurance offers after opting out",
                ],
            },
            "fraud_alerts": {
                "label": "Problem with a credit reporting company's fraud alerts or security freeze",
                "sub_issues": [
                    "Unable to place fraud alert",
                    "Unable to place security freeze",
                    "Unable to lift security freeze",
                ],
            },
            "credit_monitoring": {
                "label": "Problem with credit report or credit score",
                "sub_issues": [
                    "Problem getting free annual credit report",
                    "Problem with credit score or credit report",
                ],
            },
        },
    },
    "debt_collection": {
        "product_type": "Debt collection",
        "issues": {
            "not_owed": {
                "label": "Attempts to collect debt not owed",
                "sub_issues": [
                    "Debt is not yours",
                    "Debt was paid",
                    "Debt was discharged in bankruptcy",
                    "Debt is result of identity theft",
                ],
            },
            "communication": {
                "label": "Communication tactics",
                "sub_issues": [
                    "Frequent or repeated calls",
                    "Called after asked to stop",
                    "Used obscene, profane, or abusive language",
                    "Threatened arrest or jail if debt not paid",
                ],
            },
            "false_statements": {
                "label": "False statements or representation",
                "sub_issues": [
                    "Attempted to collect wrong amount",
                    "Impersonated attorney, law enforcement, or government official",
                    "Indicated you committed crime by not paying debt",
                    "Indicated you would be arrested if debt not paid",
                ],
            },
            "threats": {
                "label": "Threatened to take an action we can't legally take",
                "sub_issues": [
                    "Threatened to sue on debt older than the statute of limitations",
                    "Threatened to seize or garnish without court approval",
                    "Threatened to report incorrect debt info to credit bureaus",
                ],
            },
        },
    },
}

CRA_COMPANIES = {
    "equifax": {
        "name": "Equifax Information Services LLC",
        "address": "P.O. Box 740256, Atlanta, GA 30374",
    },
    "experian": {
        "name": "Experian Information Solutions, Inc.",
        "address": "P.O. Box 4500, Allen, TX 75013",
    },
    "transunion": {
        "name": "TransUnion LLC",
        "address": "P.O. Box 2000, Chester, PA 19016",
    },
}

os.makedirs("static/cfpb_complaints", exist_ok=True)


@app.route("/api/cfpb/templates", methods=["GET"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_templates():
    """Get available CFPB complaint templates"""
    return jsonify(
        {"success": True, "templates": CFPB_TEMPLATES, "cra_companies": CRA_COMPANIES}
    )


@app.route("/api/cfpb/generate", methods=["POST"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_generate():
    """Generate a CFPB complaint with AI-powered narrative"""
    data = request.get_json() or {}

    client_id = data.get("client_id")
    case_id = data.get("case_id")
    target_company = data.get("target_company")
    target_type = data.get("target_type")
    product_type = data.get("product_type")
    issue_type = data.get("issue_type")
    sub_issue_type = data.get("sub_issue_type")

    if (
        not client_id
        or not target_company
        or not target_type
        or not product_type
        or not issue_type
    ):
        return jsonify({"success": False, "error": "Missing required fields"}), 400

    db = get_db()
    try:
        client_record = db.query(Client).filter_by(id=client_id).first()
        if not client_record:
            return jsonify({"success": False, "error": "Client not found"}), 404

        violations_data = []
        standing_data = None
        dispute_history = []

        if case_id:
            case = db.query(Case).filter_by(id=case_id).first()
            if case and case.analysis_id:
                violations = (
                    db.query(Violation).filter_by(analysis_id=case.analysis_id).all()
                )
                violations_data = [
                    {
                        "bureau": v.bureau,
                        "account_name": v.account_name,
                        "fcra_section": v.fcra_section,
                        "violation_type": v.violation_type,
                        "description": v.description,
                        "is_willful": v.is_willful,
                    }
                    for v in violations
                ]

                standing = (
                    db.query(Standing).filter_by(analysis_id=case.analysis_id).first()
                )
                if standing:
                    standing_data = {
                        "concrete_harm_type": standing.concrete_harm_type,
                        "concrete_harm_details": standing.concrete_harm_details,
                        "dissemination_details": standing.dissemination_details,
                    }

        cra_responses = db.query(CRAResponse).filter_by(client_id=client_id).all()
        for resp in cra_responses:
            dispute_history.append(
                {
                    "bureau": resp.bureau,
                    "round": resp.dispute_round,
                    "response_type": resp.response_type,
                    "date": (
                        resp.response_date.isoformat() if resp.response_date else None
                    ),
                }
            )

        narrative = generate_cfpb_narrative(
            client_record,
            target_company,
            target_type,
            product_type,
            issue_type,
            sub_issue_type,
            violations_data,
            standing_data,
            dispute_history,
        )

        desired_resolution = generate_desired_resolution(target_type, issue_type)

        complaint = CFPBComplaint(
            client_id=client_id,
            case_id=case_id,
            target_company=target_company,
            target_type=target_type,
            product_type=product_type,
            issue_type=issue_type,
            sub_issue_type=sub_issue_type,
            narrative=narrative,
            desired_resolution=desired_resolution,
            status="draft",
        )
        db.add(complaint)
        db.commit()

        return jsonify(
            {
                "success": True,
                "complaint": {
                    "id": complaint.id,
                    "client_id": complaint.client_id,
                    "case_id": complaint.case_id,
                    "target_company": complaint.target_company,
                    "target_type": complaint.target_type,
                    "product_type": complaint.product_type,
                    "issue_type": complaint.issue_type,
                    "sub_issue_type": complaint.sub_issue_type,
                    "narrative": complaint.narrative,
                    "desired_resolution": complaint.desired_resolution,
                    "status": complaint.status,
                    "created_at": complaint.created_at.isoformat(),
                },
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


def generate_cfpb_narrative(
    client,
    target_company,
    target_type,
    product_type,
    issue_type,
    sub_issue_type,
    violations,
    standing,
    dispute_history,
):
    """Generate a compelling CFPB complaint narrative using Claude"""

    client_name = client.name
    client_address = f"{client.address_street or ''}, {client.address_city or ''}, {client.address_state or ''} {client.address_zip or ''}".strip(
        ", "
    )

    violations_text = ""
    if violations:
        violations_text = "VIOLATIONS IDENTIFIED:\n"
        for v in violations:
            violations_text += f"- {v.get('account_name', 'Unknown Account')}: {v.get('description', 'No description')} (FCRA ¬ß {v.get('fcra_section', 'N/A')})\n"

    standing_text = ""
    if standing:
        standing_text = f"HARM SUFFERED:\n- Type: {standing.get('concrete_harm_type', 'Not specified')}\n- Details: {standing.get('concrete_harm_details', 'Not specified')}\n"

    dispute_text = ""
    if dispute_history:
        dispute_text = "DISPUTE HISTORY:\n"
        for d in dispute_history:
            dispute_text += f"- {d.get('bureau', 'Unknown')}: Round {d.get('round', 'N/A')} - {d.get('response_type', 'Unknown')} ({d.get('date', 'Unknown date')})\n"

    prompt = f"""Generate a professional, compelling CFPB complaint narrative for the following situation. The narrative should be written in first person from the consumer's perspective and follow CFPB guidelines.

CONSUMER INFORMATION:
- Name: {client_name}
- Address: {client_address}

COMPLAINT DETAILS:
- Target Company: {target_company}
- Company Type: {target_type}
- Product/Service: {product_type}
- Issue Type: {issue_type}
- Sub-Issue: {sub_issue_type or 'Not specified'}

{violations_text}
{standing_text}
{dispute_text}

Write a detailed narrative (400-600 words) that:
1. Clearly describes the problem in chronological order
2. Includes specific dates, account numbers (partially redacted), and amounts where applicable
3. Explains what attempts were made to resolve the issue directly with the company
4. Describes the impact on the consumer (financial harm, stress, denied credit, etc.)
5. References any relevant FCRA violations
6. Maintains a professional, factual tone

Output ONLY the narrative text, no additional formatting or explanations."""

    try:
        if client is None or "invalid" in ANTHROPIC_API_KEY.lower():
            return f"""I am writing to file a formal complaint against {target_company} regarding {issue_type}.

On [DATE], I discovered that {target_company} has been reporting inaccurate information on my credit report. Despite my attempts to resolve this matter directly, the company has failed to correct these errors.

I have disputed this information through proper channels, but the issues remain unresolved. This has caused me significant financial harm and emotional distress.

I am requesting immediate investigation and correction of this matter.

[Note: This is a template narrative. Enable Claude API for AI-generated personalized narratives.]"""

        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1500,
            messages=[{"role": "user", "content": prompt}],
        )

        return response.content[0].text.strip()

    except Exception as e:
        print(f"Error generating narrative with Claude: {e}")
        return f"""I am writing to file a formal complaint against {target_company} regarding {issue_type}.

I have identified serious issues with how {target_company} has been handling my credit reporting information. Despite multiple attempts to resolve this matter directly with the company, the problems persist.

The specific issue involves {sub_issue_type or issue_type}. This has caused me financial harm and significant stress.

I have attempted to dispute this information through proper channels, sending written disputes and following up multiple times. However, {target_company} has failed to adequately investigate or correct the inaccurate information.

I am requesting that the CFPB investigate this matter and help me obtain a resolution.

[Detailed timeline and specific information would be included based on case documentation.]"""


def generate_desired_resolution(target_type, issue_type):
    """Generate appropriate desired resolution text"""
    if target_type == "cra":
        return """I request the following resolution:

1. Conduct a thorough investigation of my dispute within 30 days as required by the FCRA
2. Correct or delete all inaccurate information from my credit report
3. Provide me with written confirmation of the investigation results
4. Provide a free updated copy of my credit report showing the corrections
5. Notify all parties who received my report in the past 6 months of the corrections
6. Implement procedures to prevent this error from recurring
7. Provide monetary compensation for the harm I have suffered"""
    else:
        return """I request the following resolution:

1. Cease all collection activities on this disputed account
2. Provide complete verification of the alleged debt including original creditor documentation
3. Remove all negative credit reporting related to this disputed account
4. Confirm deletion in writing to me and all credit reporting agencies
5. Cease all communication regarding this matter if debt cannot be verified
6. Provide monetary compensation for the harm caused by these practices"""


@app.route("/api/cfpb/complaints", methods=["GET"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_complaints_list():
    """List all CFPB complaints"""
    status = request.args.get("status")
    client_id = request.args.get("client_id")

    db = get_db()
    try:
        query = db.query(CFPBComplaint)

        if status:
            query = query.filter(CFPBComplaint.status == status)
        if client_id:
            query = query.filter(CFPBComplaint.client_id == int(client_id))

        complaints = query.order_by(CFPBComplaint.created_at.desc()).all()

        result = []
        for c in complaints:
            client_record = db.query(Client).filter_by(id=c.client_id).first()
            result.append(
                {
                    "id": c.id,
                    "client_id": c.client_id,
                    "client_name": client_record.name if client_record else "Unknown",
                    "case_id": c.case_id,
                    "target_company": c.target_company,
                    "target_type": c.target_type,
                    "product_type": c.product_type,
                    "issue_type": c.issue_type,
                    "status": c.status,
                    "cfpb_complaint_id": c.cfpb_complaint_id,
                    "submitted_at": (
                        c.submitted_at.isoformat() if c.submitted_at else None
                    ),
                    "file_path": c.file_path,
                    "created_at": c.created_at.isoformat(),
                }
            )

        return jsonify({"success": True, "complaints": result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cfpb/complaints/<int:complaint_id>", methods=["GET"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_complaint_detail(complaint_id):
    """Get CFPB complaint details"""
    db = get_db()
    try:
        complaint = db.query(CFPBComplaint).filter_by(id=complaint_id).first()
        if not complaint:
            return jsonify({"success": False, "error": "Complaint not found"}), 404

        client_record = db.query(Client).filter_by(id=complaint.client_id).first()

        return jsonify(
            {
                "success": True,
                "complaint": {
                    "id": complaint.id,
                    "client_id": complaint.client_id,
                    "client_name": client_record.name if client_record else "Unknown",
                    "client_email": client_record.email if client_record else None,
                    "client_phone": client_record.phone if client_record else None,
                    "client_address": (
                        f"{client_record.address_street or ''}, {client_record.address_city or ''}, {client_record.address_state or ''} {client_record.address_zip or ''}"
                        if client_record
                        else ""
                    ),
                    "case_id": complaint.case_id,
                    "target_company": complaint.target_company,
                    "target_type": complaint.target_type,
                    "product_type": complaint.product_type,
                    "issue_type": complaint.issue_type,
                    "sub_issue_type": complaint.sub_issue_type,
                    "narrative": complaint.narrative,
                    "desired_resolution": complaint.desired_resolution,
                    "status": complaint.status,
                    "cfpb_complaint_id": complaint.cfpb_complaint_id,
                    "submitted_at": (
                        complaint.submitted_at.isoformat()
                        if complaint.submitted_at
                        else None
                    ),
                    "response_received_at": (
                        complaint.response_received_at.isoformat()
                        if complaint.response_received_at
                        else None
                    ),
                    "company_response": complaint.company_response,
                    "file_path": complaint.file_path,
                    "created_at": complaint.created_at.isoformat(),
                    "updated_at": (
                        complaint.updated_at.isoformat()
                        if complaint.updated_at
                        else None
                    ),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cfpb/complaints/<int:complaint_id>", methods=["PUT"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_complaint_update(complaint_id):
    """Update CFPB complaint"""
    data = request.get_json() or {}

    db = get_db()
    try:
        complaint = db.query(CFPBComplaint).filter_by(id=complaint_id).first()
        if not complaint:
            return jsonify({"success": False, "error": "Complaint not found"}), 404

        if "narrative" in data:
            complaint.narrative = data["narrative"]
        if "desired_resolution" in data:
            complaint.desired_resolution = data["desired_resolution"]
        if "status" in data:
            complaint.status = data["status"]
        if "cfpb_complaint_id" in data:
            complaint.cfpb_complaint_id = data["cfpb_complaint_id"]
        if "company_response" in data:
            complaint.company_response = data["company_response"]
        if "target_company" in data:
            complaint.target_company = data["target_company"]
        if "issue_type" in data:
            complaint.issue_type = data["issue_type"]
        if "sub_issue_type" in data:
            complaint.sub_issue_type = data["sub_issue_type"]

        complaint.updated_at = datetime.utcnow()
        db.commit()

        return jsonify({"success": True, "message": "Complaint updated successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cfpb/complaints/<int:complaint_id>/pdf", methods=["POST"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_complaint_pdf(complaint_id):
    """Generate PDF for CFPB complaint"""
    db = get_db()
    try:
        complaint = db.query(CFPBComplaint).filter_by(id=complaint_id).first()
        if not complaint:
            return jsonify({"success": False, "error": "Complaint not found"}), 404

        client_record = db.query(Client).filter_by(id=complaint.client_id).first()
        if not client_record:
            return jsonify({"success": False, "error": "Client not found"}), 404

        pdf_path = generate_cfpb_pdf(complaint, client_record)

        complaint.file_path = pdf_path
        complaint.status = "ready" if complaint.status == "draft" else complaint.status
        complaint.updated_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "file_path": pdf_path,
                "message": "PDF generated successfully",
            }
        )
    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


def generate_cfpb_pdf(complaint, client_record):
    """Generate CFPB complaint PDF"""
    from fpdf import FPDF

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_name = re.sub(r"[^\w\s-]", "", client_record.name).replace(" ", "_")
    filename = f"CFPB_Complaint_{safe_name}_{timestamp}.pdf"
    output_path = f"static/cfpb_complaints/{filename}"

    pdf = FPDF()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=15)

    if os.path.exists(BRIGHTPATH_LOGO_PATH):
        try:
            pdf.image(BRIGHTPATH_LOGO_PATH, 10, 8, 25)
        except:
            pass

    pdf.set_font("Arial", "B", 16)
    pdf.set_xy(40, 10)
    pdf.cell(0, 10, "CFPB COMPLAINT", ln=True, align="C")

    pdf.set_font("Arial", "", 10)
    pdf.set_xy(40, 20)
    pdf.cell(0, 5, "Consumer Financial Protection Bureau", ln=True, align="C")
    pdf.cell(
        0, 5, f"Generated: {datetime.now().strftime('%B %d, %Y')}", ln=True, align="C"
    )

    pdf.ln(10)
    pdf.set_draw_color(49, 151, 149)
    pdf.set_line_width(0.5)
    pdf.line(10, pdf.get_y(), 200, pdf.get_y())
    pdf.ln(5)

    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 8, "CONSUMER INFORMATION", ln=True)
    pdf.set_font("Arial", "", 10)
    pdf.cell(0, 6, f"Name: {client_record.name}", ln=True)
    address = f"{client_record.address_street or ''}, {client_record.address_city or ''}, {client_record.address_state or ''} {client_record.address_zip or ''}"
    pdf.cell(0, 6, f"Address: {address.strip(', ')}", ln=True)
    pdf.cell(0, 6, f"Phone: {client_record.phone or 'Not provided'}", ln=True)
    pdf.cell(0, 6, f"Email: {client_record.email or 'Not provided'}", ln=True)

    pdf.ln(5)
    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 8, "COMPANY BEING COMPLAINED ABOUT", ln=True)
    pdf.set_font("Arial", "", 10)
    pdf.cell(0, 6, f"Company Name: {complaint.target_company}", ln=True)
    pdf.cell(0, 6, f"Company Type: {complaint.target_type.upper()}", ln=True)

    pdf.ln(5)
    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 8, "PRODUCT/SERVICE & ISSUE", ln=True)
    pdf.set_font("Arial", "", 10)
    pdf.multi_cell(0, 6, f"Product/Service: {complaint.product_type}")
    pdf.cell(0, 6, f"Issue Type: {complaint.issue_type}", ln=True)
    if complaint.sub_issue_type:
        pdf.cell(0, 6, f"Sub-Issue: {complaint.sub_issue_type}", ln=True)

    pdf.ln(5)
    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 8, "WHAT HAPPENED (NARRATIVE)", ln=True)
    pdf.set_font("Arial", "", 10)

    narrative = complaint.narrative or "No narrative provided."
    narrative = narrative.encode("latin-1", "replace").decode("latin-1")
    pdf.multi_cell(0, 6, narrative)

    pdf.ln(5)
    pdf.set_font("Arial", "B", 12)
    pdf.cell(0, 8, "DESIRED RESOLUTION", ln=True)
    pdf.set_font("Arial", "", 10)

    resolution = complaint.desired_resolution or "No resolution specified."
    resolution = resolution.encode("latin-1", "replace").decode("latin-1")
    pdf.multi_cell(0, 6, resolution)

    pdf.ln(10)
    pdf.line(10, pdf.get_y(), 200, pdf.get_y())
    pdf.ln(5)

    pdf.set_font("Arial", "B", 10)
    pdf.cell(0, 6, "CONSUMER CERTIFICATION", ln=True)
    pdf.set_font("Arial", "", 9)
    pdf.multi_cell(
        0,
        5,
        "I certify that the information provided above is true and correct to the best of my knowledge. I authorize the Consumer Financial Protection Bureau to share this complaint with the company identified above for resolution purposes.",
    )

    pdf.ln(10)
    pdf.cell(0, 6, "_____________________________", ln=True)
    pdf.cell(0, 6, f"{client_record.name}", ln=True)
    pdf.cell(0, 6, f"Date: {datetime.now().strftime('%B %d, %Y')}", ln=True)

    pdf.ln(10)
    pdf.set_font("Arial", "I", 8)
    pdf.set_text_color(128, 128, 128)
    pdf.multi_cell(
        0,
        4,
        "This complaint was prepared using the Brightpath Ascend FCRA Litigation Platform. For more information, visit consumerfinance.gov/complaint to file directly with the CFPB.",
    )

    pdf.output(output_path)
    return output_path


@app.route("/api/cfpb/complaints/<int:complaint_id>/submit", methods=["POST"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_complaint_submit(complaint_id):
    """Mark CFPB complaint as submitted"""
    data = request.get_json() or {}
    cfpb_complaint_id = data.get("cfpb_complaint_id")

    db = get_db()
    try:
        complaint = db.query(CFPBComplaint).filter_by(id=complaint_id).first()
        if not complaint:
            return jsonify({"success": False, "error": "Complaint not found"}), 404

        complaint.status = "submitted"
        complaint.submitted_at = datetime.utcnow()
        if cfpb_complaint_id:
            complaint.cfpb_complaint_id = cfpb_complaint_id
        complaint.updated_at = datetime.utcnow()
        db.commit()

        return jsonify({"success": True, "message": "Complaint marked as submitted"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/cfpb/complaints/<int:complaint_id>/response", methods=["POST"])
@require_staff(["admin", "attorney", "paralegal"])
def api_cfpb_complaint_response(complaint_id):
    """Record company response to CFPB complaint"""
    data = request.get_json() or {}
    company_response = data.get("company_response")

    if not company_response:
        return jsonify({"success": False, "error": "Company response required"}), 400

    db = get_db()
    try:
        complaint = db.query(CFPBComplaint).filter_by(id=complaint_id).first()
        if not complaint:
            return jsonify({"success": False, "error": "Complaint not found"}), 404

        complaint.status = "response_received"
        complaint.response_received_at = datetime.utcnow()
        complaint.company_response = company_response
        complaint.updated_at = datetime.utcnow()
        db.commit()

        return jsonify({"success": True, "message": "Response recorded successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/cfpb")
@require_staff(["admin", "attorney", "paralegal"])
def dashboard_cfpb():
    """CFPB Complaints Dashboard"""
    db = get_db()
    try:
        complaints = (
            db.query(CFPBComplaint).order_by(CFPBComplaint.created_at.desc()).all()
        )

        complaint_list = []
        for c in complaints:
            client_record = db.query(Client).filter_by(id=c.client_id).first()
            complaint_list.append(
                {
                    "id": c.id,
                    "client_id": c.client_id,
                    "client_name": client_record.name if client_record else "Unknown",
                    "target_company": c.target_company,
                    "target_type": c.target_type,
                    "issue_type": c.issue_type,
                    "status": c.status,
                    "cfpb_complaint_id": c.cfpb_complaint_id,
                    "submitted_at": c.submitted_at,
                    "file_path": c.file_path,
                    "created_at": c.created_at,
                }
            )

        stats = {
            "total": len(complaints),
            "draft": sum(1 for c in complaints if c.status == "draft"),
            "ready": sum(1 for c in complaints if c.status == "ready"),
            "submitted": sum(1 for c in complaints if c.status == "submitted"),
            "response_received": sum(
                1 for c in complaints if c.status == "response_received"
            ),
        }

        clients = (
            db.query(Client)
            .filter(Client.status.in_(["active", "signup"]))
            .order_by(Client.name)
            .all()
        )
        client_list = [{"id": c.id, "name": c.name} for c in clients]

        return render_template(
            "cfpb_complaints.html",
            complaints=complaint_list,
            stats=stats,
            clients=client_list,
            templates=CFPB_TEMPLATES,
            cra_companies=CRA_COMPANIES,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error loading CFPB dashboard: {e}", 500
    finally:
        db.close()


@app.route("/dashboard/cfpb/generator")
@require_staff(["admin", "attorney", "paralegal"])
def dashboard_cfpb_generator():
    """CFPB Complaint Generator Wizard"""
    db = get_db()
    try:
        clients = (
            db.query(Client)
            .filter(Client.status.in_(["active", "signup"]))
            .order_by(Client.name)
            .all()
        )
        client_list = [{"id": c.id, "name": c.name, "email": c.email} for c in clients]

        return render_template(
            "cfpb_generator.html",
            clients=client_list,
            templates=CFPB_TEMPLATES,
            cra_companies=CRA_COMPANIES,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error loading CFPB generator: {e}", 500
    finally:
        db.close()


@app.route("/dashboard/cfpb/complaint/<int:complaint_id>")
@require_staff(["admin", "attorney", "paralegal"])
def dashboard_cfpb_detail(complaint_id):
    """View/Edit CFPB Complaint"""
    db = get_db()
    try:
        complaint = db.query(CFPBComplaint).filter_by(id=complaint_id).first()
        if not complaint:
            return "Complaint not found", 404

        client_record = db.query(Client).filter_by(id=complaint.client_id).first()

        complaint_data = {
            "id": complaint.id,
            "client_id": complaint.client_id,
            "client_name": client_record.name if client_record else "Unknown",
            "client_email": client_record.email if client_record else None,
            "client_address": (
                f"{client_record.address_street or ''}, {client_record.address_city or ''}, {client_record.address_state or ''} {client_record.address_zip or ''}"
                if client_record
                else ""
            ),
            "case_id": complaint.case_id,
            "target_company": complaint.target_company,
            "target_type": complaint.target_type,
            "product_type": complaint.product_type,
            "issue_type": complaint.issue_type,
            "sub_issue_type": complaint.sub_issue_type,
            "narrative": complaint.narrative,
            "desired_resolution": complaint.desired_resolution,
            "status": complaint.status,
            "cfpb_complaint_id": complaint.cfpb_complaint_id,
            "submitted_at": complaint.submitted_at,
            "response_received_at": complaint.response_received_at,
            "company_response": complaint.company_response,
            "file_path": complaint.file_path,
            "created_at": complaint.created_at,
        }

        return render_template(
            "cfpb_generator.html",
            complaint=complaint_data,
            clients=(
                [{"id": client_record.id, "name": client_record.name}]
                if client_record
                else []
            ),
            templates=CFPB_TEMPLATES,
            cra_companies=CRA_COMPANIES,
            edit_mode=True,
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error loading complaint: {e}", 500
    finally:
        db.close()


# ================================
# AFFILIATE MANAGEMENT ENDPOINTS
# ================================


@app.route("/dashboard/affiliates")
@require_staff()
def dashboard_affiliates():
    """Affiliate Dashboard - Track referrals, commissions, and payouts"""
    return render_template("affiliate_dashboard.html")


@app.route("/dashboard/affiliate/<int:affiliate_id>")
@require_staff(roles=["admin"])
def dashboard_affiliate_detail(affiliate_id):
    """Individual affiliate profile page"""
    affiliate = affiliate_service.get_affiliate_by_id(affiliate_id)
    if not affiliate:
        return "Affiliate not found", 404

    stats = affiliate_service.get_affiliate_stats(affiliate_id)
    commissions = affiliate_service.get_commission_history(affiliate_id)
    tree = affiliate_service.get_referral_tree(affiliate_id)

    db = get_db()
    try:
        referred_clients = (
            db.query(Client)
            .filter(Client.referred_by_affiliate_id == affiliate_id)
            .all()
        )

        clients_data = [
            {
                "id": c.id,
                "name": c.name,
                "email": c.email,
                "status": c.status,
                "payment_status": c.payment_status,
                "created_at": c.created_at.isoformat() if c.created_at else None,
            }
            for c in referred_clients
        ]
    finally:
        db.close()

    return render_template(
        "affiliate_detail.html",
        affiliate=affiliate,
        stats=stats,
        commissions=commissions,
        tree=tree.get("tree", {}),
        referred_clients=clients_data,
    )


@app.route("/api/affiliates", methods=["GET"])
@require_staff(roles=["admin"])
def api_list_affiliates():
    """List all affiliates with stats"""
    status = request.args.get("status")
    affiliates = affiliate_service.get_all_affiliates(status=status)
    stats = affiliate_service.get_dashboard_stats()

    return jsonify({"success": True, "affiliates": affiliates, "stats": stats})


@app.route("/api/affiliates", methods=["POST"])
@require_staff(roles=["admin"])
def api_create_affiliate():
    """Create a new affiliate"""
    data = request.json

    if not data.get("name") or not data.get("email"):
        return jsonify({"success": False, "error": "Name and email are required"}), 400

    result = affiliate_service.create_affiliate(
        name=data.get("name"),
        email=data.get("email"),
        phone=data.get("phone"),
        company_name=data.get("company_name"),
        parent_affiliate_id=data.get("parent_affiliate_id"),
        commission_rate_1=float(data.get("commission_rate_1", 0.10)),
        commission_rate_2=float(data.get("commission_rate_2", 0.05)),
        payout_method=data.get("payout_method"),
        payout_details=data.get("payout_details"),
        status=data.get("status", "active"),
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/affiliates/<int:affiliate_id>", methods=["GET"])
@require_staff(roles=["admin"])
def api_get_affiliate(affiliate_id):
    """Get affiliate details"""
    affiliate = affiliate_service.get_affiliate_by_id(affiliate_id)
    if not affiliate:
        return jsonify({"success": False, "error": "Affiliate not found"}), 404

    stats = affiliate_service.get_affiliate_stats(affiliate_id)

    return jsonify({"success": True, "affiliate": affiliate, "stats": stats})


@app.route("/api/affiliates/<int:affiliate_id>", methods=["PUT"])
@require_staff(roles=["admin"])
def api_update_affiliate(affiliate_id):
    """Update affiliate information"""
    data = request.json

    result = affiliate_service.update_affiliate(
        affiliate_id=affiliate_id,
        name=data.get("name"),
        email=data.get("email"),
        phone=data.get("phone"),
        company_name=data.get("company_name"),
        parent_affiliate_id=data.get("parent_affiliate_id"),
        commission_rate_1=(
            float(data.get("commission_rate_1"))
            if data.get("commission_rate_1")
            else None
        ),
        commission_rate_2=(
            float(data.get("commission_rate_2"))
            if data.get("commission_rate_2")
            else None
        ),
        status=data.get("status"),
        payout_method=data.get("payout_method"),
        payout_details=data.get("payout_details"),
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/affiliates/<int:affiliate_id>/commissions", methods=["GET"])
@require_staff(roles=["admin"])
def api_get_affiliate_commissions(affiliate_id):
    """Get commission history for an affiliate"""
    limit = request.args.get("limit", 50, type=int)
    commissions = affiliate_service.get_commission_history(affiliate_id, limit=limit)

    return jsonify({"success": True, "commissions": commissions})


@app.route("/api/affiliates/<int:affiliate_id>/payout", methods=["POST"])
@require_staff(roles=["admin"])
def api_process_payout(affiliate_id):
    """Process a payout for an affiliate"""
    data = request.json

    amount = data.get("amount")
    if not amount or float(amount) <= 0:
        return (
            jsonify({"success": False, "error": "Valid payout amount is required"}),
            400,
        )

    result = affiliate_service.process_payout(
        affiliate_id=affiliate_id,
        amount=float(amount),
        payout_method=data.get("payout_method"),
        notes=data.get("notes"),
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/affiliates/<int:affiliate_id>/tree", methods=["GET"])
@require_staff(roles=["admin"])
def api_get_affiliate_tree(affiliate_id):
    """Get referral tree for an affiliate"""
    result = affiliate_service.get_referral_tree(affiliate_id)

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 404


@app.route("/api/affiliate/validate/<code>", methods=["GET"])
def api_validate_affiliate_code(code):
    """Public endpoint to validate an affiliate code during signup"""
    result = affiliate_service.validate_affiliate_code(code)
    return jsonify(result)


@app.route("/api/affiliate/apply", methods=["POST"])
def api_apply_affiliate():
    """Public endpoint to apply to become an affiliate"""
    data = request.json

    if not data.get("name") or not data.get("email"):
        return jsonify({"success": False, "error": "Name and email are required"}), 400

    result = affiliate_service.apply_for_affiliate(
        name=data.get("name"),
        email=data.get("email"),
        phone=data.get("phone"),
        company_name=data.get("company_name"),
        payout_method=data.get("payout_method"),
        payout_details=data.get("payout_details"),
        referrer_code=data.get("referrer_code"),
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/affiliate/calculate-commission", methods=["POST"])
@require_staff(roles=["admin"])
def api_calculate_commission():
    """Manually trigger commission calculation for a client"""
    data = request.json

    client_id = data.get("client_id")
    trigger_type = data.get("trigger_type")
    amount = data.get("amount")

    if not all([client_id, trigger_type, amount]):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "client_id, trigger_type, and amount are required",
                }
            ),
            400,
        )

    result = affiliate_service.calculate_commission(
        client_id=int(client_id), trigger_type=trigger_type, amount=float(amount)
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/affiliate/process-referral", methods=["POST"])
@require_staff(roles=["admin"])
def api_process_referral():
    """Link a client to an affiliate"""
    data = request.json

    client_id = data.get("client_id")
    affiliate_code = data.get("affiliate_code")

    if not client_id or not affiliate_code:
        return (
            jsonify(
                {"success": False, "error": "client_id and affiliate_code are required"}
            ),
            400,
        )

    result = affiliate_service.process_referral(
        client_id=int(client_id), affiliate_code=affiliate_code
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


# ==========================================
# TRIAGE API ENDPOINTS
# ==========================================


@app.route("/api/triage/analyze/<int:analysis_id>", methods=["POST"])
@require_staff()
def api_triage_analyze(analysis_id):
    """Trigger triage for a specific analysis"""
    result = triage_service.triage_case(analysis_id)

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/triage/queue", methods=["GET"])
@require_staff()
def api_triage_queue_all():
    """Get all cases by queue"""
    limit = request.args.get("limit", 50, type=int)
    cases = triage_service.get_queue_cases(queue_name=None, limit=limit)

    return jsonify({"success": True, "cases": cases, "count": len(cases)})


@app.route("/api/triage/queue/<queue_name>", methods=["GET"])
@require_staff()
def api_triage_queue_filter(queue_name):
    """Get cases filtered by specific queue"""
    valid_queues = ["fast_track", "standard", "review_needed", "hold"]
    if queue_name not in valid_queues:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f"Invalid queue name. Valid options: {valid_queues}",
                }
            ),
            400,
        )

    limit = request.args.get("limit", 50, type=int)
    cases = triage_service.get_queue_cases(queue_name=queue_name, limit=limit)

    return jsonify(
        {"success": True, "queue": queue_name, "cases": cases, "count": len(cases)}
    )


@app.route("/api/triage/<int:triage_id>", methods=["GET"])
@require_staff()
def api_triage_get(triage_id):
    """Get triage details by ID"""
    triage = triage_service.get_triage_by_id(triage_id)

    if triage:
        return jsonify({"success": True, "triage": triage})
    else:
        return jsonify({"success": False, "error": "Triage record not found"}), 404


@app.route("/api/triage/analysis/<int:analysis_id>", methods=["GET"])
@require_staff()
def api_triage_by_analysis(analysis_id):
    """Get triage record for an analysis"""
    triage = triage_service.get_triage_by_analysis(analysis_id)

    if triage:
        return jsonify({"success": True, "triage": triage})
    else:
        return (
            jsonify(
                {"success": False, "error": "No triage record found for this analysis"}
            ),
            404,
        )


@app.route("/api/triage/<int:triage_id>/review", methods=["PUT"])
@require_staff()
def api_triage_review(triage_id):
    """Submit human review/override for triage"""
    data = request.json

    staff_email = session.get("staff_email", "unknown")
    final_priority = data.get("final_priority")
    notes = data.get("notes")

    result = triage_service.update_triage_review(
        triage_id=triage_id,
        reviewed_by=staff_email,
        final_priority=final_priority,
        notes=notes,
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/triage/stats", methods=["GET"])
@require_staff()
def api_triage_stats():
    """Get triage queue statistics"""
    stats = triage_service.get_triage_stats()

    return jsonify({"success": True, "stats": stats})


@app.route("/dashboard/triage")
@require_staff()
def triage_dashboard():
    """Triage dashboard view"""
    stats = triage_service.get_triage_stats()
    fast_track = triage_service.get_queue_cases("fast_track", limit=10)
    standard = triage_service.get_queue_cases("standard", limit=10)
    review_needed = triage_service.get_queue_cases("review_needed", limit=10)
    hold = triage_service.get_queue_cases("hold", limit=10)

    return render_template(
        "triage_dashboard.html",
        stats=stats,
        fast_track=fast_track,
        standard=standard,
        review_needed=review_needed,
        hold=hold,
    )


@app.route("/api/escalation/recommend/<int:client_id>", methods=["POST"])
@require_staff()
def api_escalation_recommend(client_id):
    """Generate AI-powered escalation recommendations for a client"""
    data = request.json or {}
    item_id = data.get("item_id")
    bureau = data.get("bureau")

    result = escalation_service.recommend_escalation(
        client_id=client_id, item_id=item_id, bureau=bureau
    )

    if result.get("error"):
        return jsonify({"success": False, "error": result["error"]}), 404

    if data.get("save", True):
        for rec in result.get("recommendations", []):
            rec_id = escalation_service.save_recommendation(rec)
            rec["id"] = rec_id

    return jsonify(result)


@app.route("/api/escalation/recommendations/<int:client_id>", methods=["GET"])
@require_staff()
def api_escalation_list(client_id):
    """List all escalation recommendations for a client"""
    db = get_db()
    try:
        recommendations = (
            db.query(EscalationRecommendation)
            .filter_by(client_id=client_id)
            .order_by(EscalationRecommendation.created_at.desc())
            .all()
        )

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "recommendations": [r.to_dict() for r in recommendations],
                "total": len(recommendations),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/escalation/<int:recommendation_id>", methods=["GET"])
@require_staff()
def api_escalation_get(recommendation_id):
    """Get details of a specific recommendation"""
    db = get_db()
    try:
        rec = db.query(EscalationRecommendation).filter_by(id=recommendation_id).first()
        if not rec:
            return jsonify({"success": False, "error": "Recommendation not found"}), 404

        action_info = escalation_service.DISPUTE_ACTIONS.get(rec.recommended_action, {})

        return jsonify(
            {
                "success": True,
                "recommendation": rec.to_dict(),
                "action_info": action_info,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/escalation/<int:recommendation_id>/apply", methods=["PUT"])
@require_staff()
def api_escalation_apply(recommendation_id):
    """Mark a recommendation as applied"""
    result = escalation_service.apply_recommendation(recommendation_id)

    if result.get("error"):
        return jsonify({"success": False, "error": result["error"]}), 404

    return jsonify(result)


@app.route("/api/escalation/<int:recommendation_id>/outcome", methods=["PUT"])
@require_staff()
def api_escalation_outcome(recommendation_id):
    """Record the actual outcome of an applied recommendation"""
    data = request.json or {}
    outcome = data.get("outcome")

    if not outcome:
        return jsonify({"success": False, "error": "Outcome is required"}), 400

    result = escalation_service.record_outcome(recommendation_id, outcome)

    if result.get("error"):
        return jsonify({"success": False, "error": result["error"]}), 404

    return jsonify(result)


@app.route("/api/escalation/stats", methods=["GET"])
@require_staff()
def api_escalation_stats():
    """Get escalation success rate statistics"""
    stats = escalation_service.get_escalation_stats()
    return jsonify(stats)


@app.route("/api/escalation/timeline/<int:client_id>", methods=["GET"])
@require_staff()
def api_escalation_timeline(client_id):
    """Get action timeline for a client"""
    result = escalation_service.get_escalation_timeline(client_id)

    if result.get("error"):
        return jsonify({"success": False, "error": result["error"]}), 404

    return jsonify(result)


@app.route("/api/escalation/needs-review", methods=["GET"])
@require_staff()
def api_escalation_needs_review():
    """Get cases needing escalation review"""
    cases = escalation_service.get_cases_needing_escalation_review()
    return jsonify({"success": True, "cases": cases, "total": len(cases)})


@app.route("/api/escalation/actions", methods=["GET"])
@require_staff()
def api_escalation_actions():
    """Get all available escalation action types"""
    return jsonify(
        {
            "success": True,
            "dispute_actions": escalation_service.DISPUTE_ACTIONS,
            "timing_actions": escalation_service.TIMING_ACTIONS,
            "documentation_actions": escalation_service.DOCUMENTATION_ACTIONS,
        }
    )


@app.route("/dashboard/escalation")
@require_staff()
def escalation_dashboard():
    """Smart escalation dashboard view"""
    stats = escalation_service.get_escalation_stats()
    cases_needing_review = escalation_service.get_cases_needing_escalation_review()

    db = get_db()
    try:
        recent_recommendations = (
            db.query(EscalationRecommendation)
            .order_by(EscalationRecommendation.created_at.desc())
            .limit(20)
            .all()
        )

        applied_recommendations = (
            db.query(EscalationRecommendation)
            .filter_by(applied=True)
            .order_by(EscalationRecommendation.applied_at.desc())
            .limit(10)
            .all()
        )

        return render_template(
            "escalation_dashboard.html",
            stats=stats,
            cases_needing_review=cases_needing_review,
            recent_recommendations=[r.to_dict() for r in recent_recommendations],
            applied_recommendations=[r.to_dict() for r in applied_recommendations],
            action_types=escalation_service.DISPUTE_ACTIONS,
        )
    except Exception as e:
        print(f"Escalation dashboard error: {e}")
        return render_template(
            "escalation_dashboard.html",
            stats={},
            cases_needing_review=[],
            recent_recommendations=[],
            applied_recommendations=[],
            action_types=escalation_service.DISPUTE_ACTIONS,
            error=str(e),
        )
    finally:
        db.close()


@app.route("/dashboard/case-law")
@require_staff()
def case_law_dashboard():
    """Case law citation database dashboard"""
    db = get_db()
    try:
        cases = case_law_service.get_all_cases(db=db)

        courts = set()
        violation_types = set()
        fcra_sections = set()
        for case in cases:
            if case.get("court"):
                courts.add(case["court"])
            for vt in case.get("violation_types") or []:
                violation_types.add(vt)
            for section in case.get("fcra_sections") or []:
                fcra_sections.add(section)

        return render_template(
            "case_law.html",
            cases=cases,
            courts=sorted(courts),
            violation_types=sorted(violation_types),
            fcra_sections=sorted(fcra_sections),
            total_cases=len(cases),
        )
    except Exception as e:
        print(f"Case law dashboard error: {e}")
        return render_template(
            "case_law.html",
            cases=[],
            courts=[],
            violation_types=[],
            fcra_sections=[],
            total_cases=0,
            error=str(e),
        )
    finally:
        db.close()


@app.route("/dashboard/knowledge-base")
@require_staff()
def dashboard_knowledge_base():
    """Enhanced Legal Strategy Knowledge Base with training content"""
    db = get_db()
    try:
        course = request.args.get("course", "all")
        search = request.args.get("search", "")

        query = db.query(KnowledgeContent).filter(KnowledgeContent.is_active == True)
        if course != "all":
            query = query.filter(KnowledgeContent.course == course)
        if search:
            query = query.filter(
                (KnowledgeContent.content.ilike(f"%{search}%"))
                | (KnowledgeContent.section_title.ilike(f"%{search}%"))
                | (KnowledgeContent.search_keywords.ilike(f"%{search}%"))
            )

        content = query.order_by(
            KnowledgeContent.course, KnowledgeContent.section_number
        ).all()

        metro2_codes = (
            db.query(Metro2Code).order_by(Metro2Code.code_type, Metro2Code.code).all()
        )

        credit_repair_count = (
            db.query(KnowledgeContent)
            .filter(KnowledgeContent.course == "credit_repair")
            .count()
        )
        metro2_count = (
            db.query(KnowledgeContent)
            .filter(KnowledgeContent.course == "metro2")
            .count()
        )

        return render_template(
            "knowledge_base_enhanced.html",
            content=content,
            metro2_codes=metro2_codes,
            current_course=course,
            search_query=search,
            credit_repair_count=credit_repair_count,
            metro2_count=metro2_count,
        )
    except Exception as e:
        print(f"Knowledge base error: {e}")
        return render_template(
            "knowledge_base_enhanced.html", content=[], metro2_codes=[], error=str(e)
        )
    finally:
        db.close()


@app.route("/dashboard/sops")
@require_staff()
def dashboard_sops():
    """Standard Operating Procedures for credit repair workflows"""
    db = get_db()
    try:
        category = request.args.get("category", "all")
        search = request.args.get("search", "")

        query = db.query(SOP).filter(SOP.is_active == True)
        if category != "all":
            query = query.filter(SOP.category == category)
        if search:
            query = query.filter(
                (SOP.title.ilike(f"%{search}%"))
                | (SOP.description.ilike(f"%{search}%"))
                | (SOP.content.ilike(f"%{search}%"))
            )

        sops = query.order_by(SOP.category, SOP.display_order).all()

        categories = (
            db.query(SOP.category).filter(SOP.is_active == True).distinct().all()
        )
        categories = sorted(set([c[0] for c in categories if c[0]]))

        category_counts = {}
        for cat in categories:
            category_counts[cat] = (
                db.query(SOP).filter(SOP.category == cat, SOP.is_active == True).count()
            )

        return render_template(
            "sops.html",
            sops=sops,
            categories=categories,
            category_counts=category_counts,
            current_category=category,
            search_query=search,
            total_sops=len(sops),
        )
    except Exception as e:
        print(f"SOPs dashboard error: {e}")
        return render_template("sops.html", sops=[], categories=[], error=str(e))
    finally:
        db.close()


@app.route("/dashboard/chexsystems")
@require_staff()
def dashboard_chexsystems():
    """ChexSystems and Early Warning Services dispute helper"""
    db = get_db()
    try:
        status = request.args.get("status", "all")
        client_id = request.args.get("client_id")

        query = db.query(ChexSystemsDispute)
        if status != "all":
            query = query.filter(ChexSystemsDispute.status == status)
        if client_id:
            query = query.filter(ChexSystemsDispute.client_id == int(client_id))

        disputes = query.order_by(ChexSystemsDispute.created_at.desc()).all()

        clients = (
            db.query(Client)
            .filter(Client.status.in_(["active", "signup"]))
            .order_by(Client.name)
            .all()
        )

        stats = {
            "total": db.query(ChexSystemsDispute).count(),
            "pending": db.query(ChexSystemsDispute)
            .filter(ChexSystemsDispute.status == "pending")
            .count(),
            "sent": db.query(ChexSystemsDispute)
            .filter(ChexSystemsDispute.status == "sent")
            .count(),
            "responded": db.query(ChexSystemsDispute)
            .filter(ChexSystemsDispute.status == "responded")
            .count(),
            "resolved": db.query(ChexSystemsDispute)
            .filter(ChexSystemsDispute.status == "resolved")
            .count(),
        }

        dispute_templates = [
            {
                "id": "unauthorized_account",
                "name": "Unauthorized Account Dispute",
                "description": "Dispute an account opened without your authorization",
                "bureau_type": "chexsystems",
            },
            {
                "id": "identity_theft",
                "name": "Identity Theft Dispute",
                "description": "Dispute fraudulent accounts due to identity theft",
                "bureau_type": "both",
            },
            {
                "id": "incorrect_info",
                "name": "Incorrect Information",
                "description": "Dispute inaccurate account details or balances",
                "bureau_type": "both",
            },
            {
                "id": "outdated_info",
                "name": "Outdated Information",
                "description": "Request removal of old/obsolete information",
                "bureau_type": "both",
            },
            {
                "id": "bank_error",
                "name": "Bank Error Dispute",
                "description": "Dispute charges or closures due to bank error",
                "bureau_type": "chexsystems",
            },
            {
                "id": "paid_account",
                "name": "Paid/Settled Account",
                "description": "Update status for paid or settled accounts",
                "bureau_type": "ews",
            },
        ]

        return render_template(
            "chexsystems.html",
            disputes=disputes,
            clients=clients,
            stats=stats,
            dispute_templates=dispute_templates,
            current_status=status,
            current_client_id=client_id,
        )
    except Exception as e:
        print(f"ChexSystems dashboard error: {e}")
        return render_template(
            "chexsystems.html", disputes=[], clients=[], stats={}, error=str(e)
        )
    finally:
        db.close()


# ============================================================
# KNOWLEDGE BASE & TRAINING CONTENT API
# ============================================================


@app.route("/api/knowledge/search", methods=["GET"])
@require_staff()
def api_knowledge_search():
    """Search knowledge content with filters"""
    db = get_db()
    try:
        search = request.args.get("q", "")
        course = request.args.get("course", "all")
        content_type = request.args.get("type", "all")
        limit = min(int(request.args.get("limit", 50)), 100)

        query = db.query(KnowledgeContent).filter(KnowledgeContent.is_active == True)

        if search:
            query = query.filter(
                (KnowledgeContent.content.ilike(f"%{search}%"))
                | (KnowledgeContent.section_title.ilike(f"%{search}%"))
                | (KnowledgeContent.search_keywords.ilike(f"%{search}%"))
            )
        if course != "all":
            query = query.filter(KnowledgeContent.course == course)
        if content_type != "all":
            query = query.filter(KnowledgeContent.content_type == content_type)

        results = (
            query.order_by(KnowledgeContent.course, KnowledgeContent.section_number)
            .limit(limit)
            .all()
        )

        return jsonify(
            {
                "success": True,
                "results": [r.to_dict() for r in results],
                "count": len(results),
            }
        )
    except Exception as e:
        print(f"Knowledge search error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/metro2/codes", methods=["GET"])
@require_staff()
def api_metro2_codes():
    """Get Metro 2 codes with optional filtering"""
    db = get_db()
    try:
        code_type = request.args.get("type", "all")
        category = request.args.get("category", "all")
        derogatory_only = request.args.get("derogatory", "false").lower() == "true"

        query = db.query(Metro2Code)

        if code_type != "all":
            query = query.filter(Metro2Code.code_type == code_type)
        if category != "all":
            query = query.filter(Metro2Code.category == category)
        if derogatory_only:
            query = query.filter(Metro2Code.is_derogatory == True)

        codes = query.order_by(Metro2Code.code_type, Metro2Code.code).all()

        code_types = db.query(Metro2Code.code_type).distinct().all()
        code_types = sorted(set([c[0] for c in code_types if c[0]]))

        return jsonify(
            {
                "success": True,
                "codes": [c.to_dict() for c in codes],
                "code_types": code_types,
                "count": len(codes),
            }
        )
    except Exception as e:
        print(f"Metro2 codes error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/metro2/validate", methods=["POST"])
@require_staff()
def api_metro2_validate():
    """Validate account data against Metro 2¬Æ 2025 compliance rules"""
    try:
        from metro2_validator import (
            run_full_metro2_validation,
            validate_account_status,
            validate_dofd_hierarchy,
            validate_payment_pattern,
        )

        data = request.get_json() or {}
        accounts = data.get("accounts", [])

        if not accounts:
            return (
                jsonify(
                    {"success": False, "error": "No accounts provided for validation"}
                ),
                400,
            )

        results = run_full_metro2_validation(accounts)

        return jsonify(
            {
                "success": True,
                "validation_results": results,
                "total_accounts": len(accounts),
                "violations_found": len(results.get("metro2_violations", [])),
                "compliance_score": results.get("compliance_score", 100),
                "is_2025_compliant": results.get("2025_compliant", True),
            }
        )
    except ImportError as e:
        print(f"Metro2 validator import error: {e}")
        return (
            jsonify(
                {"success": False, "error": "Metro 2 validator module not available"}
            ),
            500,
        )
    except Exception as e:
        print(f"Metro2 validation error: {e}")
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/metro2/validate-single", methods=["POST"])
@require_staff()
def api_metro2_validate_single():
    """Validate a single account field against Metro 2¬Æ rules"""
    try:
        from metro2_validator import (
            ACCOUNT_STATUS_CODES,
            PAYMENT_RATING_CODES,
            validate_account_status,
            validate_compliance_conditions,
            validate_dofd_hierarchy,
            validate_payment_pattern,
            validate_special_comments,
        )

        data = request.get_json() or {}
        validation_type = data.get("type", "status")

        result = {"valid": True, "issues": [], "info": {}}

        if validation_type == "status":
            status_code = data.get("status_code", "")
            result = validate_account_status(status_code)
            if status_code in ACCOUNT_STATUS_CODES:
                result["info"] = ACCOUNT_STATUS_CODES[status_code]

        elif validation_type == "payment":
            pattern = data.get("pattern", "")
            status = data.get("status", "")
            result = validate_payment_pattern(pattern, status)

        elif validation_type == "dofd":
            dofd = data.get("dofd", "")
            status_changes = data.get("status_changes", [])
            original_dofd = data.get("original_dofd")
            result = validate_dofd_hierarchy(dofd, status_changes, original_dofd)

        elif validation_type == "comments":
            comments = data.get("comments", [])
            account_data = data.get("account_data", {})
            result = validate_special_comments(comments, account_data)

        elif validation_type == "compliance":
            conditions = data.get("conditions", [])
            account_data = data.get("account_data", {})
            result = validate_compliance_conditions(conditions, account_data)
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Unknown validation type: {validation_type}",
                    }
                ),
                400,
            )

        return jsonify(
            {"success": True, "validation_type": validation_type, "result": result}
        )
    except ImportError as e:
        print(f"Metro2 validator import error: {e}")
        return (
            jsonify(
                {"success": False, "error": "Metro 2 validator module not available"}
            ),
            500,
        )
    except Exception as e:
        print(f"Metro2 single validation error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/metro2/reference", methods=["GET"])
def api_metro2_reference():
    """Get Metro 2¬Æ code reference data (public endpoint for lookup)"""
    try:
        from metro2_validator import (
            ACCOUNT_STATUS_CODES,
            COMPLIANCE_2025_REQUIREMENTS,
            COMPLIANCE_CONDITION_CODES,
            PAYMENT_RATING_CODES,
            SPECIAL_COMMENT_CODES,
        )

        code_type = request.args.get("type", "all")

        response_data = {}

        if code_type in ["all", "status"]:
            response_data["account_status_codes"] = ACCOUNT_STATUS_CODES
        if code_type in ["all", "payment"]:
            response_data["payment_rating_codes"] = PAYMENT_RATING_CODES
        if code_type in ["all", "comments"]:
            response_data["special_comment_codes"] = SPECIAL_COMMENT_CODES
        if code_type in ["all", "compliance"]:
            response_data["compliance_condition_codes"] = COMPLIANCE_CONDITION_CODES
        if code_type in ["all", "requirements"]:
            response_data["requirements_2025"] = COMPLIANCE_2025_REQUIREMENTS

        return jsonify({"success": True, "code_type": code_type, "data": response_data})
    except ImportError as e:
        print(f"Metro2 validator import error: {e}")
        return (
            jsonify(
                {"success": False, "error": "Metro 2 validator module not available"}
            ),
            500,
        )
    except Exception as e:
        print(f"Metro2 reference error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/sops", methods=["GET"])
@require_staff()
def api_list_sops():
    """List SOPs with filtering"""
    db = get_db()
    try:
        category = request.args.get("category", "all")
        difficulty = request.args.get("difficulty", "all")
        search = request.args.get("q", "")

        query = db.query(SOP).filter(SOP.is_active == True)

        if category != "all":
            query = query.filter(SOP.category == category)
        if difficulty != "all":
            query = query.filter(SOP.difficulty == difficulty)
        if search:
            query = query.filter(
                (SOP.title.ilike(f"%{search}%"))
                | (SOP.description.ilike(f"%{search}%"))
            )

        sops = query.order_by(SOP.category, SOP.display_order).all()

        categories = (
            db.query(SOP.category).filter(SOP.is_active == True).distinct().all()
        )
        categories = sorted(set([c[0] for c in categories if c[0]]))

        return jsonify(
            {
                "success": True,
                "sops": [s.to_dict() for s in sops],
                "categories": categories,
                "count": len(sops),
            }
        )
    except Exception as e:
        print(f"SOPs API error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/sops/<int:sop_id>", methods=["GET"])
@require_staff()
def api_get_sop(sop_id):
    """Get single SOP by ID"""
    db = get_db()
    try:
        sop = db.query(SOP).filter(SOP.id == sop_id).first()
        if not sop:
            return jsonify({"success": False, "error": "SOP not found"}), 404

        return jsonify({"success": True, "sop": sop.to_dict()})
    except Exception as e:
        print(f"Get SOP error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/chexsystems/disputes", methods=["GET"])
@require_staff()
def api_list_chexsystems_disputes():
    """List ChexSystems disputes"""
    db = get_db()
    try:
        status = request.args.get("status", "all")
        client_id = request.args.get("client_id")
        bureau_type = request.args.get("bureau_type", "all")

        query = db.query(ChexSystemsDispute)

        if status != "all":
            query = query.filter(ChexSystemsDispute.status == status)
        if client_id:
            query = query.filter(ChexSystemsDispute.client_id == int(client_id))
        if bureau_type != "all":
            query = query.filter(ChexSystemsDispute.bureau_type == bureau_type)

        disputes = query.order_by(ChexSystemsDispute.created_at.desc()).all()

        return jsonify(
            {
                "success": True,
                "disputes": [d.to_dict() for d in disputes],
                "count": len(disputes),
            }
        )
    except Exception as e:
        print(f"ChexSystems disputes list error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/chexsystems/disputes", methods=["POST"])
@require_staff()
def api_create_chexsystems_dispute():
    """Create a new ChexSystems dispute"""
    db = get_db()
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        required_fields = ["client_id", "bureau_type", "dispute_type"]
        for field in required_fields:
            if field not in data:
                return (
                    jsonify(
                        {"success": False, "error": f"Missing required field: {field}"}
                    ),
                    400,
                )

        client = db.query(Client).filter(Client.id == data["client_id"]).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        dispute = ChexSystemsDispute(
            client_id=data["client_id"],
            bureau_type=data["bureau_type"],
            dispute_type=data["dispute_type"],
            account_type=data.get("account_type"),
            reported_by=data.get("reported_by"),
            dispute_reason=data.get("dispute_reason"),
            dispute_details=data.get("dispute_details", {}),
            letter_type=data.get("letter_type"),
            notes=data.get("notes"),
            status="pending",
        )

        db.add(dispute)
        db.commit()

        return jsonify(
            {
                "success": True,
                "dispute": dispute.to_dict(),
                "message": "ChexSystems dispute created successfully",
            }
        )
    except Exception as e:
        db.rollback()
        print(f"Create ChexSystems dispute error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/chexsystems/disputes/<int:dispute_id>", methods=["PUT"])
@require_staff()
def api_update_chexsystems_dispute(dispute_id):
    """Update a ChexSystems dispute"""
    db = get_db()
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        dispute = (
            db.query(ChexSystemsDispute)
            .filter(ChexSystemsDispute.id == dispute_id)
            .first()
        )
        if not dispute:
            return jsonify({"success": False, "error": "Dispute not found"}), 404

        updatable_fields = [
            "dispute_type",
            "account_type",
            "reported_by",
            "dispute_reason",
            "dispute_details",
            "letter_sent_date",
            "letter_type",
            "tracking_number",
            "response_due_date",
            "response_received_date",
            "response_outcome",
            "response_details",
            "status",
            "escalation_level",
            "next_action",
            "notes",
        ]

        for field in updatable_fields:
            if field in data:
                if (
                    field
                    in [
                        "letter_sent_date",
                        "response_due_date",
                        "response_received_date",
                    ]
                    and data[field]
                ):
                    setattr(
                        dispute,
                        field,
                        datetime.fromisoformat(data[field].replace("Z", "+00:00")),
                    )
                else:
                    setattr(dispute, field, data[field])

        db.commit()

        return jsonify(
            {
                "success": True,
                "dispute": dispute.to_dict(),
                "message": "Dispute updated successfully",
            }
        )
    except Exception as e:
        db.rollback()
        print(f"Update ChexSystems dispute error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# SPECIALTY BUREAU DISPUTES DASHBOARD
# ============================================================


@app.route("/dashboard/specialty-bureaus")
@require_staff()
def dashboard_specialty_bureaus():
    """Unified specialty bureau disputes dashboard"""
    db = get_db()
    try:
        status = request.args.get("status", "all")
        client_id = request.args.get("client_id")
        bureau = request.args.get("bureau")

        query = db.query(SpecialtyBureauDispute)
        if status != "all":
            query = query.filter(SpecialtyBureauDispute.status == status)
        if client_id:
            query = query.filter(SpecialtyBureauDispute.client_id == int(client_id))
        if bureau:
            query = query.filter(SpecialtyBureauDispute.bureau_name == bureau)

        disputes = (
            query.order_by(SpecialtyBureauDispute.created_at.desc()).limit(50).all()
        )

        clients = (
            db.query(Client)
            .filter(Client.status.in_(["active", "signup"]))
            .order_by(Client.name)
            .all()
        )

        total_disputes = db.query(SpecialtyBureauDispute).count()
        pending_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "pending")
            .count()
        )
        sent_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "sent")
            .count()
        )
        awaiting_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "awaiting_response")
            .count()
        )
        resolved_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "resolved")
            .count()
        )
        escalated_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "escalated")
            .count()
        )

        deleted_outcomes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.response_outcome == "deleted")
            .count()
        )
        total_with_outcome = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.response_outcome.isnot(None))
            .count()
        )
        success_rate = round(
            (deleted_outcomes / total_with_outcome * 100)
            if total_with_outcome > 0
            else 0
        )

        stats = {
            "total": total_disputes,
            "pending": pending_disputes,
            "sent": sent_disputes,
            "awaiting_response": awaiting_disputes,
            "resolved": resolved_disputes,
            "escalated": escalated_disputes,
            "success_rate": success_rate,
        }

        bureau_stats = {}
        for bureau_name in SPECIALTY_BUREAUS:
            active = (
                db.query(SpecialtyBureauDispute)
                .filter(
                    SpecialtyBureauDispute.bureau_name == bureau_name,
                    SpecialtyBureauDispute.status.in_(
                        ["pending", "sent", "awaiting_response", "escalated"]
                    ),
                )
                .count()
            )
            pending_response = (
                db.query(SpecialtyBureauDispute)
                .filter(
                    SpecialtyBureauDispute.bureau_name == bureau_name,
                    SpecialtyBureauDispute.status == "awaiting_response",
                )
                .count()
            )
            bureau_stats[bureau_name] = {
                "active": active,
                "pending_response": pending_response,
            }

        disputes_with_clients = []
        for dispute in disputes:
            client = db.query(Client).filter(Client.id == dispute.client_id).first()
            dispute_dict = dispute.to_dict()
            dispute_dict["client_name"] = client.name if client else "Unknown"
            disputes_with_clients.append(dispute_dict)

        return render_template(
            "specialty_bureaus.html",
            disputes=disputes_with_clients,
            clients=clients,
            stats=stats,
            bureau_stats=bureau_stats,
            bureaus=SPECIALTY_BUREAUS,
            dispute_types=SPECIALTY_DISPUTE_TYPES,
            letter_types=SPECIALTY_LETTER_TYPES,
            response_outcomes=SPECIALTY_RESPONSE_OUTCOMES,
            current_status=status,
            current_client_id=client_id,
            current_bureau=bureau,
        )
    except Exception as e:
        print(f"Specialty bureaus dashboard error: {e}")
        import traceback

        traceback.print_exc()
        return render_template(
            "specialty_bureaus.html",
            disputes=[],
            clients=[],
            stats={
                "total": 0,
                "pending": 0,
                "sent": 0,
                "awaiting_response": 0,
                "resolved": 0,
                "escalated": 0,
                "success_rate": 0,
            },
            bureau_stats={
                b: {"active": 0, "pending_response": 0} for b in SPECIALTY_BUREAUS
            },
            bureaus=SPECIALTY_BUREAUS,
            dispute_types=SPECIALTY_DISPUTE_TYPES,
            letter_types=SPECIALTY_LETTER_TYPES,
            response_outcomes=SPECIALTY_RESPONSE_OUTCOMES,
            current_status="all",
            current_client_id=None,
            current_bureau=None,
            error=str(e),
        )
    finally:
        db.close()


@app.route("/api/specialty-bureaus/disputes", methods=["GET"])
@require_staff()
def api_list_specialty_disputes():
    """List specialty bureau disputes with filtering"""
    db = get_db()
    try:
        status = request.args.get("status", "all")
        client_id = request.args.get("client_id")
        bureau = request.args.get("bureau")

        query = db.query(SpecialtyBureauDispute)

        if status != "all":
            query = query.filter(SpecialtyBureauDispute.status == status)
        if client_id:
            query = query.filter(SpecialtyBureauDispute.client_id == int(client_id))
        if bureau:
            query = query.filter(SpecialtyBureauDispute.bureau_name == bureau)

        disputes = query.order_by(SpecialtyBureauDispute.created_at.desc()).all()

        disputes_with_clients = []
        for dispute in disputes:
            client = db.query(Client).filter(Client.id == dispute.client_id).first()
            dispute_dict = dispute.to_dict()
            dispute_dict["client_name"] = client.name if client else "Unknown"
            disputes_with_clients.append(dispute_dict)

        return jsonify(
            {"success": True, "disputes": disputes_with_clients, "count": len(disputes)}
        )
    except Exception as e:
        print(f"Specialty disputes list error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/specialty-bureaus/disputes", methods=["POST"])
@require_staff()
def api_create_specialty_dispute():
    """Create a new specialty bureau dispute"""
    db = get_db()
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        required_fields = [
            "client_id",
            "bureau_name",
            "dispute_type",
            "account_name",
            "dispute_reason",
        ]
        for field in required_fields:
            if field not in data or not data[field]:
                return (
                    jsonify(
                        {"success": False, "error": f"Missing required field: {field}"}
                    ),
                    400,
                )

        if data["bureau_name"] not in SPECIALTY_BUREAUS:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Invalid bureau. Must be one of: {', '.join(SPECIALTY_BUREAUS)}",
                    }
                ),
                400,
            )

        client = db.query(Client).filter(Client.id == data["client_id"]).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        letter_sent_date = None
        response_due_date = None
        if data.get("letter_sent_date"):
            try:
                letter_sent_date = datetime.fromisoformat(
                    data["letter_sent_date"]
                    .replace("Z", "+00:00")
                    .replace("T", " ")
                    .split("+")[0]
                )
                response_due_date = letter_sent_date + timedelta(days=30)
            except:
                pass

        dispute = SpecialtyBureauDispute(
            client_id=data["client_id"],
            bureau_name=data["bureau_name"],
            dispute_type=data["dispute_type"],
            account_name=data["account_name"],
            account_number=data.get("account_number"),
            dispute_reason=data["dispute_reason"],
            dispute_details=data.get("dispute_details", {}),
            supporting_docs=data.get("supporting_docs", []),
            letter_sent_date=letter_sent_date,
            letter_type=data.get("letter_type"),
            tracking_number=data.get("tracking_number"),
            response_due_date=response_due_date,
            notes=data.get("notes"),
            status="pending" if not letter_sent_date else "sent",
        )

        db.add(dispute)
        db.commit()

        return jsonify(
            {
                "success": True,
                "dispute": dispute.to_dict(),
                "message": "Specialty bureau dispute created successfully",
            }
        )
    except Exception as e:
        db.rollback()
        print(f"Create specialty dispute error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/specialty-bureaus/disputes/<int:dispute_id>", methods=["PUT"])
@require_staff()
def api_update_specialty_dispute(dispute_id):
    """Update a specialty bureau dispute"""
    db = get_db()
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        dispute = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.id == dispute_id)
            .first()
        )
        if not dispute:
            return jsonify({"success": False, "error": "Dispute not found"}), 404

        updatable_fields = [
            "bureau_name",
            "dispute_type",
            "account_name",
            "account_number",
            "dispute_reason",
            "dispute_details",
            "supporting_docs",
            "letter_type",
            "tracking_number",
            "response_outcome",
            "status",
            "escalation_level",
            "next_action",
            "notes",
        ]

        date_fields = [
            "letter_sent_date",
            "response_due_date",
            "response_received_date",
        ]

        for field in updatable_fields:
            if field in data:
                setattr(dispute, field, data[field])

        for field in date_fields:
            if field in data:
                if data[field]:
                    try:
                        setattr(
                            dispute,
                            field,
                            datetime.fromisoformat(
                                data[field]
                                .replace("Z", "+00:00")
                                .replace("T", " ")
                                .split("+")[0]
                            ),
                        )
                    except:
                        pass
                else:
                    setattr(dispute, field, None)

        if data.get("letter_sent_date") and not dispute.response_due_date:
            dispute.response_due_date = dispute.letter_sent_date + timedelta(days=30)

        if data.get("status") == "sent" and dispute.letter_sent_date:
            dispute.status = "awaiting_response"

        db.commit()

        return jsonify(
            {
                "success": True,
                "dispute": dispute.to_dict(),
                "message": "Dispute updated successfully",
            }
        )
    except Exception as e:
        db.rollback()
        print(f"Update specialty dispute error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/specialty-bureaus/disputes/<int:dispute_id>", methods=["DELETE"])
@require_staff()
def api_delete_specialty_dispute(dispute_id):
    """Delete a specialty bureau dispute"""
    db = get_db()
    try:
        dispute = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.id == dispute_id)
            .first()
        )
        if not dispute:
            return jsonify({"success": False, "error": "Dispute not found"}), 404

        db.delete(dispute)
        db.commit()

        return jsonify({"success": True, "message": "Dispute deleted successfully"})
    except Exception as e:
        db.rollback()
        print(f"Delete specialty dispute error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/specialty-bureaus/stats", methods=["GET"])
@require_staff()
def api_specialty_bureaus_stats():
    """Get aggregate stats for specialty bureaus dashboard"""
    db = get_db()
    try:
        total_disputes = db.query(SpecialtyBureauDispute).count()
        pending_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "pending")
            .count()
        )
        sent_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "sent")
            .count()
        )
        awaiting_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "awaiting_response")
            .count()
        )
        resolved_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "resolved")
            .count()
        )
        escalated_disputes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.status == "escalated")
            .count()
        )

        deleted_outcomes = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.response_outcome == "deleted")
            .count()
        )
        total_with_outcome = (
            db.query(SpecialtyBureauDispute)
            .filter(SpecialtyBureauDispute.response_outcome.isnot(None))
            .count()
        )
        success_rate = round(
            (deleted_outcomes / total_with_outcome * 100)
            if total_with_outcome > 0
            else 0
        )

        bureau_stats = {}
        for bureau_name in SPECIALTY_BUREAUS:
            active = (
                db.query(SpecialtyBureauDispute)
                .filter(
                    SpecialtyBureauDispute.bureau_name == bureau_name,
                    SpecialtyBureauDispute.status.in_(
                        ["pending", "sent", "awaiting_response", "escalated"]
                    ),
                )
                .count()
            )
            pending_response = (
                db.query(SpecialtyBureauDispute)
                .filter(
                    SpecialtyBureauDispute.bureau_name == bureau_name,
                    SpecialtyBureauDispute.status == "awaiting_response",
                )
                .count()
            )
            total_bureau = (
                db.query(SpecialtyBureauDispute)
                .filter(SpecialtyBureauDispute.bureau_name == bureau_name)
                .count()
            )
            resolved_bureau = (
                db.query(SpecialtyBureauDispute)
                .filter(
                    SpecialtyBureauDispute.bureau_name == bureau_name,
                    SpecialtyBureauDispute.status == "resolved",
                )
                .count()
            )
            bureau_stats[bureau_name] = {
                "active": active,
                "pending_response": pending_response,
                "total": total_bureau,
                "resolved": resolved_bureau,
            }

        return jsonify(
            {
                "success": True,
                "stats": {
                    "total": total_disputes,
                    "pending": pending_disputes,
                    "sent": sent_disputes,
                    "awaiting_response": awaiting_disputes,
                    "resolved": resolved_disputes,
                    "escalated": escalated_disputes,
                    "success_rate": success_rate,
                },
                "bureau_stats": bureau_stats,
            }
        )
    except Exception as e:
        print(f"Specialty bureaus stats error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# FRIVOLOUSNESS DEFENSE TRACKER
# ============================================================

FRIVOLOUS_EVIDENCE_TYPES = [
    {
        "id": "government_id",
        "name": "Government-Issued ID",
        "description": "Valid drivers license, passport, or state ID",
    },
    {
        "id": "utility_bill",
        "name": "Utility Bill",
        "description": "Recent utility bill showing name and address",
    },
    {
        "id": "bank_statement",
        "name": "Bank Statement",
        "description": "Recent bank statement showing name and address",
    },
    {
        "id": "ssn_card",
        "name": "Social Security Card",
        "description": "Copy of Social Security card",
    },
    {
        "id": "affidavit",
        "name": "Consumer Affidavit",
        "description": "Signed affidavit regarding dispute",
    },
    {
        "id": "police_report",
        "name": "Police Report",
        "description": "Police report for identity theft cases",
    },
    {
        "id": "ftc_report",
        "name": "FTC Identity Theft Report",
        "description": "Official FTC identity theft affidavit",
    },
    {
        "id": "credit_report",
        "name": "Credit Report Copy",
        "description": "Copy of credit report showing disputed item",
    },
    {
        "id": "payment_records",
        "name": "Payment Records",
        "description": "Cancelled checks, payment receipts",
    },
    {
        "id": "correspondence",
        "name": "Prior Correspondence",
        "description": "Previous dispute letters and CRA responses",
    },
    {
        "id": "account_statement",
        "name": "Account Statement",
        "description": "Statement from creditor/furnisher",
    },
    {
        "id": "other",
        "name": "Other Evidence",
        "description": "Other supporting documentation",
    },
]

FRIVOLOUS_STATUS_WORKFLOW = [
    {"status": "pending", "label": "Pending Review", "next": "evidence_gathering"},
    {
        "status": "evidence_gathering",
        "label": "Gathering Evidence",
        "next": "ready_to_redispute",
    },
    {
        "status": "ready_to_redispute",
        "label": "Ready to Re-dispute",
        "next": "redisputed",
    },
    {"status": "redisputed", "label": "Re-disputed", "next": "resolved"},
    {"status": "resolved", "label": "Resolved", "next": None},
]


@app.route("/dashboard/frivolousness")
@require_staff(roles=["admin", "paralegal", "attorney"])
def dashboard_frivolousness():
    """Dashboard page for frivolous defense tracking"""
    db = get_db()
    try:
        defenses = (
            db.query(FrivolousDefense)
            .order_by(FrivolousDefense.created_at.desc())
            .all()
        )

        stats = {
            "total": len(defenses),
            "pending": sum(1 for d in defenses if d.status == "pending"),
            "evidence_gathering": sum(
                1 for d in defenses if d.status == "evidence_gathering"
            ),
            "ready_to_redispute": sum(
                1 for d in defenses if d.status == "ready_to_redispute"
            ),
            "redisputed": sum(1 for d in defenses if d.status == "redisputed"),
            "resolved": sum(1 for d in defenses if d.status == "resolved"),
        }

        defense_list = []
        for defense in defenses:
            client = db.query(Client).filter(Client.id == defense.client_id).first()
            evidence_count = (
                db.query(FrivolousDefenseEvidence)
                .filter(FrivolousDefenseEvidence.defense_id == defense.id)
                .count()
            )

            required_count = (
                len(defense.required_evidence) if defense.required_evidence else 0
            )

            defense_list.append(
                {
                    "id": defense.id,
                    "client_id": defense.client_id,
                    "client_name": client.name if client else "Unknown",
                    "bureau": defense.bureau,
                    "dispute_round": defense.dispute_round,
                    "claim_date": defense.claim_date,
                    "claim_reason": defense.claim_reason,
                    "status": defense.status,
                    "evidence_collected": evidence_count,
                    "evidence_required": required_count,
                    "evidence_sufficient": defense.evidence_sufficient,
                    "follow_up_due": defense.follow_up_due,
                    "redispute_outcome": defense.redispute_outcome,
                    "created_at": defense.created_at,
                }
            )

        clients = (
            db.query(Client)
            .filter(Client.status.in_(["active", "signup"]))
            .order_by(Client.name)
            .all()
        )

        return render_template(
            "frivolousness_tracker.html",
            defenses=defense_list,
            stats=stats,
            clients=clients,
            evidence_types=FRIVOLOUS_EVIDENCE_TYPES,
            status_workflow=FRIVOLOUS_STATUS_WORKFLOW,
        )
    except Exception as e:
        print(f"Frivolousness dashboard error: {e}")
        return (
            render_template("error.html", error="Dashboard Error", message=str(e)),
            500,
        )
    finally:
        db.close()


@app.route("/api/frivolousness/add", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_add_frivolous_defense():
    """Add a new frivolous defense case"""
    db = get_db()
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        required_fields = ["client_id", "bureau"]
        for field in required_fields:
            if not data.get(field):
                return jsonify({"success": False, "error": f"{field} is required"}), 400

        claim_date = None
        if data.get("claim_date"):
            claim_date = datetime.strptime(data["claim_date"], "%Y-%m-%d").date()

        follow_up_due = None
        if data.get("follow_up_due"):
            follow_up_due = datetime.strptime(data["follow_up_due"], "%Y-%m-%d").date()

        defense = FrivolousDefense(
            client_id=int(data["client_id"]),
            bureau=data["bureau"],
            dispute_round=data.get("dispute_round", 1),
            claim_date=claim_date,
            claim_reason=data.get("claim_reason"),
            claim_citation=data.get("claim_citation"),
            required_evidence=data.get("required_evidence", []),
            new_legal_theory=data.get("new_legal_theory"),
            new_facts_required=data.get("new_facts_required"),
            defense_strategy=data.get("defense_strategy"),
            follow_up_due=follow_up_due,
            status="pending",
            assigned_to_staff_id=session.get("staff_id"),
        )

        db.add(defense)
        db.commit()

        return jsonify(
            {
                "success": True,
                "defense": defense.to_dict(),
                "message": "Frivolous defense case created successfully",
            }
        )
    except Exception as e:
        db.rollback()
        print(f"Add frivolous defense error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/frivolousness/<int:defense_id>", methods=["GET"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_get_frivolous_defense(defense_id):
    """Get a frivolous defense case details"""
    db = get_db()
    try:
        defense = (
            db.query(FrivolousDefense).filter(FrivolousDefense.id == defense_id).first()
        )
        if not defense:
            return jsonify({"success": False, "error": "Defense case not found"}), 404

        client = db.query(Client).filter(Client.id == defense.client_id).first()
        evidence_docs = (
            db.query(FrivolousDefenseEvidence)
            .filter(FrivolousDefenseEvidence.defense_id == defense_id)
            .order_by(FrivolousDefenseEvidence.created_at.desc())
            .all()
        )

        evidence_list = [
            {
                "id": e.id,
                "evidence_type": e.evidence_type,
                "file_name": e.file_name,
                "file_path": e.file_path,
                "description": e.description,
                "verified": e.verified,
                "verified_at": e.verified_at.isoformat() if e.verified_at else None,
                "created_at": e.created_at.isoformat(),
            }
            for e in evidence_docs
        ]

        defense_data = defense.to_dict()
        defense_data["client_name"] = client.name if client else "Unknown"
        defense_data["claim_citation"] = defense.claim_citation
        defense_data["new_facts_required"] = defense.new_facts_required
        defense_data["defense_strategy"] = defense.defense_strategy
        defense_data["admin_notes"] = defense.admin_notes
        defense_data["redispute_date"] = (
            defense.redispute_date.isoformat() if defense.redispute_date else None
        )
        defense_data["escalation_notes"] = defense.escalation_notes
        defense_data["evidence_docs"] = evidence_list
        defense_data["created_at"] = defense.created_at.isoformat()
        defense_data["updated_at"] = (
            defense.updated_at.isoformat() if defense.updated_at else None
        )

        return jsonify(
            {
                "success": True,
                "defense": defense_data,
                "evidence_types": FRIVOLOUS_EVIDENCE_TYPES,
                "status_workflow": FRIVOLOUS_STATUS_WORKFLOW,
            }
        )
    except Exception as e:
        print(f"Get frivolous defense error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/frivolousness/<int:defense_id>/update", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_update_frivolous_defense(defense_id):
    """Update a frivolous defense case status"""
    db = get_db()
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        defense = (
            db.query(FrivolousDefense).filter(FrivolousDefense.id == defense_id).first()
        )
        if not defense:
            return jsonify({"success": False, "error": "Defense case not found"}), 404

        updatable_fields = [
            "bureau",
            "dispute_round",
            "claim_reason",
            "claim_citation",
            "required_evidence",
            "new_legal_theory",
            "new_facts_required",
            "status",
            "defense_strategy",
            "evidence_collected",
            "evidence_sufficient",
            "redispute_outcome",
            "escalation_notes",
            "admin_notes",
        ]

        for field in updatable_fields:
            if field in data:
                setattr(defense, field, data[field])

        if "claim_date" in data and data["claim_date"]:
            defense.claim_date = datetime.strptime(
                data["claim_date"], "%Y-%m-%d"
            ).date()

        if "follow_up_due" in data and data["follow_up_due"]:
            defense.follow_up_due = datetime.strptime(
                data["follow_up_due"], "%Y-%m-%d"
            ).date()

        if "redispute_date" in data and data["redispute_date"]:
            defense.redispute_date = datetime.strptime(
                data["redispute_date"], "%Y-%m-%d"
            ).date()

        db.commit()

        return jsonify(
            {
                "success": True,
                "defense": defense.to_dict(),
                "message": "Defense case updated successfully",
            }
        )
    except Exception as e:
        db.rollback()
        print(f"Update frivolous defense error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/frivolousness/<int:defense_id>/evidence", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_upload_frivolous_evidence(defense_id):
    """Upload evidence document for a frivolous defense case"""
    db = get_db()
    try:
        defense = (
            db.query(FrivolousDefense).filter(FrivolousDefense.id == defense_id).first()
        )
        if not defense:
            return jsonify({"success": False, "error": "Defense case not found"}), 404

        if "file" not in request.files:
            return jsonify({"success": False, "error": "No file provided"}), 400

        file = request.files["file"]
        if file.filename == "":
            return jsonify({"success": False, "error": "No file selected"}), 400

        # Security check: block dangerous file extensions
        if is_blocked_extension(file.filename):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "File type not allowed for security reasons",
                    }
                ),
                400,
            )

        # Only allow safe document types
        if not allowed_file(file.filename):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Only PDF, image, and document files are allowed",
                    }
                ),
                400,
            )

        evidence_type = request.form.get("evidence_type", "other")
        description = request.form.get("description", "")

        filename = secure_filename(file.filename)
        unique_filename = f"frivolous_{defense_id}_{uuid.uuid4().hex[:8]}_{filename}"

        upload_dir = "static/client_uploads/frivolous_evidence"
        os.makedirs(upload_dir, exist_ok=True)
        file_path = os.path.join(upload_dir, unique_filename)
        file.save(file_path)

        evidence = FrivolousDefenseEvidence(
            defense_id=defense_id,
            evidence_type=evidence_type,
            file_path=file_path,
            file_name=filename,
            description=description,
        )

        db.add(evidence)

        required = defense.required_evidence or []
        if evidence_type in required:
            collected = defense.evidence_collected or []
            if evidence_type not in collected:
                collected.append(evidence_type)
                defense.evidence_collected = collected
                flag_modified(defense, "evidence_collected")

            if set(required).issubset(set(collected)):
                defense.evidence_sufficient = True

        db.commit()

        return jsonify(
            {
                "success": True,
                "evidence": {
                    "id": evidence.id,
                    "evidence_type": evidence.evidence_type,
                    "file_name": evidence.file_name,
                    "file_path": evidence.file_path,
                    "description": evidence.description,
                },
                "message": "Evidence uploaded successfully",
            }
        )
    except Exception as e:
        db.rollback()
        print(f"Upload frivolous evidence error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route(
    "/api/frivolousness/<int:defense_id>/evidence/<int:evidence_id>/verify",
    methods=["POST"],
)
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_verify_frivolous_evidence(defense_id, evidence_id):
    """Mark evidence document as verified"""
    db = get_db()
    try:
        evidence = (
            db.query(FrivolousDefenseEvidence)
            .filter(
                FrivolousDefenseEvidence.id == evidence_id,
                FrivolousDefenseEvidence.defense_id == defense_id,
            )
            .first()
        )

        if not evidence:
            return jsonify({"success": False, "error": "Evidence not found"}), 404

        evidence.verified = True
        evidence.verified_by_staff_id = session.get("staff_id")
        evidence.verified_at = datetime.utcnow()

        db.commit()

        return jsonify({"success": True, "message": "Evidence verified successfully"})
    except Exception as e:
        db.rollback()
        print(f"Verify frivolous evidence error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/frivolousness/evidence-types", methods=["GET"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_get_evidence_types():
    """Get list of available evidence types"""
    return jsonify({"success": True, "evidence_types": FRIVOLOUS_EVIDENCE_TYPES})


# ============================================================
# ESCALATION PATHWAY TRACKING API (Credit Repair Warfare)
# ============================================================

ESCALATION_STAGES = {
    "section_611": {
        "name": "¬ß611 Bureau Dispute",
        "description": "Initial dispute with CRA (Equifax, Experian, TransUnion)",
        "next_stage": "section_623",
        "triggers": [
            "verified_without_proof",
            "no_method_verification",
            "superficial_check",
        ],
    },
    "section_623": {
        "name": "¬ß623 Direct Furnisher",
        "description": "Direct dispute to furnisher bypassing bureau",
        "next_stage": "section_621",
        "triggers": [
            "furnisher_non_response",
            "continued_inaccuracy",
            "no_dispute_flag",
        ],
    },
    "section_621": {
        "name": "¬ß621 Regulators",
        "description": "Complaint to CFPB, State AG, OCC, NCUA",
        "next_stage": "section_616_617",
        "triggers": [
            "pattern_violations",
            "systemic_noncompliance",
            "regulator_pressure_fails",
        ],
    },
    "section_616_617": {
        "name": "¬ß¬ß616-617 Litigation",
        "description": "Civil lawsuit with consumer attorney",
        "next_stage": None,
        "triggers": ["willful_violations", "clear_damages", "strong_evidence"],
    },
}


@app.route("/api/escalation/stages", methods=["GET"])
@require_staff()
def api_get_escalation_stages():
    """Get all escalation stages with descriptions"""
    return jsonify({"success": True, "stages": ESCALATION_STAGES})


@app.route("/api/escalation/items", methods=["GET"])
@require_staff()
def api_get_escalation_items():
    """Get all dispute items grouped by escalation stage"""
    client_id = request.args.get("client_id")
    stage = request.args.get("stage")

    db = get_db()
    try:
        query = db.query(DisputeItem)

        if client_id:
            query = query.filter(DisputeItem.client_id == int(client_id))
        if stage:
            query = query.filter(DisputeItem.escalation_stage == stage)

        items = query.order_by(DisputeItem.created_at.desc()).all()

        result = {
            "section_611": [],
            "section_623": [],
            "section_621": [],
            "section_616_617": [],
        }

        for item in items:
            stage_key = item.escalation_stage or "section_611"
            if stage_key in result:
                result[stage_key].append(
                    {
                        "id": item.id,
                        "client_id": item.client_id,
                        "creditor_name": item.creditor_name,
                        "account_id": item.account_id,
                        "item_type": item.item_type,
                        "bureau": item.bureau,
                        "dispute_round": item.dispute_round,
                        "status": item.status,
                        "escalation_stage": item.escalation_stage,
                        "escalation_notes": item.escalation_notes,
                        "furnisher_dispute_sent": item.furnisher_dispute_sent,
                        "furnisher_dispute_date": (
                            str(item.furnisher_dispute_date)
                            if item.furnisher_dispute_date
                            else None
                        ),
                        "cfpb_complaint_filed": item.cfpb_complaint_filed,
                        "cfpb_complaint_id": item.cfpb_complaint_id,
                        "attorney_referral": item.attorney_referral,
                        "method_of_verification_requested": item.method_of_verification_requested,
                        "method_of_verification_received": item.method_of_verification_received,
                        "sent_date": str(item.sent_date) if item.sent_date else None,
                        "response_date": (
                            str(item.response_date) if item.response_date else None
                        ),
                    }
                )

        stats = {
            "section_611": len(result["section_611"]),
            "section_623": len(result["section_623"]),
            "section_621": len(result["section_621"]),
            "section_616_617": len(result["section_616_617"]),
            "total": sum(len(v) for v in result.values()),
        }

        return jsonify({"success": True, "items": result, "stats": stats})
    except Exception as e:
        print(f"Escalation items error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/escalation/item/<int:item_id>/escalate", methods=["POST"])
@require_staff()
def api_escalate_item(item_id):
    """Escalate a dispute item to the next stage"""
    data = request.get_json() or {}
    target_stage = data.get("target_stage")
    notes = data.get("notes", "")

    db = get_db()
    try:
        item = db.query(DisputeItem).filter(DisputeItem.id == item_id).first()
        if not item:
            return jsonify({"success": False, "error": "Dispute item not found"}), 404

        current_stage = item.escalation_stage or "section_611"

        if target_stage:
            if target_stage not in ESCALATION_STAGES:
                return (
                    jsonify({"success": False, "error": "Invalid escalation stage"}),
                    400,
                )
            new_stage = target_stage
        else:
            next_stage = ESCALATION_STAGES.get(current_stage, {}).get("next_stage")
            if not next_stage:
                return (
                    jsonify({"success": False, "error": "Already at final stage"}),
                    400,
                )
            new_stage = next_stage

        item.escalation_stage = new_stage
        if notes:
            existing_notes = item.escalation_notes or ""
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M")
            item.escalation_notes = f"{existing_notes}\n[{timestamp}] Escalated to {ESCALATION_STAGES[new_stage]['name']}: {notes}".strip()

        if new_stage == "section_623" and not item.furnisher_dispute_sent:
            pass

        db.commit()

        try:
            from services.letter_queue_service import check_escalation_triggers

            letter_queue_results = check_escalation_triggers(db, item_id, new_stage)
            if letter_queue_results:
                print(
                    f"üì¨ Letter Queue: {len(letter_queue_results)} letters auto-queued for escalation to {new_stage}"
                )
        except Exception as lq_error:
            print(f"‚ö†Ô∏è  Letter queue trigger error (non-fatal): {lq_error}")

        return jsonify(
            {
                "success": True,
                "item_id": item_id,
                "previous_stage": current_stage,
                "new_stage": new_stage,
                "stage_info": ESCALATION_STAGES[new_stage],
                "letters_queued": (
                    len(letter_queue_results) if "letter_queue_results" in dir() else 0
                ),
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/escalation/item/<int:item_id>/update", methods=["POST"])
@require_staff()
def api_update_escalation_details(item_id):
    """Update escalation-specific details for a dispute item"""
    data = request.get_json() or {}

    db = get_db()
    try:
        item = db.query(DisputeItem).filter(DisputeItem.id == item_id).first()
        if not item:
            return jsonify({"success": False, "error": "Dispute item not found"}), 404

        if "furnisher_dispute_sent" in data:
            item.furnisher_dispute_sent = data["furnisher_dispute_sent"]
            if data["furnisher_dispute_sent"] and not item.furnisher_dispute_date:
                item.furnisher_dispute_date = datetime.utcnow().date()

        if "furnisher_dispute_date" in data:
            item.furnisher_dispute_date = (
                datetime.strptime(data["furnisher_dispute_date"], "%Y-%m-%d").date()
                if data["furnisher_dispute_date"]
                else None
            )

        if "cfpb_complaint_filed" in data:
            item.cfpb_complaint_filed = data["cfpb_complaint_filed"]
            if data["cfpb_complaint_filed"] and not item.cfpb_complaint_date:
                item.cfpb_complaint_date = datetime.utcnow().date()

        if "cfpb_complaint_id" in data:
            item.cfpb_complaint_id = data["cfpb_complaint_id"]

        if "attorney_referral" in data:
            item.attorney_referral = data["attorney_referral"]
            if data["attorney_referral"] and not item.attorney_referral_date:
                item.attorney_referral_date = datetime.utcnow().date()

        if "method_of_verification_requested" in data:
            item.method_of_verification_requested = data[
                "method_of_verification_requested"
            ]

        if "method_of_verification_received" in data:
            item.method_of_verification_received = data[
                "method_of_verification_received"
            ]

        if "escalation_notes" in data:
            item.escalation_notes = data["escalation_notes"]

        db.commit()

        return jsonify({"success": True, "message": "Escalation details updated"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/escalation/client/<int:client_id>/summary", methods=["GET"])
@require_staff()
def api_client_escalation_summary(client_id):
    """Get escalation summary for a client"""
    db = get_db()
    try:
        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        items = db.query(DisputeItem).filter(DisputeItem.client_id == client_id).all()

        summary = {
            "client_id": client_id,
            "client_name": client.name,
            "total_items": len(items),
            "stages": {
                "section_611": {"count": 0, "items": []},
                "section_623": {"count": 0, "items": []},
                "section_621": {"count": 0, "items": []},
                "section_616_617": {"count": 0, "items": []},
            },
            "metrics": {
                "method_verification_requested": 0,
                "furnisher_disputes_sent": 0,
                "cfpb_complaints_filed": 0,
                "attorney_referrals": 0,
            },
            "recommended_actions": [],
        }

        for item in items:
            stage = item.escalation_stage or "section_611"
            if stage in summary["stages"]:
                summary["stages"][stage]["count"] += 1
                summary["stages"][stage]["items"].append(
                    {
                        "id": item.id,
                        "creditor": item.creditor_name,
                        "status": item.status,
                    }
                )

            if item.method_of_verification_requested:
                summary["metrics"]["method_verification_requested"] += 1
            if item.furnisher_dispute_sent:
                summary["metrics"]["furnisher_disputes_sent"] += 1
            if item.cfpb_complaint_filed:
                summary["metrics"]["cfpb_complaints_filed"] += 1
            if item.attorney_referral:
                summary["metrics"]["attorney_referrals"] += 1

        for item in items:
            if (
                item.status in ["no_change", "verified"]
                and not item.method_of_verification_requested
            ):
                summary["recommended_actions"].append(
                    {
                        "item_id": item.id,
                        "action": "Request Method of Verification",
                        "reason": f"{item.creditor_name} verified without proof - request ¬ß611(a)(6)(B)(iii) details",
                    }
                )
            if (
                item.status in ["no_change", "verified"]
                and item.dispute_round >= 2
                and not item.furnisher_dispute_sent
            ):
                summary["recommended_actions"].append(
                    {
                        "item_id": item.id,
                        "action": "Send ¬ß623 Direct Furnisher Dispute",
                        "reason": f"{item.creditor_name} - bureau disputes unsuccessful, escalate to direct furnisher",
                    }
                )

        return jsonify({"success": True, "summary": summary})
    except Exception as e:
        print(f"Client escalation summary error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# END ESCALATION PATHWAY TRACKING API
# ============================================================


# ============================================================
# DOFD & OBSOLESCENCE ANALYSIS (Credit Repair Warfare)
# ============================================================


@app.route("/api/obsolescence/calculate", methods=["POST"])
@require_staff()
def api_calculate_obsolescence():
    """Calculate obsolescence date based on DOFD and item type"""
    data = request.get_json() or {}

    dofd_str = data.get("date_of_first_delinquency")
    item_type = data.get("item_type", "standard")

    if not dofd_str:
        return (
            jsonify({"success": False, "error": "Date of first delinquency required"}),
            400,
        )

    try:
        dofd = datetime.strptime(dofd_str, "%Y-%m-%d").date()
    except ValueError:
        return (
            jsonify({"success": False, "error": "Invalid date format. Use YYYY-MM-DD"}),
            400,
        )

    obsolescence_years = {
        "standard": 7,
        "collection": 7,
        "late_payment": 7,
        "charge_off": 7,
        "bankruptcy_ch7": 10,
        "bankruptcy_ch13": 7,
        "tax_lien_paid": 7,
        "judgment": 7,
        "inquiry": 2,
    }

    years = obsolescence_years.get(item_type, 7)

    from dateutil.relativedelta import relativedelta

    obsolescence_date = dofd + relativedelta(years=years)

    today = datetime.utcnow().date()
    days_remaining = (obsolescence_date - today).days

    if days_remaining <= 0:
        status = "obsolete"
        recommendation = "Item should be removed - past 7-year reporting period"
    elif days_remaining <= 90:
        status = "expiring_soon"
        recommendation = f"Item expires in {days_remaining} days - consider waiting or challenging DOFD accuracy"
    elif days_remaining <= 365:
        status = "within_year"
        recommendation = (
            f"Item expires in {days_remaining} days ({days_remaining // 30} months)"
        )
    else:
        status = "active"
        recommendation = f"Item has {days_remaining} days ({days_remaining // 365} years, {(days_remaining % 365) // 30} months) until obsolescence"

    return jsonify(
        {
            "success": True,
            "dofd": str(dofd),
            "item_type": item_type,
            "obsolescence_years": years,
            "obsolescence_date": str(obsolescence_date),
            "days_remaining": max(0, days_remaining),
            "status": status,
            "recommendation": recommendation,
            "legal_basis": f"FCRA ¬ß605(a) - {years}-year reporting period from Date of First Delinquency",
        }
    )


@app.route("/api/obsolescence/check-dofd", methods=["POST"])
@require_staff()
def api_check_dofd_compliance():
    """Check if DOFD is properly reported (¬ß623(a)(5) requirement)"""
    data = request.get_json() or {}

    has_dofd = data.get("has_dofd", False)
    reported_dofd = data.get("reported_dofd")
    actual_dofd = data.get("actual_dofd")

    violations = []
    recommendations = []

    if not has_dofd:
        violations.append(
            {
                "type": "missing_dofd",
                "statute": "¬ß623(a)(5)",
                "description": "Furnisher failed to report Date of First Delinquency as required",
                "severity": "high",
            }
        )
        recommendations.append("Dispute as incomplete reporting under ¬ß623(a)(5)")
        recommendations.append("File CFPB complaint for ¬ß623(a)(5) violation")

    if reported_dofd and actual_dofd:
        try:
            reported = datetime.strptime(reported_dofd, "%Y-%m-%d").date()
            actual = datetime.strptime(actual_dofd, "%Y-%m-%d").date()

            if reported != actual:
                diff_days = (reported - actual).days
                violations.append(
                    {
                        "type": "incorrect_dofd",
                        "statute": "¬ß623(a)(5)",
                        "description": f"DOFD incorrect by {abs(diff_days)} days - affects obsolescence calculation",
                        "severity": "high" if abs(diff_days) > 30 else "medium",
                        "reported": str(reported),
                        "actual": str(actual),
                    }
                )
                recommendations.append(
                    f"Challenge DOFD accuracy - off by {abs(diff_days)} days"
                )
                if reported > actual:
                    recommendations.append(
                        "Reported DOFD is later than actual - item may have expired earlier"
                    )
        except ValueError:
            pass

    return jsonify(
        {
            "success": True,
            "violations": violations,
            "recommendations": recommendations,
            "has_violations": len(violations) > 0,
            "legal_reference": "FCRA ¬ß623(a)(5) requires furnishers to report the Date of First Delinquency",
        }
    )


# ============================================================
# END DOFD & OBSOLESCENCE ANALYSIS
# ============================================================


# ============================================================
# LETTER QUEUE AUTOMATION
# Smart letter suggestions based on escalation triggers
# ============================================================


@app.route("/dashboard/letter-queue")
@require_staff()
def letter_queue_dashboard():
    """Letter Queue Dashboard - Review and approve auto-suggested letters"""
    return render_template("letter_queue.html")


@app.route("/dashboard/va-approval")
@require_staff(roles=["admin", "attorney", "paralegal"])
def va_letter_approval_dashboard():
    """VA Letter Approval Dashboard - Review and approve letters for certified mail delivery"""
    return render_template("va_letter_approval.html")


@app.route("/api/letter-queue", methods=["GET"])
@require_staff()
def api_get_letter_queue():
    """Get pending letter queue entries"""
    from services.letter_queue_service import get_pending_queue, get_queue_stats

    db = get_db()
    try:
        client_id = request.args.get("client_id", type=int)
        priority = request.args.get("priority")
        limit = request.args.get("limit", 50, type=int)

        entries = get_pending_queue(
            db, client_id=client_id, priority=priority, limit=limit
        )
        stats = get_queue_stats(db)

        return jsonify({"success": True, "entries": entries, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/stats", methods=["GET"])
@require_staff()
def api_get_letter_queue_stats():
    """Get letter queue statistics"""
    from services.letter_queue_service import get_queue_stats

    db = get_db()
    try:
        stats = get_queue_stats(db)
        return jsonify({"success": True, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/<int:queue_id>/approve", methods=["POST"])
@require_staff()
def api_approve_letter_queue(queue_id):
    """Approve a queued letter for generation"""
    from services.letter_queue_service import approve_queue_entry

    db = get_db()
    try:
        staff_id = session.get("staff_id", 1)
        data = request.get_json() or {}
        notes = data.get("notes")

        result = approve_queue_entry(db, queue_id, staff_id, notes)

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/<int:queue_id>/dismiss", methods=["POST"])
@require_staff()
def api_dismiss_letter_queue(queue_id):
    """Dismiss a queued letter suggestion"""
    from services.letter_queue_service import dismiss_queue_entry

    db = get_db()
    try:
        staff_id = session.get("staff_id", 1)
        data = request.get_json() or {}
        reason = data.get("reason", "Dismissed by staff")

        result = dismiss_queue_entry(db, queue_id, staff_id, reason)

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/bulk-approve", methods=["POST"])
@require_staff()
def api_bulk_approve_letters():
    """Approve multiple queued letters at once"""
    from services.letter_queue_service import bulk_approve

    db = get_db()
    try:
        staff_id = session.get("staff_id", 1)
        data = request.get_json() or {}
        queue_ids = data.get("queue_ids", [])

        if not queue_ids:
            return jsonify({"success": False, "error": "No queue IDs provided"}), 400

        result = bulk_approve(db, queue_ids, staff_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/run-triggers", methods=["POST"])
@require_staff(roles=["admin"])
def api_run_letter_triggers():
    """Manually run all trigger checks (admin only)"""
    from services.letter_queue_service import run_all_triggers

    db = get_db()
    try:
        result = run_all_triggers(db)
        return jsonify(
            {
                "success": True,
                "message": f'Trigger check complete. {result["total_queued"]} letters queued.',
                "details": result,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/trigger-check/<int:client_id>", methods=["POST"])
@require_staff()
def api_check_client_triggers(client_id):
    """Check triggers for a specific client"""
    from database import DisputeItem
    from services.letter_queue_service import (
        check_escalation_triggers,
        check_item_type_triggers,
    )

    db = get_db()
    try:
        results = []

        items = db.query(DisputeItem).filter_by(client_id=client_id).all()
        for item in items:
            item_results = check_item_type_triggers(db, item.id)
            results.extend(item_results)

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "letters_queued": len(results),
                "details": results,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/<int:queue_id>/generate", methods=["POST"])
@require_staff()
def api_generate_queued_letter(queue_id):
    """Generate PDF for an approved queued letter"""
    from database import Client, LetterQueue

    db = get_db()
    try:
        entry = db.query(LetterQueue).filter_by(id=queue_id).first()
        if not entry:
            return jsonify({"success": False, "error": "Queue entry not found"}), 404

        if entry.status not in ["pending", "approved"]:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Cannot generate - status is {entry.status}",
                    }
                ),
                400,
            )

        client = db.query(Client).filter_by(id=entry.client_id).first()
        letter_data = entry.letter_data or {}
        letter_data["client_name"] = (
            client.name if client else letter_data.get("client_name", "Unknown")
        )
        letter_data["client_address"] = (
            {
                "street": client.address_street if client else "",
                "city": client.address_city if client else "",
                "state": client.address_state if client else "",
                "zip": client.address_zip if client else "",
            }
            if client
            else {}
        )

        entry.status = "generated"
        entry.generated_at = datetime.utcnow()
        entry.updated_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "queue_id": queue_id,
                "letter_type": entry.letter_type,
                "status": "generated",
                "message": "Letter generated successfully. Use Automation Tools to customize and download.",
                "letter_data": letter_data,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/letter-queue/letter-types", methods=["GET"])
@require_staff()
def api_get_letter_types():
    """Get available letter types and their descriptions"""
    from services.letter_queue_service import LETTER_TYPE_DISPLAY, TRIGGER_DISPLAY

    return jsonify(
        {
            "success": True,
            "letter_types": LETTER_TYPE_DISPLAY,
            "trigger_types": TRIGGER_DISPLAY,
        }
    )


# ============================================================
# END LETTER QUEUE AUTOMATION
# ============================================================


@app.route("/api/case-law", methods=["GET"])
@require_staff()
def api_get_case_law():
    """List all cases with optional filters"""
    filters = {
        "court": request.args.get("court"),
        "section": request.args.get("section"),
        "violation_type": request.args.get("violation_type"),
        "year": request.args.get("year"),
        "plaintiff_won": request.args.get("plaintiff_won"),
    }
    filters = {k: v for k, v in filters.items() if v is not None}

    if "plaintiff_won" in filters:
        filters["plaintiff_won"] = filters["plaintiff_won"].lower() == "true"

    cases = case_law_service.get_all_cases(filters=filters if filters else None)
    return jsonify({"success": True, "cases": cases, "count": len(cases)})


@app.route("/api/case-law/<int:case_id>", methods=["GET"])
@require_staff()
def api_get_case_law_detail(case_id):
    """Get case details by ID"""
    case = case_law_service.get_case_by_id(case_id)
    if not case:
        return jsonify({"success": False, "error": "Case not found"}), 404
    return jsonify({"success": True, "case": case})


@app.route("/api/case-law", methods=["POST"])
@require_staff(roles=["admin"])
def api_create_case_law():
    """Create a new case law citation (admin only)"""
    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    required = ["case_name", "citation"]
    for field in required:
        if not data.get(field):
            return jsonify({"success": False, "error": f"{field} is required"}), 400

    try:
        case = case_law_service.create_case(data)
        return jsonify({"success": True, "case": case})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/case-law/<int:case_id>", methods=["PUT"])
@require_staff(roles=["admin"])
def api_update_case_law(case_id):
    """Update an existing case (admin only)"""
    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    try:
        case = case_law_service.update_case(case_id, data)
        if not case:
            return jsonify({"success": False, "error": "Case not found"}), 404
        return jsonify({"success": True, "case": case})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/case-law/<int:case_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_delete_case_law(case_id):
    """Delete a case (admin only)"""
    try:
        success = case_law_service.delete_case(case_id)
        if not success:
            return jsonify({"success": False, "error": "Case not found"}), 404
        return jsonify({"success": True, "message": "Case deleted"})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/case-law/search", methods=["GET"])
@require_staff()
def api_search_case_law():
    """Full-text search by keywords"""
    query = request.args.get("q", "").strip()
    if not query:
        return (
            jsonify({"success": False, "error": "Query parameter q is required"}),
            400,
        )

    results = case_law_service.search_cases(query)
    return jsonify({"success": True, "results": results, "count": len(results)})


@app.route("/api/case-law/suggest/<violation_type>", methods=["GET"])
@require_staff()
def api_suggest_case_law(violation_type):
    """Get suggested citations for a violation type"""
    cases = case_law_service.get_citations_for_violation(violation_type)
    return jsonify({"success": True, "cases": cases, "count": len(cases)})


@app.route("/api/case-law/by-section/<section>", methods=["GET"])
@require_staff()
def api_case_law_by_section(section):
    """Get cases for a specific FCRA section"""
    cases = case_law_service.get_citations_for_fcra_section(section)
    return jsonify({"success": True, "cases": cases, "count": len(cases)})


@app.route("/api/case-law/format/<int:case_id>", methods=["GET"])
@require_staff()
def api_format_citation(case_id):
    """Format a citation for letter insertion"""
    format_type = request.args.get("format", "short")
    formatted = case_law_service.format_citation_for_letter(case_id, format_type)
    if not formatted:
        return jsonify({"success": False, "error": "Case not found"}), 404
    return jsonify({"success": True, "formatted_citation": formatted})


@app.route("/api/case-law/suggest-for-analysis/<int:analysis_id>", methods=["GET"])
@require_staff()
def api_suggest_for_analysis(analysis_id):
    """Suggest citations based on analysis violations"""
    suggestions = case_law_service.suggest_citations_for_analysis(analysis_id)
    return jsonify(
        {"success": True, "suggestions": suggestions, "count": len(suggestions)}
    )


@app.route("/api/case-law/populate", methods=["POST"])
@require_staff(roles=["admin"])
def api_populate_case_law():
    """Populate database with default FCRA cases (admin only)"""
    result = case_law_service.populate_default_cases()
    if result["status"] == "error":
        return jsonify({"success": False, "error": result["message"]}), 500
    return jsonify({"success": True, **result})


# ============================================================================
# POWER FEATURES: INSTANT VIOLATION PREVIEW (Lead Generation)
# ============================================================================


@app.route("/preview")
def instant_preview_page():
    """Public landing page for instant credit report violation preview"""
    return render_template("instant_preview.html")


PREVIEW_RATE_LIMIT: dict[str, tuple[int, float]] = (
    {}
)  # Simple IP-based rate limit: {ip: (count, first_request_time)}
PREVIEW_RATE_MAX = 10  # Max 10 requests per 10 minutes per IP
PREVIEW_RATE_WINDOW = 600  # 10 minutes


@app.route("/api/instant-preview", methods=["POST"])
def api_instant_preview():
    """
    Fast AI-powered credit report preview - designed for lead conversion.
    Returns violation count, estimated value, and top violations in 60 seconds.
    """
    import time

    client_ip = request.headers.get("X-Forwarded-For", request.remote_addr) or "unknown"
    current_time = time.time()

    if client_ip in PREVIEW_RATE_LIMIT:
        count, first_time = PREVIEW_RATE_LIMIT[client_ip]
        if current_time - first_time < PREVIEW_RATE_WINDOW:
            if count >= PREVIEW_RATE_MAX:
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "Rate limit exceeded. Please try again later.",
                        }
                    ),
                    429,
                )
            PREVIEW_RATE_LIMIT[client_ip] = (count + 1, first_time)
        else:
            PREVIEW_RATE_LIMIT[client_ip] = (1, current_time)
    else:
        PREVIEW_RATE_LIMIT[client_ip] = (1, current_time)

    try:
        if "file" not in request.files:
            return jsonify({"success": False, "error": "No file uploaded"}), 400

        file = request.files["file"]
        if not file.filename:
            return jsonify({"success": False, "error": "Empty file"}), 400

        file_ext = (
            file.filename.rsplit(".", 1)[-1].lower() if "." in file.filename else ""
        )

        if file_ext == "pdf":
            try:
                import pdfplumber

                pdf_bytes = io.BytesIO(file.read())
                text_content = ""
                with pdfplumber.open(pdf_bytes) as pdf:
                    for page in pdf.pages[:10]:
                        text_content += page.extract_text() or ""
            except Exception as pdf_err:
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": f"PDF parsing failed: {str(pdf_err)}",
                        }
                    ),
                    400,
                )
        else:
            text_content = file.read().decode("utf-8", errors="ignore")

        if len(text_content) < 100:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Credit report appears empty or too short",
                    }
                ),
                400,
            )

        text_content = text_content[:50000]

        preview_prompt = """You are an FCRA expert analyzing a credit report for potential violations.
        
Analyze this credit report and identify the TOP 5-10 most actionable FCRA violations.
Focus on HIGH-VALUE violations that would be most likely to succeed in litigation.

RETURN ONLY VALID JSON in this exact format:
{
    "violation_count": <total number of violations found>,
    "estimated_value_low": <minimum total statutory damages>,
    "estimated_value_high": <maximum total statutory damages>,
    "case_strength": "Strong" | "Moderate" | "Weak",
    "violations": [
        {
            "type": "<violation type, e.g., 'Inaccurate Balance Reporting'>",
            "bureau": "<Equifax, Experian, or TransUnion>",
            "fcra_section": "<e.g., '¬ß1681e(b)'>",
            "severity": "high" | "medium" | "low",
            "value_min": <min damages for this violation>,
            "value_max": <max damages for this violation>,
            "brief_description": "<1 sentence description>"
        }
    ]
}

Common high-value violations to look for:
- Mixed files (wrong person's info) - ¬ß1681e(b) - $1,000-$5,000 each
- Inaccurate account status - ¬ß1681e(b) - $500-$2,000 each
- Outdated negative information - ¬ß1681c - $500-$1,500 each
- Duplicate accounts - ¬ß1681e(b) - $300-$1,000 each
- Wrong balance/credit limit - ¬ß1681e(b) - $200-$800 each
- Failure to update after dispute - ¬ß1681i - $1,000-$3,000 each

If you cannot identify clear violations, return violation_count: 0 with empty violations array.

CREDIT REPORT TO ANALYZE:
"""

        if client is None:
            return jsonify({"success": False, "error": "AI service unavailable"}), 503

        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2000,
            temperature=0,
            messages=[{"role": "user", "content": preview_prompt + text_content}],
        )

        response_text = response.content[0].text.strip()

        if response_text.startswith("```json"):
            response_text = response_text[7:]
        if response_text.startswith("```"):
            response_text = response_text[3:]
        if response_text.endswith("```"):
            response_text = response_text[:-3]
        response_text = response_text.strip()

        try:
            result = json.loads(response_text)
        except json.JSONDecodeError:
            import re

            json_match = re.search(r"\{[\s\S]*\}", response_text)
            if json_match:
                try:
                    result = json.loads(json_match.group())
                except json.JSONDecodeError:
                    result = {
                        "violation_count": 0,
                        "estimated_value_low": 0,
                        "estimated_value_high": 0,
                        "case_strength": "Unknown",
                        "violations": [],
                    }
            else:
                result = {
                    "violation_count": 0,
                    "estimated_value_low": 0,
                    "estimated_value_high": 0,
                    "case_strength": "Unknown",
                    "violations": [],
                }

        def sanitize_numeric(val, default=0):
            """Sanitize AI-derived numeric fields - handles $1k, $1,000, etc."""
            if val is None:
                return default
            if isinstance(val, (int, float)):
                return int(val)
            try:
                s = str(val).strip().lower()
                s = s.replace("$", "").replace(",", "").replace(" ", "")
                if "k" in s:
                    s = s.replace("k", "")
                    return int(float(s) * 1000)
                if "m" in s:
                    s = s.replace("m", "")
                    return int(float(s) * 1000000)
                import re

                digits = re.sub(r"[^\d.]", "", s)
                return int(float(digits)) if digits else default
            except (ValueError, TypeError):
                return default

        if not isinstance(result.get("violations"), list):
            result["violations"] = []
        if not isinstance(result.get("violation_count"), (int, float)):
            result["violation_count"] = len(result.get("violations", []))

        val_low = sanitize_numeric(result.get("estimated_value_low"), 0)
        val_high = sanitize_numeric(result.get("estimated_value_high"), 0)
        estimated_avg = (val_low + val_high) // 2

        safe_violations = []
        for v in result.get("violations", [])[:10]:
            if isinstance(v, dict):
                safe_violations.append(
                    {
                        "type": str(v.get("type", "Unknown"))[:100],
                        "bureau": str(v.get("bureau", "Unknown"))[:50],
                        "fcra_section": str(v.get("fcra_section", "N/A"))[:20],
                        "severity": str(v.get("severity", "medium"))[:10],
                        "value_min": sanitize_numeric(v.get("value_min"), 100),
                        "value_max": sanitize_numeric(v.get("value_max"), 1000),
                        "brief_description": str(v.get("brief_description", ""))[:200],
                    }
                )

        return jsonify(
            {
                "success": True,
                "data": {
                    "violation_count": int(result.get("violation_count", 0) or 0),
                    "estimated_value": estimated_avg,
                    "case_strength": str(result.get("case_strength", "Unknown"))[:20],
                    "violations": safe_violations,
                },
            }
        )

    except Exception as e:
        print(f"Instant preview error: {e}")
        import traceback

        traceback.print_exc()
        return (
            jsonify({"success": False, "error": "Analysis failed. Please try again."}),
            500,
        )


# ============================================================================
# POWER FEATURES: AI SETTLEMENT DEMAND LETTER GENERATOR
# ============================================================================


@app.route("/dashboard/generator")
@require_staff()
def dashboard_generator():
    """Redirect to demand generator page"""
    return redirect(url_for("demand_generator_page"))


@app.route("/dashboard/demand-generator")
@require_staff()
def demand_generator_page():
    """Dashboard page for generating AI-powered settlement demand letters"""
    db = get_db()
    try:
        clients = db.query(Client).order_by(Client.created_at.desc()).limit(100).all()
        return render_template("demand_generator.html", clients=clients)
    finally:
        db.close()


@app.route("/api/generate-demand/<int:client_id>", methods=["POST"])
@require_staff()
def api_generate_demand_letter(client_id):
    """Generate AI-powered settlement demand letter for a client"""
    print(f"[Demand Generator] Starting generation for client {client_id}")
    db = get_db()
    try:
        client_rec = db.query(Client).filter_by(id=client_id).first()
        if not client_rec:
            print(f"[Demand Generator] Client {client_id} not found")
            return jsonify({"success": False, "error": "Client not found"}), 404

        print(f"[Demand Generator] Found client: {client_rec.name}")

        analysis = (
            db.query(Analysis)
            .filter_by(client_id=client_id)
            .order_by(Analysis.created_at.desc())
            .first()
        )
        if not analysis:
            print(f"[Demand Generator] No analysis found for client {client_id}")
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "No analysis found for this client. Please run credit report analysis first.",
                    }
                ),
                404,
            )

        print(f"[Demand Generator] Found analysis ID: {analysis.id}")

        violations = db.query(Violation).filter_by(analysis_id=analysis.id).all()
        damages = db.query(Damages).filter_by(analysis_id=analysis.id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis.id).first()

        data = request.json or {}
        demand_target = data.get("target", "bureaus")
        demand_amount = data.get("amount")
        deadline_days = data.get("deadline_days", 30)

        if not demand_amount and damages:
            demand_amount = damages.settlement_target or damages.total_exposure
        elif not demand_amount:
            demand_amount = sum(v.statutory_damages_max or 1000 for v in violations)

        violation_summary = []
        for v in violations:
            violation_summary.append(
                {
                    "bureau": v.bureau,
                    "account": v.account_name,
                    "section": v.fcra_section,
                    "type": v.violation_type,
                    "is_willful": v.is_willful,
                    "damages_max": v.statutory_damages_max,
                }
            )

        demand_prompt = f"""You are an FCRA litigation attorney drafting a formal settlement demand letter.

CLIENT: {client_rec.name}
TARGET: {demand_target.upper()} (Equifax, Experian, TransUnion)
DEMAND AMOUNT: ${demand_amount:,.2f}
RESPONSE DEADLINE: {deadline_days} days

VIOLATIONS IDENTIFIED:
{json.dumps(violation_summary, indent=2)}

DAMAGES CALCULATION:
- Total Statutory Damages: ${damages.statutory_damages_total if damages else 'N/A'}
- Actual Damages: ${damages.actual_damages_total if damages else 'N/A'}
- Punitive Potential: ${damages.punitive_damages_amount if damages else 'N/A'}
- Attorney Fees Estimate: ${(demand_amount * 0.3):.2f}

CASE STRENGTH: {case_score.case_strength if case_score else 'Strong'} (Score: {case_score.total_score if case_score else 'N/A'}/10)

Generate a professional, aggressive but legally sound settlement demand letter that:
1. Opens with clear identification of the claim and demand
2. Summarizes the most egregious violations with FCRA section citations
3. Details the damages calculation methodology
4. Cites relevant case law (Spokeo v. Robins, Safeco v. Burr, etc.)
5. States the settlement demand and deadline clearly
6. Warns of litigation if demand is not met
7. Includes all required legal disclaimers

Format the letter professionally with proper headers, spacing, and signature block.
Use assertive but professional language befitting FCRA consumer protection litigation.
"""

        if client is None:
            print("[Demand Generator] AI client is None - service unavailable")
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "AI service unavailable. Please check API key configuration.",
                    }
                ),
                503,
            )

        print(
            f"[Demand Generator] Calling AI with {len(violation_summary)} violations, demand amount: ${demand_amount}"
        )

        try:
            response = client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=4000,
                temperature=0.3,
                messages=[{"role": "user", "content": demand_prompt}],
            )
            print(
                f"[Demand Generator] AI response received, tokens used: {response.usage.input_tokens + response.usage.output_tokens}"
            )
        except Exception as ai_error:
            print(f"[Demand Generator] AI API error: {ai_error}")
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"AI generation failed: {str(ai_error)}",
                    }
                ),
                500,
            )

        letter_content = response.content[0].text.strip()

        from reportlab.lib.pagesizes import letter
        from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
        from reportlab.lib.units import inch
        from reportlab.platypus import Paragraph, SimpleDocTemplate, Spacer

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"demand_letter_{client_id}_{timestamp}.pdf"
        filepath = f"static/generated_letters/{filename}"

        doc = SimpleDocTemplate(
            filepath,
            pagesize=letter,
            leftMargin=1 * inch,
            rightMargin=1 * inch,
            topMargin=1 * inch,
            bottomMargin=1 * inch,
        )

        styles = getSampleStyleSheet()
        body_style = ParagraphStyle(
            "BodyStyle", parent=styles["Normal"], fontSize=11, leading=14, spaceAfter=12
        )

        story = []
        for paragraph in letter_content.split("\n\n"):
            if paragraph.strip():
                clean_para = paragraph.replace("\n", " ").strip()
                story.append(Paragraph(clean_para, body_style))
                story.append(Spacer(1, 6))

        doc.build(story)

        return jsonify(
            {
                "success": True,
                "letter_content": letter_content,
                "pdf_path": f"/static/generated_letters/{filename}",
                "demand_amount": demand_amount,
                "deadline_days": deadline_days,
                "violation_count": len(violations),
            }
        )

    except Exception as e:
        print(f"Demand letter generation error: {e}")
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================================
# POWER FEATURES: CLIENT ROI DASHBOARD
# ============================================================================


@app.route("/api/client/<int:client_id>/roi-summary")
def api_client_roi_summary(client_id):
    """Get comprehensive ROI summary for client portal display"""
    db = get_db()
    try:
        client_rec = db.query(Client).filter_by(id=client_id).first()
        if not client_rec:
            return jsonify({"success": False, "error": "Client not found"}), 404

        analysis = (
            db.query(Analysis)
            .filter_by(client_id=client_id)
            .order_by(Analysis.created_at.desc())
            .first()
        )
        if not analysis:
            return jsonify(
                {
                    "success": True,
                    "data": {
                        "has_analysis": False,
                        "message": "No analysis available yet",
                    },
                }
            )

        violations = db.query(Violation).filter_by(analysis_id=analysis.id).all()
        damages = db.query(Damages).filter_by(analysis_id=analysis.id).first()
        case_score = db.query(CaseScore).filter_by(analysis_id=analysis.id).first()

        triage = (
            db.query(CaseTriage)
            .filter_by(client_id=client_id)
            .order_by(CaseTriage.created_at.desc())
            .first()
        )

        cra_responses = db.query(CRAResponse).filter_by(client_id=client_id).all()
        items_deleted = sum(r.items_deleted or 0 for r in cra_responses)
        items_verified = sum(r.items_verified or 0 for r in cra_responses)

        violation_breakdown = {
            "high_value": len(
                [
                    v
                    for v in violations
                    if v.statutory_damages_max and v.statutory_damages_max >= 1000
                ]
            ),
            "medium_value": len(
                [
                    v
                    for v in violations
                    if v.statutory_damages_max and 500 <= v.statutory_damages_max < 1000
                ]
            ),
            "low_value": len(
                [
                    v
                    for v in violations
                    if not v.statutory_damages_max or v.statutory_damages_max < 500
                ]
            ),
            "willful": len([v for v in violations if v.is_willful]),
        }

        avg_fcra_settlement = 7500

        try:
            total_exposure = 0
            if damages and damages.total_exposure is not None:
                total_exposure = (
                    int(damages.total_exposure) if damages.total_exposure else 5000
                )
            elif violations:
                total_exposure = sum(
                    (int(v.statutory_damages_max or 500)) for v in violations
                )
            else:
                total_exposure = 5000
            total_exposure = max(total_exposure, 1000)  # Minimum floor

            if damages and damages.settlement_target is not None:
                settlement_target = (
                    int(damages.settlement_target)
                    if damages.settlement_target
                    else 3000
                )
            else:
                settlement_target = max(int(total_exposure * 0.6), 1000)
            settlement_target = max(settlement_target, 500)  # Minimum floor

            conservative_estimate = max(int(settlement_target * 0.4), 500)
            aggressive_estimate = max(int(total_exposure * 1.2), 1000)
        except (ValueError, TypeError):
            total_exposure = 5000
            settlement_target = 3000
            conservative_estimate = 1200
            aggressive_estimate = 6000

        try:
            if case_score and case_score.settlement_probability is not None:
                settlement_probability = float(case_score.settlement_probability)
                if settlement_probability > 1:
                    settlement_probability = settlement_probability / 100
                settlement_probability = max(
                    0.0, min(1.0, settlement_probability)
                )  # Clamp 0-1
            else:
                settlement_probability = 0.6
        except (ValueError, TypeError):
            settlement_probability = 0.6

        expected_value = max(int(settlement_target * settlement_probability), 500)

        dispute_round = 1
        if client_rec.current_dispute_round:
            dispute_round = client_rec.current_dispute_round
        if dispute_round == 1:
            estimated_weeks = "8-12 weeks"
            timeline_stage = "Initial Dispute"
        elif dispute_round == 2:
            estimated_weeks = "6-10 weeks"
            timeline_stage = "MOV Demand"
        elif dispute_round == 3:
            estimated_weeks = "4-8 weeks"
            timeline_stage = "Regulatory Escalation"
        else:
            estimated_weeks = "2-6 weeks"
            timeline_stage = "Pre-Litigation"

        return jsonify(
            {
                "success": True,
                "data": {
                    "has_analysis": True,
                    "client_name": client_rec.name,
                    "analysis_date": analysis.created_at.strftime("%Y-%m-%d"),
                    "dispute_round": dispute_round,
                    "timeline_stage": timeline_stage,
                    "estimated_resolution": estimated_weeks,
                    "violations": {
                        "total": len(violations),
                        "breakdown": violation_breakdown,
                    },
                    "financials": {
                        "total_exposure": (
                            int(total_exposure) if total_exposure else 5000
                        ),
                        "settlement_target": (
                            int(settlement_target) if settlement_target else 3000
                        ),
                        "conservative_estimate": (
                            int(conservative_estimate)
                            if conservative_estimate
                            else 1500
                        ),
                        "aggressive_estimate": (
                            int(aggressive_estimate) if aggressive_estimate else 6000
                        ),
                        "expected_value": (
                            int(expected_value) if expected_value else 2500
                        ),
                        "avg_fcra_settlement": avg_fcra_settlement,
                        "your_case_vs_average": (
                            round((settlement_target / avg_fcra_settlement) * 100)
                            if avg_fcra_settlement > 0
                            else 100
                        ),
                    },
                    "case_metrics": {
                        "case_strength": (
                            case_score.case_strength if case_score else "Unknown"
                        ),
                        "total_score": case_score.total_score if case_score else 0,
                        "settlement_probability": int(settlement_probability * 100),
                        "priority": triage.priority_level if triage else "standard",
                        "star_rating": triage.star_rating if triage else 3,
                    },
                    "progress": {
                        "items_deleted": items_deleted,
                        "items_verified": items_verified,
                        "disputes_sent": len(cra_responses),
                        "success_rate": (
                            round(
                                (items_deleted / (items_deleted + items_verified) * 100)
                            )
                            if (items_deleted + items_verified) > 0
                            else 0
                        ),
                    },
                },
            }
        )

    except Exception as e:
        print(f"ROI summary error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# INTEGRATIONS HUB - API ENDPOINTS
# ============================================================

from services import certified_mail_service, notarization_service, sendcertified_service


@app.route("/dashboard/integrations")
@require_staff()
def integrations_hub():
    """Integrations hub dashboard page"""
    db = get_db()
    try:
        from datetime import timedelta

        from sqlalchemy import func

        from database import (
            CertifiedMailOrder,
            IntegrationConnection,
            IntegrationEvent,
            NotarizationOrder,
        )

        sendcertified_status = sendcertified_service.get_sendcertified_status()
        sendcertified_stats = sendcertified_service.get_mailing_statistics()

        notarize_configured = notarization_service.is_proof_configured()
        notarize_stats = {"total": 0, "completed": 0}
        try:
            notarize_stats["total"] = (
                db.query(func.count(NotarizationOrder.id)).scalar() or 0
            )
            notarize_stats["completed"] = (
                db.query(func.count(NotarizationOrder.id))
                .filter(NotarizationOrder.status == "completed")
                .scalar()
                or 0
            )
        except:
            pass

        creditpull_connection = (
            db.query(IntegrationConnection).filter_by(service_name="creditpull").first()
        )
        creditpull_status = {
            "configured": bool(
                creditpull_connection and creditpull_connection.api_key_encrypted
            ),
            "connected": (
                creditpull_connection.connection_status == "connected"
                if creditpull_connection
                else False
            ),
            "status": (
                creditpull_connection.connection_status
                if creditpull_connection
                else "not_configured"
            ),
        }

        stripe_key = os.environ.get("STRIPE_SECRET_KEY")
        stripe_status = {
            "configured": bool(stripe_key),
            "connected": bool(stripe_key),
            "status": "connected" if stripe_key else "not_configured",
        }
        stripe_stats = {"total_revenue": 0, "transactions": 0}
        try:
            from database import Client

            paid_clients = (
                db.query(Client).filter(Client.payment_status == "paid").count()
            )
            total_revenue = (
                db.query(func.sum(Client.signup_amount))
                .filter(Client.payment_status == "paid")
                .scalar()
                or 0
            )
            stripe_stats["transactions"] = paid_clients
            stripe_stats["total_revenue"] = total_revenue / 100 if total_revenue else 0
        except:
            pass

        integrations = {
            "sendcertified": {
                "configured": sendcertified_status.get("configured", False),
                "connected": sendcertified_status.get("connected", False),
                "status": sendcertified_status.get("status", "not_configured"),
                "stats": sendcertified_stats,
            },
            "notarize": {
                "configured": notarize_configured,
                "connected": notarize_configured,
                "status": "connected" if notarize_configured else "not_configured",
                "stats": notarize_stats,
            },
            "creditpull": {
                "configured": creditpull_status.get("configured", False),
                "connected": creditpull_status.get("connected", False),
                "status": creditpull_status.get("status", "not_configured"),
                "stats": {"total": 0, "this_month": 0},
            },
            "stripe": {
                "configured": stripe_status.get("configured", False),
                "connected": stripe_status.get("connected", False),
                "status": stripe_status.get("status", "not_configured"),
                "stats": stripe_stats,
            },
        }

        active_count = sum(1 for i in integrations.values() if i["connected"])

        thirty_days_ago = datetime.utcnow() - timedelta(days=30)
        mailings_month = (
            db.query(func.count(CertifiedMailOrder.id))
            .filter(CertifiedMailOrder.created_at >= thirty_days_ago)
            .scalar()
            or 0
        )
        notarized_month = 0
        try:
            notarized_month = (
                db.query(func.count(NotarizationOrder.id))
                .filter(
                    NotarizationOrder.created_at >= thirty_days_ago,
                    NotarizationOrder.status == "completed",
                )
                .scalar()
                or 0
            )
        except:
            pass

        stats = {
            "mailings_sent": sendcertified_stats.get("total", 0),
            "mailings_month": mailings_month,
            "docs_notarized": notarize_stats.get("completed", 0),
            "notarized_month": notarized_month,
            "active_integrations": active_count,
            "total_integrations": 4,
            "total_spend": sendcertified_stats.get("total_cost", 0),
        }

        events = []
        try:
            recent_events = (
                db.query(IntegrationEvent)
                .order_by(IntegrationEvent.created_at.desc())
                .limit(20)
                .all()
            )

            for event in recent_events:
                connection = (
                    db.query(IntegrationConnection)
                    .filter_by(id=event.integration_id)
                    .first()
                )

                time_diff = datetime.utcnow() - event.created_at
                if time_diff.days > 0:
                    time_ago = f"{time_diff.days}d ago"
                elif time_diff.seconds > 3600:
                    time_ago = f"{time_diff.seconds // 3600}h ago"
                else:
                    time_ago = f"{time_diff.seconds // 60}m ago"

                events.append(
                    {
                        "title": event.event_type.replace("_", " ").title(),
                        "service": connection.display_name if connection else "Unknown",
                        "details": (
                            event.error_message[:50] if event.error_message else ""
                        ),
                        "success": (
                            event.response_status == 200
                            if event.response_status
                            else not event.error_message
                        ),
                        "error": bool(event.error_message),
                        "time_ago": time_ago,
                    }
                )
        except Exception as e:
            print(f"Error loading integration events: {e}")

        return render_template(
            "integrations_hub.html",
            integrations=integrations,
            stats=stats,
            events=events,
        )

    except Exception as e:
        print(f"Integrations hub error: {e}")
        return render_template(
            "error.html", error="Error loading integrations", message=str(e)
        )
    finally:
        db.close()


@app.route("/api/integrations/status")
@require_staff()
def get_integrations_status():
    """Get status of all integrations"""
    try:
        sendcertified_status = sendcertified_service.get_sendcertified_status()

        notarize_configured = notarization_service.is_proof_configured()

        db = get_db()
        try:
            from database import IntegrationConnection

            creditpull = (
                db.query(IntegrationConnection)
                .filter_by(service_name="creditpull")
                .first()
            )
            creditpull_status = {
                "configured": bool(creditpull and creditpull.api_key_encrypted),
                "connected": (
                    creditpull.connection_status == "connected" if creditpull else False
                ),
                "status": (
                    creditpull.connection_status if creditpull else "not_configured"
                ),
            }
        except:
            creditpull_status = {
                "configured": False,
                "connected": False,
                "status": "not_configured",
            }
        finally:
            db.close()

        stripe_key = os.environ.get("STRIPE_SECRET_KEY")

        return jsonify(
            {
                "success": True,
                "integrations": {
                    "sendcertified": sendcertified_status,
                    "notarize": {
                        "configured": notarize_configured,
                        "connected": notarize_configured,
                        "status": (
                            "connected" if notarize_configured else "not_configured"
                        ),
                    },
                    "creditpull": creditpull_status,
                    "stripe": {
                        "configured": bool(stripe_key),
                        "connected": bool(stripe_key),
                        "status": "connected" if stripe_key else "not_configured",
                    },
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/integrations/<service>/test", methods=["POST"])
@require_staff()
def test_integration_connection(service):
    """Test connection for a specific integration"""
    try:
        if service == "sendcertified":
            svc = sendcertified_service.get_sendcertified_service()
            if not svc.is_configured():
                return jsonify(
                    {
                        "success": True,
                        "configured": False,
                        "connected": False,
                        "error": "API credentials not configured",
                    }
                )

            connected = svc.test_connection()
            return jsonify(
                {
                    "success": True,
                    "configured": True,
                    "connected": connected,
                    "error": None if connected else "Connection test failed",
                }
            )

        elif service == "notarize":
            configured = notarization_service.is_proof_configured()
            return jsonify(
                {
                    "success": True,
                    "configured": configured,
                    "connected": configured,
                    "error": None if configured else "PROOF_API_KEY not configured",
                }
            )

        elif service == "creditpull":
            db = get_db()
            try:
                from database import IntegrationConnection

                connection = (
                    db.query(IntegrationConnection)
                    .filter_by(service_name="creditpull")
                    .first()
                )

                configured = bool(connection and connection.api_key_encrypted)
                return jsonify(
                    {
                        "success": True,
                        "configured": configured,
                        "connected": (
                            connection.connection_status == "connected"
                            if connection
                            else False
                        ),
                        "error": (
                            None if configured else "API credentials not configured"
                        ),
                    }
                )
            finally:
                db.close()

        elif service == "stripe":
            stripe_key = os.environ.get("STRIPE_SECRET_KEY")
            return jsonify(
                {
                    "success": True,
                    "configured": bool(stripe_key),
                    "connected": bool(stripe_key),
                    "error": None if stripe_key else "STRIPE_SECRET_KEY not configured",
                }
            )

        else:
            return (
                jsonify({"success": False, "error": f"Unknown service: {service}"}),
                400,
            )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/integrations/<service>/configure", methods=["POST"])
@require_staff(roles=["admin"])
def configure_integration(service):
    """Configure API credentials for an integration"""
    data = request.get_json() or {}
    api_key = data.get("api_key", "").strip()
    api_secret = data.get("api_secret", "").strip()
    sandbox = data.get("sandbox", True)

    if not api_key:
        return jsonify({"success": False, "error": "API key is required"}), 400

    try:
        if service == "sendcertified":
            result = sendcertified_service.configure_sendcertified(
                api_key=api_key, api_secret=api_secret, sandbox=sandbox
            )
            return jsonify(result)

        elif service == "notarize":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Notarize API key must be set as PROOF_API_KEY environment variable",
                    }
                ),
                400,
            )

        elif service == "creditpull":
            db = get_db()
            try:
                from database import IntegrationConnection
                from services.encryption import encrypt_value

                connection = (
                    db.query(IntegrationConnection)
                    .filter_by(service_name="creditpull")
                    .first()
                )

                if not connection:
                    connection = IntegrationConnection(
                        service_name="creditpull",
                        display_name="Credit Pull Service",
                        is_sandbox=sandbox,
                        connection_status="configured",
                        created_at=datetime.utcnow(),
                    )
                    db.add(connection)

                connection.api_key_encrypted = encrypt_value(api_key)
                if api_secret:
                    connection.api_secret_encrypted = encrypt_value(api_secret)
                connection.is_sandbox = sandbox
                connection.is_active = True
                connection.connection_status = "configured"
                connection.updated_at = datetime.utcnow()

                db.commit()

                return jsonify(
                    {
                        "success": True,
                        "configured": True,
                        "connection_test": False,
                        "error": None,
                    }
                )
            finally:
                db.close()

        elif service == "stripe":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Stripe API key must be set as STRIPE_SECRET_KEY environment variable",
                    }
                ),
                400,
            )

        else:
            return (
                jsonify({"success": False, "error": f"Unknown service: {service}"}),
                400,
            )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/certified-mail/<int:order_id>/tracking")
@require_staff()
def get_certified_mail_tracking(order_id):
    """Get tracking status for a certified mail order"""
    try:
        svc = sendcertified_service.get_sendcertified_service()
        result = svc.get_tracking_status(order_id=order_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/certified-mail/<int:order_id>/receipt")
@require_staff()
def download_certified_mail_receipt(order_id):
    """Download return receipt for a certified mail order"""
    try:
        svc = sendcertified_service.get_sendcertified_service()
        pdf_bytes = svc.download_return_receipt(order_id=order_id)

        if pdf_bytes:
            return send_file(
                io.BytesIO(pdf_bytes),
                mimetype="application/pdf",
                as_attachment=True,
                download_name=f"return_receipt_{order_id}.pdf",
            )
        else:
            return (
                jsonify({"success": False, "error": "Return receipt not available"}),
                404,
            )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ============================================================
# CREDIT PULL API ENDPOINTS
# ============================================================


@app.route("/api/credit-pull/providers")
@require_staff()
def get_credit_pull_providers():
    """Get list of available credit pull providers and their configuration status"""
    try:
        service = credit_pull_service.get_credit_pull_service()
        providers = service.get_available_providers()
        return jsonify({"success": True, "providers": providers})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/credit-pull/request/<int:client_id>", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def request_credit_pull(client_id):
    """Request a credit report pull for a client"""
    data = request.get_json() or {}
    ssn_last4 = data.get("ssn_last4", "").strip()
    dob = data.get("dob", "").strip()
    full_ssn_encrypted = data.get("full_ssn_encrypted")
    provider = data.get("provider", "smartcredit")
    sandbox = data.get("sandbox", True)

    if not ssn_last4 or len(ssn_last4) != 4:
        return (
            jsonify({"success": False, "error": "Valid 4-digit SSN last 4 required"}),
            400,
        )

    if not dob:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Date of birth required (YYYY-MM-DD format)",
                }
            ),
            400,
        )

    try:
        service = credit_pull_service.get_credit_pull_service(
            provider=provider, sandbox=sandbox
        )

        result = service.request_credit_report(
            client_id=client_id,
            ssn_last4=ssn_last4,
            dob=dob,
            full_ssn_encrypted=full_ssn_encrypted,
        )

        return jsonify(result)

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/credit-pull/<int:pull_id>/status")
@require_staff()
def get_credit_pull_status(pull_id):
    """Get the status of a credit pull request"""
    try:
        service = credit_pull_service.get_credit_pull_service()
        result = service.get_report_status(pull_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/credit-pull/<int:pull_id>/report")
@require_staff()
def get_credit_pull_report(pull_id):
    """Get the parsed credit report data"""
    try:
        service = credit_pull_service.get_credit_pull_service()
        result = service.get_parsed_report(pull_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/credit-pull/client/<int:client_id>")
@require_staff()
def get_client_credit_pulls(client_id):
    """Get all credit pull requests for a client"""
    try:
        service = credit_pull_service.get_credit_pull_service()
        pulls = service.get_client_pulls(client_id)
        return jsonify({"success": True, "pulls": pulls, "count": len(pulls)})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/credit-pull/import/<int:pull_id>", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def import_credit_pull_to_analysis(pull_id):
    """Import a completed credit pull into the analysis pipeline"""
    try:
        service = credit_pull_service.get_credit_pull_service()
        result = service.import_to_analysis(pull_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/credit-pull/test-connection", methods=["POST"])
@require_staff(roles=["admin"])
def test_credit_pull_connection():
    """Test connection to the credit pull provider"""
    data = request.get_json() or {}
    provider = data.get("provider", "smartcredit")
    sandbox = data.get("sandbox", True)

    try:
        service = credit_pull_service.get_credit_pull_service(
            provider=provider, sandbox=sandbox
        )

        connected = service.test_connection()

        return jsonify(
            {
                "success": True,
                "provider": provider,
                "configured": service.is_configured,
                "connected": connected,
                "sandbox": sandbox,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ============================================================
# BILLING & SUBSCRIPTION API ENDPOINTS
# ============================================================

from services.stripe_plans_service import stripe_plans_service


@app.route("/dashboard/billing")
@require_staff(roles=["admin"])
def dashboard_billing():
    """Billing management page for admins"""
    try:
        plans = stripe_plans_service.list_plans(active_only=False)
        stats = stripe_plans_service.get_subscription_stats()
        subscriptions = stripe_plans_service.get_active_subscriptions(limit=50)

        return render_template(
            "billing_management.html",
            plans=plans,
            stats=stats,
            subscriptions=subscriptions,
        )
    except Exception as e:
        return (
            render_template(
                "error.html",
                error="Billing Error",
                message=f"Could not load billing data: {str(e)}",
            ),
            500,
        )


@app.route("/api/billing/plans")
@require_staff()
def api_billing_list_plans():
    """List all billing plans"""
    try:
        active_only = request.args.get("active_only", "true").lower() == "true"
        plans = stripe_plans_service.list_plans(active_only=active_only)
        return jsonify({"success": True, "plans": plans})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/plans", methods=["POST"])
@require_staff(roles=["admin"])
def api_billing_create_plan():
    """Create a new billing plan (admin only)"""
    data = request.get_json() or {}

    name = data.get("name", "").strip().lower().replace(" ", "_")
    display_name = data.get("display_name", "").strip()
    price_cents = data.get("price_cents", 0)
    interval = data.get("interval", "month")
    features = data.get("features", [])

    if not name:
        return jsonify({"success": False, "error": "Plan name is required"}), 400

    if price_cents <= 0:
        return jsonify({"success": False, "error": "Price must be greater than 0"}), 400

    try:
        result = stripe_plans_service.create_plan(
            name=name,
            price_cents=int(price_cents),
            interval=interval,
            features=features,
            display_name=display_name or name.replace("_", " ").title(),
        )

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/plans/<int:plan_id>", methods=["PUT"])
@require_staff(roles=["admin"])
def api_billing_update_plan(plan_id):
    """Update a billing plan (admin only)"""
    data = request.get_json() or {}

    try:
        result = stripe_plans_service.update_plan(plan_id, **data)
        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/plans/initialize", methods=["POST"])
@require_staff(roles=["admin"])
def api_billing_initialize_plans():
    """Initialize default billing plans (admin only)"""
    try:
        result = stripe_plans_service.initialize_default_plans()
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/checkout/<int:client_id>", methods=["POST"])
@require_staff()
def api_billing_create_checkout(client_id):
    """Create a Stripe checkout session for a client"""
    data = request.get_json() or {}

    plan_id = data.get("plan_id")
    if not plan_id:
        return jsonify({"success": False, "error": "Plan ID is required"}), 400

    base_url = request.host_url.rstrip("/")
    success_url = data.get(
        "success_url",
        f"{base_url}/dashboard/clients?payment=success&client_id={client_id}",
    )
    cancel_url = data.get(
        "cancel_url",
        f"{base_url}/dashboard/clients?payment=canceled&client_id={client_id}",
    )

    try:
        result = stripe_plans_service.create_checkout_session(
            client_id=client_id,
            plan_id=int(plan_id),
            success_url=success_url,
            cancel_url=cancel_url,
        )

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/portal/<int:client_id>")
@require_staff()
def api_billing_customer_portal(client_id):
    """Create a Stripe customer portal session"""
    base_url = request.host_url.rstrip("/")
    return_url = request.args.get("return_url", f"{base_url}/dashboard/clients")

    try:
        result = stripe_plans_service.create_customer_portal_session(
            client_id=client_id, return_url=return_url
        )

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/webhooks/stripe", methods=["POST"])
def stripe_billing_webhook():
    """Handle Stripe webhook events for billing subscriptions"""
    payload = request.get_data()
    signature = request.headers.get("Stripe-Signature", "")

    try:
        result = stripe_plans_service.handle_webhook(payload, signature)

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    except Exception as e:
        print(f"Stripe billing webhook error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/subscription/<int:client_id>")
@require_staff()
def api_billing_subscription_status(client_id):
    """Get subscription status for a client"""
    try:
        result = stripe_plans_service.get_subscription_status(client_id)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/cancel/<int:client_id>", methods=["POST"])
@require_staff(roles=["admin"])
def api_billing_cancel_subscription(client_id):
    """Cancel a client's subscription (admin only)"""
    data = request.get_json() or {}
    at_period_end = data.get("at_period_end", True)

    try:
        success = stripe_plans_service.cancel_subscription(
            client_id=client_id, at_period_end=at_period_end
        )

        if success:
            return jsonify(
                {
                    "success": True,
                    "message": "Subscription canceled successfully",
                    "at_period_end": at_period_end,
                }
            )
        else:
            return (
                jsonify({"success": False, "error": "Could not cancel subscription"}),
                400,
            )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/stats")
@require_staff(roles=["admin"])
def api_billing_stats():
    """Get billing statistics (admin only)"""
    try:
        stats = stripe_plans_service.get_subscription_stats()
        return jsonify(stats)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/billing/test-connection")
@require_staff(roles=["admin"])
def api_billing_test_connection():
    """Test Stripe connection (admin only)"""
    try:
        connected = stripe_plans_service.test_connection()
        return jsonify({"success": True, "connected": connected})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ============================================================================
# TASK QUEUE & SCHEDULER ROUTES
# ============================================================================


@app.route("/dashboard/tasks")
@require_staff()
def dashboard_tasks():
    """Task queue dashboard"""
    SchedulerService.initialize_built_in_schedules()

    task_stats = TaskQueueService.get_task_stats()
    scheduler_stats = SchedulerService.get_scheduler_stats()
    task_types = TaskQueueService.get_available_task_types()
    cron_presets = COMMON_CRON_EXPRESSIONS

    return render_template(
        "task_queue.html",
        task_stats=task_stats,
        scheduler_stats=scheduler_stats,
        task_types=task_types,
        cron_presets=cron_presets,
        staff=session.get("staff"),
    )


@app.route("/api/tasks", methods=["GET"])
@require_staff()
def api_get_tasks():
    """Get all tasks with optional filtering"""
    status = request.args.get("status")
    task_type = request.args.get("task_type")
    limit = int(request.args.get("limit", 100))
    offset = int(request.args.get("offset", 0))

    try:
        tasks = TaskQueueService.get_tasks(
            status=status, task_type=task_type, limit=limit, offset=offset
        )
        stats = TaskQueueService.get_task_stats()

        return jsonify({"success": True, "tasks": tasks, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/tasks", methods=["POST"])
@require_staff()
def api_create_task():
    """Create a new background task"""
    data = request.get_json()

    if not data or "task_type" not in data:
        return jsonify({"success": False, "error": "task_type is required"}), 400

    try:
        scheduled_at = None
        if data.get("scheduled_at"):
            scheduled_at = datetime.fromisoformat(
                data["scheduled_at"].replace("Z", "+00:00")
            )

        task = TaskQueueService.enqueue_task(
            task_type=data["task_type"],
            payload=data.get("payload", {}),
            priority=data.get("priority", 5),
            scheduled_at=scheduled_at,
            client_id=data.get("client_id"),
            staff_id=session.get("staff", {}).get("id"),
            max_retries=data.get("max_retries", 3),
        )

        return jsonify({"success": True, "task": task.to_dict()})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/tasks/<int:task_id>", methods=["GET"])
@require_staff()
def api_get_task(task_id):
    """Get a specific task status"""
    try:
        task = TaskQueueService.get_task_status(task_id)
        if task:
            return jsonify({"success": True, "task": task})
        return jsonify({"success": False, "error": "Task not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/tasks/<int:task_id>", methods=["DELETE"])
@require_staff()
def api_cancel_task(task_id):
    """Cancel a pending task"""
    try:
        success = TaskQueueService.cancel_task(task_id)
        if success:
            return jsonify({"success": True, "message": "Task cancelled"})
        return (
            jsonify(
                {"success": False, "error": "Task cannot be cancelled (not pending)"}
            ),
            400,
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/tasks/<int:task_id>/retry", methods=["POST"])
@require_staff()
def api_retry_task(task_id):
    """Retry a failed task"""
    try:
        success = TaskQueueService.retry_failed_task(task_id)
        if success:
            return jsonify({"success": True, "message": "Task queued for retry"})
        return (
            jsonify({"success": False, "error": "Task cannot be retried (not failed)"}),
            400,
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/tasks/process", methods=["POST"])
@require_staff(roles=["admin"])
def api_process_tasks():
    """Manually trigger task processing (admin only)"""
    limit = request.get_json().get("limit", 1) if request.get_json() else 1

    try:
        results = TaskQueueService.process_pending_tasks(limit=limit)
        return jsonify({"success": True, "processed": len(results), "results": results})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/tasks/cleanup", methods=["POST"])
@require_staff(roles=["admin"])
def api_cleanup_tasks():
    """Cleanup old tasks (admin only)"""
    data = request.get_json() or {}
    days = data.get("days", 30)

    try:
        deleted = TaskQueueService.cleanup_old_tasks(days=days)
        return jsonify(
            {
                "success": True,
                "deleted": deleted,
                "message": f"Deleted {deleted} tasks older than {days} days",
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/tasks/stats", methods=["GET"])
@require_staff()
def api_task_stats():
    """Get task queue statistics"""
    try:
        stats = TaskQueueService.get_task_stats()
        return jsonify({"success": True, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules", methods=["GET"])
@require_staff()
def api_get_schedules():
    """Get all scheduled jobs"""
    active_only = request.args.get("active_only", "false").lower() == "true"

    try:
        schedules = SchedulerService.get_all_schedules(active_only=active_only)
        stats = SchedulerService.get_scheduler_stats()

        return jsonify({"success": True, "schedules": schedules, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules", methods=["POST"])
@require_staff(roles=["admin", "manager"])
def api_create_schedule():
    """Create a new scheduled job"""
    data = request.get_json()

    if not data:
        return jsonify({"success": False, "error": "Request body required"}), 400

    required = ["name", "task_type", "cron_expression"]
    for field in required:
        if field not in data:
            return jsonify({"success": False, "error": f"{field} is required"}), 400

    try:
        CronParser.parse(data["cron_expression"])
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400

    try:
        job = SchedulerService.create_schedule(
            name=data["name"],
            task_type=data["task_type"],
            payload=data.get("payload", {}),
            cron_expression=data["cron_expression"],
            staff_id=session.get("staff", {}).get("id"),
        )

        return jsonify({"success": True, "schedule": job.to_dict()})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/<int:job_id>", methods=["GET"])
@require_staff()
def api_get_schedule(job_id):
    """Get a specific scheduled job"""
    try:
        schedule = SchedulerService.get_schedule(job_id)
        if schedule:
            return jsonify({"success": True, "schedule": schedule})
        return jsonify({"success": False, "error": "Schedule not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/<int:job_id>", methods=["PUT"])
@require_staff(roles=["admin", "manager"])
def api_update_schedule(job_id):
    """Update a scheduled job"""
    data = request.get_json()

    if not data:
        return jsonify({"success": False, "error": "Request body required"}), 400

    if "cron_expression" in data:
        try:
            CronParser.parse(data["cron_expression"])
        except ValueError as e:
            return jsonify({"success": False, "error": str(e)}), 400

    try:
        job = SchedulerService.update_schedule(job_id, **data)
        if job:
            return jsonify({"success": True, "schedule": job.to_dict()})
        return jsonify({"success": False, "error": "Schedule not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/<int:job_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_delete_schedule(job_id):
    """Delete a scheduled job (admin only)"""
    try:
        success = SchedulerService.delete_schedule(job_id)
        if success:
            return jsonify({"success": True, "message": "Schedule deleted"})
        return jsonify({"success": False, "error": "Schedule not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/<int:job_id>/run", methods=["POST"])
@require_staff()
def api_run_schedule_now(job_id):
    """Manually run a scheduled job now"""
    try:
        result = SchedulerService.run_job_now(job_id)
        if result:
            return jsonify({"success": True, "result": result})
        return jsonify({"success": False, "error": "Schedule not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/<int:job_id>/pause", methods=["POST"])
@require_staff()
def api_pause_schedule(job_id):
    """Pause a scheduled job"""
    try:
        success = SchedulerService.pause_schedule(job_id)
        if success:
            return jsonify({"success": True, "message": "Schedule paused"})
        return jsonify({"success": False, "error": "Schedule not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/<int:job_id>/resume", methods=["POST"])
@require_staff()
def api_resume_schedule(job_id):
    """Resume a paused scheduled job"""
    try:
        success = SchedulerService.resume_schedule(job_id)
        if success:
            return jsonify({"success": True, "message": "Schedule resumed"})
        return jsonify({"success": False, "error": "Schedule not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/run-due", methods=["POST"])
@require_staff(roles=["admin"])
def api_run_due_schedules():
    """Manually run all due schedules (admin only)"""
    try:
        results = SchedulerService.run_due_jobs()
        return jsonify({"success": True, "processed": len(results), "results": results})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/schedules/cron-presets", methods=["GET"])
@require_staff()
def api_get_cron_presets():
    """Get common cron expression presets"""
    return jsonify({"success": True, "presets": COMMON_CRON_EXPRESSIONS})


# ============================================================
# WORKFLOW TRIGGERS ROUTES
# ============================================================


@app.route("/dashboard/workflows")
@require_staff()
def dashboard_workflows():
    """Workflow triggers dashboard"""
    try:
        WorkflowTriggersService.initialize_default_triggers()

        triggers = WorkflowTriggersService.get_all_triggers()
        stats = WorkflowTriggersService.get_trigger_stats()
        recent_executions = WorkflowTriggersService.get_recent_executions(limit=20)

        return render_template(
            "workflow_triggers.html",
            triggers=[t.to_dict() for t in triggers],
            stats=stats,
            recent_executions=recent_executions,
            trigger_types=TRIGGER_TYPES,
            action_types=ACTION_TYPES,
            staff=session.get("staff"),
        )
    except Exception as e:
        print(f"Workflow dashboard error: {e}")
        return render_template(
            "workflow_triggers.html",
            triggers=[],
            stats={},
            recent_executions=[],
            trigger_types=TRIGGER_TYPES,
            action_types=ACTION_TYPES,
            staff=session.get("staff"),
        )


@app.route("/api/workflows", methods=["GET"])
@require_staff()
def api_get_workflows():
    """Get all workflow triggers"""
    try:
        active_only = request.args.get("active_only", "false").lower() == "true"
        triggers = WorkflowTriggersService.get_all_triggers(active_only=active_only)
        stats = WorkflowTriggersService.get_trigger_stats()

        return jsonify(
            {
                "success": True,
                "triggers": [t.to_dict() for t in triggers],
                "stats": stats,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows", methods=["POST"])
@require_staff(roles=["admin", "attorney"])
def api_create_workflow():
    """Create a new workflow trigger"""
    data = request.get_json()

    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    required = ["name", "trigger_type", "actions"]
    for field in required:
        if field not in data:
            return jsonify({"success": False, "error": f"{field} is required"}), 400

    try:
        trigger = WorkflowTriggersService.create_trigger(
            name=data["name"],
            trigger_type=data["trigger_type"],
            conditions=data.get("conditions", {}),
            actions=data["actions"],
            description=data.get("description"),
            priority=data.get("priority", 5),
            staff_id=session.get("staff", {}).get("id"),
        )

        return jsonify({"success": True, "trigger": trigger.to_dict()})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/<int:trigger_id>", methods=["GET"])
@require_staff()
def api_get_workflow(trigger_id):
    """Get a specific workflow trigger"""
    try:
        trigger = WorkflowTriggersService.get_trigger(trigger_id)
        if trigger:
            return jsonify({"success": True, "trigger": trigger.to_dict()})
        return jsonify({"success": False, "error": "Trigger not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/<int:trigger_id>", methods=["PUT"])
@require_staff(roles=["admin", "attorney"])
def api_update_workflow(trigger_id):
    """Update a workflow trigger"""
    data = request.get_json()

    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    try:
        trigger = WorkflowTriggersService.update_trigger(trigger_id, **data)
        if trigger:
            return jsonify({"success": True, "trigger": trigger.to_dict()})
        return jsonify({"success": False, "error": "Trigger not found"}), 404
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/<int:trigger_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_delete_workflow(trigger_id):
    """Delete a workflow trigger (admin only)"""
    try:
        success = WorkflowTriggersService.delete_trigger(trigger_id)
        if success:
            return jsonify({"success": True, "message": "Trigger deleted"})
        return jsonify({"success": False, "error": "Trigger not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/<int:trigger_id>/toggle", methods=["POST"])
@require_staff(roles=["admin", "attorney"])
def api_toggle_workflow(trigger_id):
    """Toggle a workflow trigger's active state"""
    try:
        is_active = WorkflowTriggersService.toggle_trigger(trigger_id)
        if is_active is not None:
            return jsonify(
                {
                    "success": True,
                    "is_active": is_active,
                    "message": f'Trigger {"enabled" if is_active else "disabled"}',
                }
            )
        return jsonify({"success": False, "error": "Trigger not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/<int:trigger_id>/test", methods=["POST"])
@require_staff()
def api_test_workflow(trigger_id):
    """Test a trigger with sample data"""
    data = request.get_json() or {}
    sample_event_data = data.get(
        "event_data",
        {
            "client_id": 1,
            "client_name": "Test Client",
            "email": "test@example.com",
            "phone": "555-0100",
        },
    )

    try:
        result = WorkflowTriggersService.test_trigger(trigger_id, sample_event_data)
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/<int:trigger_id>/history", methods=["GET"])
@require_staff()
def api_get_workflow_history(trigger_id):
    """Get execution history for a trigger"""
    limit = int(request.args.get("limit", 50))

    try:
        history = WorkflowTriggersService.get_trigger_history(trigger_id, limit=limit)
        return jsonify({"success": True, "history": history})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/executions", methods=["GET"])
@require_staff()
def api_get_workflow_executions():
    """Get all recent workflow executions"""
    limit = int(request.args.get("limit", 100))

    try:
        executions = WorkflowTriggersService.get_recent_executions(limit=limit)
        return jsonify({"success": True, "executions": executions})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/stats", methods=["GET"])
@require_staff()
def api_get_workflow_stats():
    """Get workflow trigger statistics"""
    try:
        stats = WorkflowTriggersService.get_trigger_stats()
        return jsonify({"success": True, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/evaluate", methods=["POST"])
@require_staff(roles=["admin", "attorney"])
def api_evaluate_workflows():
    """Manually trigger event evaluation"""
    data = request.get_json()

    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    if "event_type" not in data:
        return jsonify({"success": False, "error": "event_type is required"}), 400

    try:
        results = WorkflowTriggersService.evaluate_triggers(
            event_type=data["event_type"], event_data=data.get("event_data", {})
        )

        return jsonify(
            {"success": True, "triggered_count": len(results), "results": results}
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/workflows/types", methods=["GET"])
@require_staff()
def api_get_workflow_types():
    """Get available trigger and action types"""
    return jsonify(
        {"success": True, "trigger_types": TRIGGER_TYPES, "action_types": ACTION_TYPES}
    )


# ============================================================
# ML INSIGHTS & OUTCOME LEARNING ROUTES
# ============================================================
from services import ml_learning_service, pattern_analyzer_service


@app.route("/dashboard/ml-insights")
@require_staff()
def ml_insights_dashboard():
    """ML Insights Dashboard - Outcome Learning & Pattern Analysis"""
    try:
        learning_stats = ml_learning_service.get_learning_stats()
        success_rates = ml_learning_service.calculate_success_rate()
        settlement_stats = ml_learning_service.get_average_settlement()
        seasonal_trends = pattern_analyzer_service.detect_seasonal_trends()
        winning_strategies = pattern_analyzer_service.identify_winning_strategies()

        return render_template(
            "ml_insights.html",
            learning_stats=learning_stats,
            success_rates=success_rates,
            settlement_stats=settlement_stats,
            seasonal_trends=seasonal_trends,
            winning_strategies=winning_strategies,
        )
    except Exception as e:
        print(f"ML Insights error: {e}")
        return render_template(
            "ml_insights.html",
            learning_stats={},
            success_rates={},
            settlement_stats={},
            seasonal_trends={},
            winning_strategies={},
        )


@app.route("/api/ml/predictions/<int:client_id>")
@require_staff()
def api_ml_predictions(client_id):
    """Get ML predictions for a specific client"""
    try:
        outcome_prediction = ml_learning_service.predict_outcome(client_id)
        settlement_prediction = ml_learning_service.predict_settlement_range(client_id)
        resolution_estimate = ml_learning_service.get_resolution_time_estimate()

        features = ml_learning_service.MLLearningService().generate_prediction_features(
            client_id
        )

        similar_cases = ml_learning_service.get_similar_cases(
            violation_types=features.get("violation_types", []), limit=5
        )

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "predictions": {
                    "outcome": outcome_prediction,
                    "settlement": settlement_prediction,
                    "resolution_time": resolution_estimate,
                },
                "features": features,
                "similar_cases": similar_cases,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/outcomes", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_ml_record_outcome():
    """Record a new case outcome for ML training"""
    data = request.get_json()

    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    if "client_id" not in data:
        return jsonify({"success": False, "error": "client_id is required"}), 400

    if "final_outcome" not in data:
        return jsonify({"success": False, "error": "final_outcome is required"}), 400

    valid_outcomes = ["won", "lost", "settled", "dismissed"]
    if data["final_outcome"] not in valid_outcomes:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f"final_outcome must be one of: {valid_outcomes}",
                }
            ),
            400,
        )

    try:
        result = ml_learning_service.record_outcome(
            client_id=data["client_id"], outcome_data=data
        )
        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/success-rates")
@require_staff()
def api_ml_success_rates():
    """Get success rate analytics with optional filters"""
    filters = {}

    if request.args.get("furnisher_id"):
        filters["furnisher_id"] = int(request.args.get("furnisher_id"))

    if request.args.get("attorney_id"):
        filters["attorney_id"] = int(request.args.get("attorney_id"))

    if request.args.get("date_from"):
        filters["date_from"] = request.args.get("date_from")

    if request.args.get("date_to"):
        filters["date_to"] = request.args.get("date_to")

    try:
        success_rates = ml_learning_service.calculate_success_rate(
            filters if filters else None
        )
        settlement_stats = ml_learning_service.get_average_settlement(
            filters if filters else None
        )

        return jsonify(
            {
                "success": True,
                "filters_applied": filters,
                "success_rates": success_rates,
                "settlement_stats": settlement_stats,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/patterns")
@require_staff()
def api_ml_patterns():
    """Get identified patterns and insights"""
    filters = {}

    if request.args.get("furnisher_id"):
        filters["furnisher_id"] = int(request.args.get("furnisher_id"))

    if request.args.get("pattern_type"):
        filters["pattern_type"] = request.args.get("pattern_type")

    if request.args.get("violation_type"):
        filters["violation_type"] = request.args.get("violation_type")

    try:
        patterns = pattern_analyzer_service.get_pattern_insights(
            filters if filters else None
        )
        seasonal = pattern_analyzer_service.detect_seasonal_trends()
        strategies = pattern_analyzer_service.identify_winning_strategies(
            filters.get("violation_type")
        )

        return jsonify(
            {
                "success": True,
                "filters_applied": filters,
                "patterns": patterns,
                "seasonal_trends": seasonal,
                "winning_strategies": strategies,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/model-stats")
@require_staff()
def api_ml_model_stats():
    """Get ML model performance statistics"""
    try:
        learning_stats = ml_learning_service.get_learning_stats()
        accuracy = ml_learning_service.MLLearningService().update_model_accuracy()

        return jsonify(
            {
                "success": True,
                "learning_stats": learning_stats,
                "accuracy_report": accuracy,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/furnisher-analysis/<int:furnisher_id>")
@require_staff()
def api_ml_furnisher_analysis(furnisher_id):
    """Get detailed analysis for a specific furnisher"""
    try:
        analysis = pattern_analyzer_service.analyze_furnisher_behavior(
            furnisher_id=furnisher_id
        )
        return jsonify({"success": True, "analysis": analysis})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/attorney-performance")
@require_staff()
def api_ml_attorney_performance():
    """Get attorney performance analysis"""
    try:
        performance = pattern_analyzer_service.find_attorney_strengths()
        return jsonify({"success": True, "performance": performance})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/similar-cases")
@require_staff()
def api_ml_similar_cases():
    """Find similar historical cases"""
    violation_types = request.args.getlist("violation_types")
    furnisher_id = request.args.get("furnisher_id", type=int)
    limit = request.args.get("limit", 10, type=int)

    try:
        similar = ml_learning_service.get_similar_cases(
            violation_types=violation_types if violation_types else None,
            furnisher_id=furnisher_id,
            limit=min(limit, 50),
        )
        return jsonify(
            {"success": True, "similar_cases": similar, "count": len(similar)}
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/ml/refresh-patterns", methods=["POST"])
@require_staff(roles=["admin"])
def api_ml_refresh_patterns():
    """Refresh all pattern analysis (admin only)"""
    try:
        service = pattern_analyzer_service.PatternAnalyzerService()
        result = service.refresh_all_patterns()
        return jsonify({"success": True, "result": result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ============================================================
# WHITE-LABEL MANAGEMENT ROUTES
# ============================================================


@app.route("/dashboard/white-label")
@require_staff(roles=["admin"])
def dashboard_white_label():
    """White-label management dashboard - admin only"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        tenants = service.get_all_tenants(include_inactive=True)

        tenant_stats = []
        for tenant in tenants:
            stats = service.get_tenant_usage_stats(tenant.id)
            tenant_stats.append({"tenant": tenant.to_dict(), "stats": stats})

        staff_members = (
            db.query(Staff).filter_by(is_active=True).order_by(Staff.first_name).all()
        )

        return render_template(
            "white_label_dashboard.html",
            tenants=tenants,
            tenant_stats=tenant_stats,
            staff_members=staff_members,
            subscription_tiers=SUBSCRIPTION_TIERS,
            message=request.args.get("message"),
            error=request.args.get("error"),
        )
    except Exception as e:
        print(f"White-label dashboard error: {e}")
        return (
            render_template("error.html", error="Dashboard Error", message=str(e)),
            500,
        )
    finally:
        db.close()


@app.route("/api/tenants", methods=["GET"])
@require_staff(roles=["admin"])
def api_tenants_list():
    """List all tenants"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        include_inactive = (
            request.args.get("include_inactive", "false").lower() == "true"
        )
        tenants = service.get_all_tenants(include_inactive=include_inactive)

        return jsonify(
            {
                "success": True,
                "tenants": [t.to_dict() for t in tenants],
                "count": len(tenants),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants", methods=["POST"])
@require_staff(roles=["admin"])
def api_tenants_create():
    """Create a new tenant"""
    db = get_db()
    try:
        data = request.get_json() or request.form.to_dict()

        name = data.get("name")
        slug = data.get("slug")

        if not name or not slug:
            return (
                jsonify({"success": False, "error": "Name and slug are required"}),
                400,
            )

        import re

        if not re.match(r"^[a-z0-9-]+$", slug):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Slug must contain only lowercase letters, numbers, and hyphens",
                    }
                ),
                400,
            )

        settings = {
            "domain": data.get("domain"),
            "logo_url": data.get("logo_url"),
            "favicon_url": data.get("favicon_url"),
            "primary_color": data.get("primary_color", "#319795"),
            "secondary_color": data.get("secondary_color", "#1a1a2e"),
            "accent_color": data.get("accent_color", "#84cc16"),
            "company_name": data.get("company_name", name),
            "company_address": data.get("company_address"),
            "company_phone": data.get("company_phone"),
            "company_email": data.get("company_email"),
            "support_email": data.get("support_email"),
            "terms_url": data.get("terms_url"),
            "privacy_url": data.get("privacy_url"),
            "custom_css": data.get("custom_css"),
            "custom_js": data.get("custom_js"),
            "is_active": data.get("is_active", True),
            "subscription_tier": data.get("subscription_tier", "basic"),
            "max_users": int(data.get("max_users", 5)),
            "max_clients": int(data.get("max_clients", 100)),
            "webhook_url": data.get("webhook_url"),
        }

        if data.get("features_enabled"):
            if isinstance(data["features_enabled"], str):
                settings["features_enabled"] = json.loads(data["features_enabled"])
            else:
                settings["features_enabled"] = data["features_enabled"]

        service = get_white_label_service(db)
        tenant = service.create_tenant(name, slug, settings)

        return jsonify(
            {
                "success": True,
                "tenant": tenant.to_dict(),
                "message": f'Tenant "{name}" created successfully',
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>", methods=["GET"])
@require_staff(roles=["admin"])
def api_tenants_get(tenant_id):
    """Get a specific tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        tenant = service.get_tenant_by_id(tenant_id)

        if not tenant:
            return jsonify({"success": False, "error": "Tenant not found"}), 404

        stats = service.get_tenant_usage_stats(tenant_id)
        users = [tu.to_dict() for tu in service.get_tenant_users(tenant_id)]

        return jsonify(
            {
                "success": True,
                "tenant": tenant.to_dict(),
                "stats": stats,
                "users": users,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>", methods=["PUT"])
@require_staff(roles=["admin"])
def api_tenants_update(tenant_id):
    """Update a tenant"""
    db = get_db()
    try:
        data = request.get_json() or request.form.to_dict()

        if "slug" in data:
            import re

            if not re.match(r"^[a-z0-9-]+$", data["slug"]):
                return (
                    jsonify(
                        {
                            "success": False,
                            "error": "Slug must contain only lowercase letters, numbers, and hyphens",
                        }
                    ),
                    400,
                )

        if "features_enabled" in data and isinstance(data["features_enabled"], str):
            data["features_enabled"] = json.loads(data["features_enabled"])

        if "max_users" in data:
            data["max_users"] = int(data["max_users"])
        if "max_clients" in data:
            data["max_clients"] = int(data["max_clients"])
        if "is_active" in data and isinstance(data["is_active"], str):
            data["is_active"] = data["is_active"].lower() == "true"

        service = get_white_label_service(db)
        tenant = service.update_tenant(tenant_id, **data)

        if not tenant:
            return jsonify({"success": False, "error": "Tenant not found"}), 404

        return jsonify(
            {
                "success": True,
                "tenant": tenant.to_dict(),
                "message": "Tenant updated successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_tenants_delete(tenant_id):
    """Delete a tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        success = service.delete_tenant(tenant_id)

        if not success:
            return jsonify({"success": False, "error": "Tenant not found"}), 404

        return jsonify({"success": True, "message": "Tenant deleted successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/users", methods=["GET"])
@require_staff(roles=["admin"])
def api_tenant_users_list(tenant_id):
    """Get users assigned to a tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        users = service.get_tenant_users(tenant_id)

        return jsonify(
            {
                "success": True,
                "users": [u.to_dict() for u in users],
                "count": len(users),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/users", methods=["POST"])
@require_staff(roles=["admin"])
def api_tenant_users_add(tenant_id):
    """Assign a user to a tenant"""
    db = get_db()
    try:
        data = request.get_json() or request.form.to_dict()

        staff_id = data.get("staff_id")
        if not staff_id:
            return jsonify({"success": False, "error": "Staff ID is required"}), 400

        role = data.get("role", "user")
        is_primary_admin = data.get("is_primary_admin", False)
        if isinstance(is_primary_admin, str):
            is_primary_admin = is_primary_admin.lower() == "true"

        service = get_white_label_service(db)
        tenant_user = service.assign_user_to_tenant(
            staff_id=int(staff_id),
            tenant_id=tenant_id,
            role=role,
            is_primary_admin=is_primary_admin,
        )

        return jsonify(
            {
                "success": True,
                "tenant_user": tenant_user.to_dict(),
                "message": "User assigned to tenant successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/users/<int:staff_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_tenant_users_remove(tenant_id, staff_id):
    """Remove a user from a tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        success = service.remove_user_from_tenant(staff_id, tenant_id)

        if not success:
            return jsonify({"success": False, "error": "User not found in tenant"}), 404

        return jsonify(
            {"success": True, "message": "User removed from tenant successfully"}
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/clients", methods=["GET"])
@require_staff(roles=["admin"])
def api_tenant_clients_list(tenant_id):
    """Get clients assigned to a tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        clients = service.get_tenant_clients(tenant_id)

        return jsonify(
            {
                "success": True,
                "clients": [c.to_dict() for c in clients],
                "count": len(clients),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/clients", methods=["POST"])
@require_staff(roles=["admin"])
def api_tenant_clients_add(tenant_id):
    """Assign a client to a tenant"""
    db = get_db()
    try:
        data = request.get_json() or request.form.to_dict()

        client_id = data.get("client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Client ID is required"}), 400

        service = get_white_label_service(db)
        tenant_client = service.assign_client_to_tenant(
            client_id=int(client_id), tenant_id=tenant_id
        )

        return jsonify(
            {
                "success": True,
                "tenant_client": tenant_client.to_dict(),
                "message": "Client assigned to tenant successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/clients/<int:client_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_tenant_clients_remove(tenant_id, client_id):
    """Remove a client from a tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        success = service.remove_client_from_tenant(client_id, tenant_id)

        if not success:
            return (
                jsonify({"success": False, "error": "Client not found in tenant"}),
                404,
            )

        return jsonify(
            {"success": True, "message": "Client removed from tenant successfully"}
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/regenerate-api-key", methods=["POST"])
@require_staff(roles=["admin"])
def api_tenant_regenerate_api_key(tenant_id):
    """Regenerate API key for a tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        new_api_key = service.generate_tenant_api_key(tenant_id)

        return jsonify(
            {
                "success": True,
                "api_key": new_api_key,
                "message": "API key regenerated successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 404
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/tenants/<int:tenant_id>/stats", methods=["GET"])
@require_staff(roles=["admin"])
def api_tenant_stats(tenant_id):
    """Get usage statistics for a tenant"""
    db = get_db()
    try:
        service = get_white_label_service(db)
        stats = service.get_tenant_usage_stats(tenant_id)

        if not stats:
            return jsonify({"success": False, "error": "Tenant not found"}), 404

        return jsonify({"success": True, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/branding", methods=["GET"])
def api_branding():
    """Get current tenant branding (for frontend)"""
    branding = getattr(g, "tenant_branding", None)
    tenant = getattr(g, "tenant", None)

    if not branding:
        branding = {
            "primary_color": "#319795",
            "secondary_color": "#1a1a2e",
            "accent_color": "#84cc16",
            "logo_url": "/static/images/logo.png",
            "favicon_url": None,
            "company_name": "Brightpath Ascend",
            "company_address": None,
            "company_phone": None,
            "company_email": None,
            "support_email": None,
            "terms_url": None,
            "privacy_url": None,
            "custom_css": None,
            "custom_js": None,
        }

    return jsonify(
        {
            "success": True,
            "is_tenant": tenant is not None,
            "tenant_name": tenant.name if tenant else None,
            "tenant_slug": tenant.slug if tenant else None,
            "branding": branding,
        }
    )


# ============================================================
# WHITE-LABEL CONFIG ROUTES (Partner Law Firm Branding)
# ============================================================


@app.route("/dashboard/whitelabel")
@require_staff(roles=["admin"])
def dashboard_whitelabel():
    """White-label configuration management dashboard - admin only"""
    db = get_db()
    try:
        service = get_whitelabel_config_service(db)
        configs = service.get_all_configs(include_inactive=True)

        organizations = (
            db.query(FranchiseOrganization)
            .filter_by(is_active=True)
            .order_by(FranchiseOrganization.name)
            .all()
        )

        return render_template(
            "whitelabel_admin.html",
            configs=configs,
            organizations=organizations,
            font_families=FONT_FAMILIES,
            message=request.args.get("message"),
            error=request.args.get("error"),
        )
    except Exception as e:
        print(f"Whitelabel dashboard error: {e}")
        return (
            render_template("error.html", error="Dashboard Error", message=str(e)),
            500,
        )
    finally:
        db.close()


@app.route("/api/whitelabel", methods=["GET"])
@require_staff(roles=["admin"])
def api_whitelabel_list():
    """List all white-label configurations"""
    db = get_db()
    try:
        service = get_whitelabel_config_service(db)
        include_inactive = (
            request.args.get("include_inactive", "false").lower() == "true"
        )
        configs = service.get_all_configs(include_inactive=include_inactive)

        return jsonify(
            {
                "success": True,
                "configs": [c.to_dict() for c in configs],
                "count": len(configs),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/whitelabel", methods=["POST"])
@require_staff(roles=["admin"])
def api_whitelabel_create():
    """Create a new white-label configuration"""
    db = get_db()
    try:
        data = request.get_json() or request.form.to_dict()

        org_id = data.get("organization_id")
        if org_id:
            org_id = int(org_id)

        required_fields = ["organization_name", "subdomain"]
        for field in required_fields:
            if not data.get(field):
                return jsonify({"success": False, "error": f"{field} is required"}), 400

        service = get_whitelabel_config_service(db)
        config = service.create_config(org_id, data)

        return jsonify(
            {
                "success": True,
                "config": config.to_dict(),
                "message": f'White-label configuration for "{config.organization_name}" created successfully',
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/whitelabel/<int:config_id>", methods=["GET"])
@require_staff(roles=["admin"])
def api_whitelabel_get(config_id):
    """Get a specific white-label configuration"""
    db = get_db()
    try:
        service = get_whitelabel_config_service(db)
        config = service.get_config_by_id(config_id)

        if not config:
            return jsonify({"success": False, "error": "Configuration not found"}), 404

        return jsonify(
            {
                "success": True,
                "config": config.to_dict(),
                "branding": config.get_branding_dict(),
                "css": service.generate_css(config),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/whitelabel/<int:config_id>", methods=["PUT"])
@require_staff(roles=["admin"])
def api_whitelabel_update(config_id):
    """Update a white-label configuration"""
    db = get_db()
    try:
        data = request.get_json() or request.form.to_dict()

        if "organization_id" in data and data["organization_id"]:
            data["organization_id"] = int(data["organization_id"])

        if "is_active" in data and isinstance(data["is_active"], str):
            data["is_active"] = data["is_active"].lower() == "true"

        service = get_whitelabel_config_service(db)
        config = service.update_config(config_id, **data)

        if not config:
            return jsonify({"success": False, "error": "Configuration not found"}), 404

        return jsonify(
            {
                "success": True,
                "config": config.to_dict(),
                "message": "Configuration updated successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/whitelabel/<int:config_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_whitelabel_delete(config_id):
    """Delete a white-label configuration"""
    db = get_db()
    try:
        service = get_whitelabel_config_service(db)
        success = service.delete_config(config_id)

        if not success:
            return jsonify({"success": False, "error": "Configuration not found"}), 404

        return jsonify(
            {"success": True, "message": "Configuration deleted successfully"}
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/whitelabel/<int:config_id>/preview", methods=["POST"])
@require_staff(roles=["admin"])
def api_whitelabel_preview(config_id):
    """Preview branding for a white-label configuration"""
    db = get_db()
    try:
        service = get_whitelabel_config_service(db)
        config = service.get_config_by_id(config_id)

        if not config:
            return jsonify({"success": False, "error": "Configuration not found"}), 404

        preview_data = request.get_json() or {}

        branding = config.get_branding_dict()

        for key, value in preview_data.items():
            if key in branding and value is not None:
                branding[key] = value

        css = service.generate_css(config)

        if preview_data.get("custom_css"):
            css += f"\n/* Preview Custom CSS */\n{preview_data['custom_css']}"

        return jsonify(
            {"success": True, "branding": branding, "css": css, "config_id": config_id}
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/whitelabel/validate-domain", methods=["GET"])
@require_staff(roles=["admin"])
def api_whitelabel_validate_domain():
    """Check if a domain/subdomain is available"""
    domain = request.args.get("domain", "").strip()
    exclude_id = request.args.get("exclude_id")

    if not domain:
        return jsonify({"success": False, "error": "Domain is required"}), 400

    db = get_db()
    try:
        service = get_whitelabel_config_service(db)
        result = service.validate_domain(
            domain, int(exclude_id) if exclude_id else None
        )

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/whitelabel/current", methods=["GET"])
def api_whitelabel_current():
    """Get current white-label branding based on request host"""
    branding = getattr(g, "whitelabel_branding", None)
    config = getattr(g, "whitelabel_config", None)

    if not branding:
        branding = _get_default_whitelabel_branding()

    return jsonify(
        {
            "success": True,
            "is_whitelabel": config is not None,
            "organization_name": branding.get("organization_name"),
            "subdomain": branding.get("subdomain"),
            "branding": branding,
        }
    )


@app.route("/api/tenants/<int:tenant_id>/validate-feature", methods=["GET"])
@require_staff()
def api_tenant_validate_feature(tenant_id):
    """Check if a tenant has access to a specific feature"""
    feature_name = request.args.get("feature")
    if not feature_name:
        return jsonify({"success": False, "error": "Feature name is required"}), 400

    db = get_db()
    try:
        service = get_white_label_service(db)
        has_feature = service.validate_tenant_features(tenant_id, feature_name)

        return jsonify(
            {"success": True, "feature": feature_name, "has_access": has_feature}
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# FRANCHISE MODE MANAGEMENT ROUTES
# ============================================================


def get_franchise_service(db):
    """Get franchise service instance"""
    return FranchiseService(db)


@app.route("/dashboard/franchise")
@require_staff()
def dashboard_franchise():
    """Franchise management dashboard"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role == "admin":
            organizations = service.get_all_organizations(include_inactive=True)
            hierarchy = service.get_organization_hierarchy()
        else:
            organizations = service.get_accessible_organizations(staff_user.id)
            hierarchy = []
            for org in organizations:
                if not org.parent_org_id:
                    hierarchy.extend(service.get_organization_hierarchy(org.id))

        pending_transfers = []
        for org in organizations:
            pending_transfers.extend(
                service.get_pending_transfers(org.id, direction="incoming")
            )

        org_stats = {}
        for org in organizations:
            org_stats[org.id] = service.get_org_stats(org.id)

        staff_members = (
            db.query(Staff).filter_by(is_active=True).order_by(Staff.first_name).all()
        )
        clients = (
            db.query(Client)
            .filter_by(status="active")
            .order_by(Client.name)
            .limit(500)
            .all()
        )

        return render_template(
            "franchise_dashboard.html",
            organizations=organizations,
            hierarchy=hierarchy,
            org_stats=org_stats,
            pending_transfers=pending_transfers,
            staff_members=staff_members,
            clients=clients,
            org_types=FRANCHISE_ORG_TYPES,
            member_roles=FRANCHISE_MEMBER_ROLES,
            message=request.args.get("message"),
            error=request.args.get("error"),
        )
    except Exception as e:
        print(f"Franchise dashboard error: {e}")
        import traceback

        traceback.print_exc()
        return (
            render_template("error.html", error="Dashboard Error", message=str(e)),
            500,
        )
    finally:
        db.close()


@app.route("/api/organizations", methods=["GET"])
@require_staff()
def api_organizations_list():
    """List organizations accessible to the current user"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)
        include_inactive = (
            request.args.get("include_inactive", "false").lower() == "true"
        )

        if staff_user.role == "admin":
            orgs = service.get_all_organizations(include_inactive=include_inactive)
        else:
            orgs = service.get_accessible_organizations(staff_user.id)
            if not include_inactive:
                orgs = [o for o in orgs if o.is_active]

        return jsonify(
            {
                "success": True,
                "organizations": [o.to_dict() for o in orgs],
                "count": len(orgs),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations", methods=["POST"])
@require_staff(roles=["admin", "attorney", "manager"])
def api_organizations_create():
    """Create a new organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)
        data = request.get_json() or request.form.to_dict()

        name = data.get("name")
        org_type = data.get("org_type", "branch")
        parent_org_id = data.get("parent_org_id")

        if not name:
            return (
                jsonify({"success": False, "error": "Organization name is required"}),
                400,
            )

        if parent_org_id:
            parent_org_id = int(parent_org_id)
            if staff_user.role != "admin":
                if not service.check_org_permission(
                    staff_user.id, parent_org_id, "manage_members"
                ):
                    return (
                        jsonify({"success": False, "error": "Permission denied"}),
                        403,
                    )

        org = service.create_organization(
            name=name,
            org_type=org_type,
            parent_org_id=parent_org_id,
            address=data.get("address"),
            city=data.get("city"),
            state=data.get("state"),
            zip_code=data.get("zip_code"),
            phone=data.get("phone"),
            email=data.get("email"),
            manager_staff_id=data.get("manager_staff_id"),
            revenue_share_percent=float(data.get("revenue_share_percent", 0)),
            settings=(
                json.loads(data.get("settings", "{}"))
                if isinstance(data.get("settings"), str)
                else data.get("settings", {})
            ),
        )

        return jsonify(
            {
                "success": True,
                "organization": org.to_dict(),
                "message": f'Organization "{name}" created successfully',
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>", methods=["GET"])
@require_staff()
def api_organizations_get(org_id):
    """Get a specific organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        org = service.get_organization_by_id(org_id)
        if not org:
            return jsonify({"success": False, "error": "Organization not found"}), 404

        if staff_user.role != "admin":
            accessible = service.get_accessible_organizations(staff_user.id)
            if org not in accessible:
                return jsonify({"success": False, "error": "Permission denied"}), 403

        stats = service.get_org_stats(org_id)
        members = [m.to_dict() for m in service.get_organization_members(org_id)]

        return jsonify(
            {
                "success": True,
                "organization": org.to_dict(),
                "stats": stats,
                "members": members,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>", methods=["PUT"])
@require_staff()
def api_organizations_update(org_id):
    """Update an organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "edit_org"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        data = request.get_json() or request.form.to_dict()

        if "settings" in data and isinstance(data["settings"], str):
            data["settings"] = json.loads(data["settings"])
        if "revenue_share_percent" in data:
            data["revenue_share_percent"] = float(data["revenue_share_percent"])

        org = service.update_organization(org_id, **data)
        if not org:
            return jsonify({"success": False, "error": "Organization not found"}), 404

        return jsonify(
            {
                "success": True,
                "organization": org.to_dict(),
                "message": "Organization updated successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_organizations_delete(org_id):
    """Delete (deactivate) an organization"""
    db = get_db()
    try:
        service = get_franchise_service(db)

        success = service.delete_organization(org_id)
        if not success:
            return jsonify({"success": False, "error": "Organization not found"}), 404

        return jsonify(
            {"success": True, "message": "Organization deactivated successfully"}
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/hierarchy", methods=["GET"])
@require_staff()
def api_organizations_hierarchy(org_id):
    """Get organization hierarchy tree"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            accessible = service.get_accessible_organizations(staff_user.id)
            if not any(o.id == org_id for o in accessible):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        hierarchy = service.get_organization_hierarchy(org_id)

        return jsonify({"success": True, "hierarchy": hierarchy})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/members", methods=["GET"])
@require_staff()
def api_organizations_members_list(org_id):
    """List organization members"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "view_org"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        members = service.get_organization_members(org_id)

        return jsonify(
            {
                "success": True,
                "members": [m.to_dict() for m in members],
                "count": len(members),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/members", methods=["POST"])
@require_staff()
def api_organizations_members_add(org_id):
    """Add a member to an organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(
                staff_user.id, org_id, "manage_members"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        data = request.get_json() or request.form.to_dict()
        staff_id = data.get("staff_id")
        role = data.get("role", "staff")
        permissions = data.get("permissions", [])
        is_primary = data.get("is_primary", False)

        if not staff_id:
            return jsonify({"success": False, "error": "Staff ID is required"}), 400

        if isinstance(permissions, str):
            permissions = json.loads(permissions)

        membership = service.add_member(
            org_id=org_id,
            staff_id=int(staff_id),
            role=role,
            permissions=permissions,
            is_primary=bool(is_primary),
        )

        return jsonify(
            {
                "success": True,
                "membership": membership.to_dict(),
                "message": "Member added successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/members/<int:staff_id>", methods=["PUT"])
@require_staff()
def api_organizations_members_update(org_id, staff_id):
    """Update a member's role/permissions"""
    db = get_db()
    try:
        current_staff = g.staff_user
        service = get_franchise_service(db)

        if current_staff.role != "admin":
            if not service.check_org_permission(
                current_staff.id, org_id, "manage_members"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        data = request.get_json() or request.form.to_dict()

        if "permissions" in data and isinstance(data["permissions"], str):
            data["permissions"] = json.loads(data["permissions"])

        membership = service.update_member(org_id, staff_id, **data)
        if not membership:
            return jsonify({"success": False, "error": "Member not found"}), 404

        return jsonify(
            {
                "success": True,
                "membership": membership.to_dict(),
                "message": "Member updated successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/members/<int:staff_id>", methods=["DELETE"])
@require_staff()
def api_organizations_members_remove(org_id, staff_id):
    """Remove a member from an organization"""
    db = get_db()
    try:
        current_staff = g.staff_user
        service = get_franchise_service(db)

        if current_staff.role != "admin":
            if not service.check_org_permission(
                current_staff.id, org_id, "manage_members"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        success = service.remove_member(org_id, staff_id)
        if not success:
            return jsonify({"success": False, "error": "Member not found"}), 404

        return jsonify({"success": True, "message": "Member removed successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/clients", methods=["GET"])
@require_staff()
def api_organizations_clients_list(org_id):
    """List clients assigned to an organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "view_clients"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        include_children = (
            request.args.get("include_children", "false").lower() == "true"
        )
        clients = service.get_organization_clients(
            org_id, include_child_orgs=include_children
        )

        return jsonify(
            {
                "success": True,
                "clients": [c.to_dict() for c in clients],
                "count": len(clients),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/clients", methods=["POST"])
@require_staff()
def api_organizations_clients_assign(org_id):
    """Assign a client to an organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(
                staff_user.id, org_id, "manage_clients"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        data = request.get_json() or request.form.to_dict()
        client_id = data.get("client_id")

        if not client_id:
            return jsonify({"success": False, "error": "Client ID is required"}), 400

        assignment = service.assign_client_to_org(
            client_id=int(client_id), org_id=org_id, assigned_by_staff_id=staff_user.id
        )

        return jsonify(
            {
                "success": True,
                "assignment": assignment.to_dict(),
                "message": "Client assigned successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route(
    "/api/organizations/<int:org_id>/clients/<int:client_id>", methods=["DELETE"]
)
@require_staff()
def api_organizations_clients_unassign(org_id, client_id):
    """Remove a client assignment from an organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(
                staff_user.id, org_id, "manage_clients"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        success = service.unassign_client_from_org(client_id, org_id)
        if not success:
            return (
                jsonify({"success": False, "error": "Client assignment not found"}),
                404,
            )

        return jsonify({"success": True, "message": "Client unassigned successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/transfers", methods=["GET"])
@require_staff()
def api_transfers_list():
    """List client transfers"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        org_id = request.args.get("org_id", type=int)
        status = request.args.get("status")
        direction = request.args.get("direction", "both")

        if status == "pending":
            transfers = service.get_pending_transfers(org_id, direction)
        else:
            transfers = service.get_transfer_history(org_id)

        if staff_user.role != "admin":
            accessible = service.get_accessible_organizations(staff_user.id)
            accessible_ids = [o.id for o in accessible]
            transfers = [
                t
                for t in transfers
                if t.from_org_id in accessible_ids or t.to_org_id in accessible_ids
            ]

        return jsonify(
            {
                "success": True,
                "transfers": [t.to_dict() for t in transfers],
                "count": len(transfers),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/transfers", methods=["POST"])
@require_staff()
def api_transfers_create():
    """Initiate a client transfer"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)
        data = request.get_json() or request.form.to_dict()

        client_id = data.get("client_id")
        from_org_id = data.get("from_org_id")
        to_org_id = data.get("to_org_id")
        reason = data.get("reason", "")
        transfer_type = data.get("transfer_type", "referral")

        if not all([client_id, from_org_id, to_org_id]):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Client ID, from_org_id, and to_org_id are required",
                    }
                ),
                400,
            )

        if staff_user.role != "admin":
            if not service.check_org_permission(
                staff_user.id, int(from_org_id), "manage_clients"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        transfer = service.transfer_client(
            client_id=int(client_id),
            from_org_id=int(from_org_id),
            to_org_id=int(to_org_id),
            reason=reason,
            transferred_by_staff_id=staff_user.id,
            transfer_type=transfer_type,
        )

        return jsonify(
            {
                "success": True,
                "transfer": transfer.to_dict(),
                "message": "Transfer request created successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/transfers/<int:transfer_id>/approve", methods=["POST"])
@require_staff()
def api_transfers_approve(transfer_id):
    """Approve or reject a transfer"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)
        data = request.get_json() or request.form.to_dict()

        approve = data.get("approve", True)
        if isinstance(approve, str):
            approve = approve.lower() in ["true", "1", "yes"]

        transfer = db.query(InterOrgTransfer).filter_by(id=transfer_id).first()
        if not transfer:
            return jsonify({"success": False, "error": "Transfer not found"}), 404

        if staff_user.role != "admin":
            if not service.check_org_permission(
                staff_user.id, transfer.to_org_id, "approve_transfers"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        transfer = service.approve_transfer(
            transfer_id=transfer_id, approved_by_staff_id=staff_user.id, approve=approve
        )

        action = "approved" if approve else "rejected"
        return jsonify(
            {
                "success": True,
                "transfer": transfer.to_dict(),
                "message": f"Transfer {action} successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/revenue", methods=["GET"])
@require_staff()
def api_organizations_revenue(org_id):
    """Get revenue report for an organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "view_revenue"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        period = request.args.get("period", "month")
        include_children = (
            request.args.get("include_children", "true").lower() == "true"
        )

        report = service.get_org_revenue_report(org_id, period, include_children)
        revenue_share = service.calculate_revenue_share(org_id, period)

        return jsonify(
            {"success": True, "revenue_report": report, "revenue_share": revenue_share}
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/organizations/<int:org_id>/stats", methods=["GET"])
@require_staff()
def api_organizations_stats(org_id):
    """Get statistics for an organization"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "view_org"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        include_children = (
            request.args.get("include_children", "false").lower() == "true"
        )
        stats = service.get_org_stats(org_id, include_children)

        return jsonify({"success": True, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/user/organizations", methods=["GET"])
@require_staff()
def api_user_organizations():
    """Get organizations the current user belongs to"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        organizations = service.get_user_organizations(staff_user.id)

        return jsonify(
            {
                "success": True,
                "organizations": organizations,
                "count": len(organizations),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# FRANCHISE MODE API ROUTES (Aliases with /api/franchise prefix)
# ============================================================


@app.route("/api/franchise/organizations", methods=["GET"])
@require_staff()
def api_franchise_organizations_list():
    """List all organizations accessible to user - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)
        include_inactive = (
            request.args.get("include_inactive", "false").lower() == "true"
        )

        if staff_user.role == "admin":
            orgs = service.get_all_organizations(include_inactive=include_inactive)
        else:
            orgs = service.get_accessible_organizations(staff_user.id)
            if not include_inactive:
                orgs = [o for o in orgs if o.is_active]

        return jsonify(
            {
                "success": True,
                "organizations": [o.to_dict() for o in orgs],
                "count": len(orgs),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations", methods=["POST"])
@require_staff(roles=["admin", "attorney", "manager"])
def api_franchise_organizations_create():
    """Create new organization - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)
        data = request.get_json() or request.form.to_dict()

        name = data.get("name")
        org_type = data.get("org_type", data.get("type", "branch"))
        parent_org_id = data.get("parent_org_id", data.get("parent_id"))

        if not name:
            return (
                jsonify({"success": False, "error": "Organization name is required"}),
                400,
            )

        if parent_org_id:
            parent_org_id = int(parent_org_id)
            if staff_user.role != "admin":
                if not service.check_org_permission(
                    staff_user.id, parent_org_id, "manage_members"
                ):
                    return (
                        jsonify({"success": False, "error": "Permission denied"}),
                        403,
                    )

        org = service.create_organization(
            name=name,
            org_type=org_type,
            parent_org_id=parent_org_id,
            address=data.get("address"),
            city=data.get("city"),
            state=data.get("state"),
            zip_code=data.get("zip_code"),
            phone=data.get("phone"),
            email=data.get("email"),
            contact_name=data.get("contact_name"),
            license_number=data.get("license_number"),
            max_users=int(data.get("max_users", 10)) if data.get("max_users") else 10,
            max_clients=(
                int(data.get("max_clients", 100)) if data.get("max_clients") else 100
            ),
            subscription_tier=data.get("subscription_tier", "basic"),
            billing_contact_email=data.get("billing_contact_email"),
            manager_staff_id=data.get("manager_staff_id"),
            revenue_share_percent=float(data.get("revenue_share_percent", 0)),
            settings=(
                json.loads(data.get("settings", "{}"))
                if isinstance(data.get("settings"), str)
                else data.get("settings", {})
            ),
        )

        return jsonify(
            {
                "success": True,
                "organization": org.to_dict(),
                "message": f'Organization "{name}" created successfully',
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations/<int:org_id>", methods=["GET"])
@require_staff()
def api_franchise_organizations_get(org_id):
    """Get organization details - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        org = service.get_organization_by_id(org_id)
        if not org:
            return jsonify({"success": False, "error": "Organization not found"}), 404

        if staff_user.role != "admin":
            accessible = service.get_accessible_organizations(staff_user.id)
            if org not in accessible:
                return jsonify({"success": False, "error": "Permission denied"}), 403

        stats = service.get_org_stats(org_id)
        members = [m.to_dict() for m in service.get_organization_members(org_id)]
        limits = service.check_org_limits(org_id)

        return jsonify(
            {
                "success": True,
                "organization": org.to_dict(),
                "stats": stats,
                "members": members,
                "limits": limits,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations/<int:org_id>", methods=["PUT"])
@require_staff()
def api_franchise_organizations_update(org_id):
    """Update organization - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "edit_org"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        data = request.get_json() or request.form.to_dict()

        if "settings" in data and isinstance(data["settings"], str):
            data["settings"] = json.loads(data["settings"])
        if "revenue_share_percent" in data:
            data["revenue_share_percent"] = float(data["revenue_share_percent"])
        if "max_users" in data:
            data["max_users"] = int(data["max_users"])
        if "max_clients" in data:
            data["max_clients"] = int(data["max_clients"])

        org = service.update_organization(org_id, **data)
        if not org:
            return jsonify({"success": False, "error": "Organization not found"}), 404

        return jsonify(
            {
                "success": True,
                "organization": org.to_dict(),
                "message": "Organization updated successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations/<int:org_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_franchise_organizations_delete(org_id):
    """Delete (deactivate) organization - franchise API endpoint"""
    db = get_db()
    try:
        service = get_franchise_service(db)

        success = service.delete_organization(org_id)
        if not success:
            return jsonify({"success": False, "error": "Organization not found"}), 404

        return jsonify(
            {"success": True, "message": "Organization deactivated successfully"}
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations/<int:org_id>/tree", methods=["GET"])
@require_staff()
def api_franchise_organizations_tree(org_id):
    """Get organization hierarchy tree - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            accessible = service.get_accessible_organizations(staff_user.id)
            if not any(o.id == org_id for o in accessible):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        hierarchy = service.get_organization_hierarchy(org_id)
        children = service.get_child_organizations(org_id, recursive=True)

        return jsonify(
            {
                "success": True,
                "hierarchy": hierarchy,
                "children": [c.to_dict() for c in children],
                "children_count": len(children),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations/<int:org_id>/stats", methods=["GET"])
@require_staff()
def api_franchise_organizations_stats(org_id):
    """Get organization statistics - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "view_org"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        include_children = (
            request.args.get("include_children", "false").lower() == "true"
        )
        stats = service.get_org_stats(org_id, include_children)
        limits = service.check_org_limits(org_id)

        return jsonify({"success": True, "stats": stats, "limits": limits})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations/<int:org_id>/members", methods=["POST"])
@require_staff()
def api_franchise_organizations_members_add(org_id):
    """Add member to organization - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(
                staff_user.id, org_id, "manage_members"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        limits = service.check_org_limits(org_id)
        if not limits.get("can_add_users", True):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f'Organization has reached maximum user limit ({limits["users"]["max"]})',
                    }
                ),
                400,
            )

        data = request.get_json() or request.form.to_dict()
        staff_id = data.get("staff_id")
        role = data.get("role", "staff")
        permissions = data.get("permissions", [])
        is_primary = data.get("is_primary", False)

        if not staff_id:
            return jsonify({"success": False, "error": "Staff ID is required"}), 400

        if isinstance(permissions, str):
            permissions = json.loads(permissions)

        membership = service.add_member(
            org_id=org_id,
            staff_id=int(staff_id),
            role=role,
            permissions=permissions,
            is_primary=bool(is_primary),
        )

        return jsonify(
            {
                "success": True,
                "membership": membership.to_dict(),
                "message": "Member added successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route(
    "/api/franchise/organizations/<int:org_id>/members/<int:staff_id>",
    methods=["DELETE"],
)
@require_staff()
def api_franchise_organizations_members_remove(org_id, staff_id):
    """Remove member from organization - franchise API endpoint"""
    db = get_db()
    try:
        current_staff = g.staff_user
        service = get_franchise_service(db)

        if current_staff.role != "admin":
            if not service.check_org_permission(
                current_staff.id, org_id, "manage_members"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        success = service.remove_member(org_id, staff_id)
        if not success:
            return jsonify({"success": False, "error": "Member not found"}), 404

        return jsonify({"success": True, "message": "Member removed successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/clients/transfer", methods=["POST"])
@require_staff()
def api_franchise_clients_transfer():
    """Transfer client between organizations - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)
        data = request.get_json() or request.form.to_dict()

        client_id = data.get("client_id")
        from_org_id = data.get("from_org_id", data.get("from_org"))
        to_org_id = data.get("to_org_id", data.get("to_org"))
        reason = data.get("reason", "")
        transfer_type = data.get("transfer_type", "referral")

        if not all([client_id, from_org_id, to_org_id]):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "client_id, from_org_id, and to_org_id are required",
                    }
                ),
                400,
            )

        if staff_user.role != "admin":
            if not service.check_org_permission(
                staff_user.id, int(from_org_id), "manage_clients"
            ):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        to_limits = service.check_org_limits(int(to_org_id))
        if not to_limits.get("can_add_clients", True):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f'Target organization has reached maximum client limit ({to_limits["clients"]["max"]})',
                    }
                ),
                400,
            )

        transfer = service.transfer_client(
            client_id=int(client_id),
            from_org_id=int(from_org_id),
            to_org_id=int(to_org_id),
            reason=reason,
            transferred_by_staff_id=staff_user.id,
            transfer_type=transfer_type,
        )

        return jsonify(
            {
                "success": True,
                "transfer": transfer.to_dict(),
                "message": "Transfer request created successfully",
            }
        )
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route(
    "/api/franchise/organizations/<int:org_id>/consolidated-report", methods=["GET"]
)
@require_staff()
def api_franchise_organizations_consolidated_report(org_id):
    """Get consolidated report for organization and children - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "view_revenue"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        report = service.get_consolidated_report(org_id)

        return jsonify({"success": True, "report": report})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/franchise/organizations/<int:org_id>/limits", methods=["GET"])
@require_staff()
def api_franchise_organizations_limits(org_id):
    """Check organization user/client limits - franchise API endpoint"""
    db = get_db()
    try:
        staff_user = g.staff_user
        service = get_franchise_service(db)

        if staff_user.role != "admin":
            if not service.check_org_permission(staff_user.id, org_id, "view_org"):
                return jsonify({"success": False, "error": "Permission denied"}), 403

        limits = service.check_org_limits(org_id)

        return jsonify({"success": True, "limits": limits})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================
# PUBLIC API v1 ROUTES
# ============================================================


@app.route("/api/v1/auth/validate", methods=["POST"])
@require_api_key()
def api_v1_auth_validate():
    """Validate API key and return key information"""
    api_key = g.api_key
    return jsonify(
        {
            "success": True,
            "valid": True,
            "key_name": api_key.name,
            "key_prefix": api_key.key_prefix,
            "scopes": api_key.scopes or [],
            "rate_limits": {
                "per_minute": api_key.rate_limit_per_minute,
                "per_day": api_key.rate_limit_per_day,
            },
            "expires_at": (
                api_key.expires_at.isoformat() if api_key.expires_at else None
            ),
            "rate_limit_info": g.rate_limit_info,
        }
    )


@app.route("/api/v1/clients", methods=["GET"])
@require_api_key(scopes=["read:clients"])
def api_v1_clients_list():
    """List clients (paginated)"""
    db = get_db()
    try:
        page = request.args.get("page", 1, type=int)
        per_page = min(request.args.get("per_page", 20, type=int), 100)
        status = request.args.get("status")

        query = db.query(Client)

        if status:
            query = query.filter(Client.status == status)

        if g.api_key.tenant_id:
            tenant_clients = db.query(TenantClient.client_id).filter(
                TenantClient.tenant_id == g.api_key.tenant_id
            )
            query = query.filter(Client.id.in_(tenant_clients))

        total = query.count()
        clients = (
            query.order_by(Client.created_at.desc())
            .offset((page - 1) * per_page)
            .limit(per_page)
            .all()
        )

        return jsonify(
            {
                "success": True,
                "clients": [
                    {
                        "id": c.id,
                        "name": c.name,
                        "first_name": c.first_name,
                        "last_name": c.last_name,
                        "email": c.email,
                        "phone": c.phone,
                        "status": c.status,
                        "current_dispute_round": c.current_dispute_round,
                        "dispute_status": c.dispute_status,
                        "created_at": (
                            c.created_at.isoformat() if c.created_at else None
                        ),
                    }
                    for c in clients
                ],
                "pagination": {
                    "page": page,
                    "per_page": per_page,
                    "total": total,
                    "pages": (total + per_page - 1) // per_page,
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/clients/<int:client_id>", methods=["GET"])
@require_api_key(scopes=["read:clients"])
def api_v1_clients_get(client_id):
    """Get client details"""
    db = get_db()
    try:
        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Client not found"}), 404

        return jsonify(
            {
                "success": True,
                "client": {
                    "id": client.id,
                    "name": client.name,
                    "first_name": client.first_name,
                    "last_name": client.last_name,
                    "email": client.email,
                    "phone": client.phone,
                    "address": {
                        "street": client.address_street,
                        "city": client.address_city,
                        "state": client.address_state,
                        "zip": client.address_zip,
                    },
                    "status": client.status,
                    "current_dispute_round": client.current_dispute_round,
                    "dispute_status": client.dispute_status,
                    "round_started_at": (
                        client.round_started_at.isoformat()
                        if client.round_started_at
                        else None
                    ),
                    "created_at": (
                        client.created_at.isoformat() if client.created_at else None
                    ),
                    "updated_at": (
                        client.updated_at.isoformat() if client.updated_at else None
                    ),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/clients", methods=["POST"])
@require_api_key(scopes=["write:clients"])
def api_v1_clients_create():
    """Create a new client"""
    db = get_db()
    try:
        data = request.get_json() or {}

        if not data.get("name") and not (
            data.get("first_name") and data.get("last_name")
        ):
            return jsonify({"success": False, "error": "Name is required"}), 400

        name = (
            data.get("name")
            or f"{data.get('first_name', '')} {data.get('last_name', '')}".strip()
        )

        client = Client(
            name=name,
            first_name=data.get("first_name"),
            last_name=data.get("last_name"),
            email=data.get("email"),
            phone=data.get("phone"),
            address_street=data.get("address_street"),
            address_city=data.get("address_city"),
            address_state=data.get("address_state"),
            address_zip=data.get("address_zip"),
            status="signup",
        )

        db.add(client)
        db.flush()

        if g.api_key.tenant_id:
            tenant_client = TenantClient(
                tenant_id=g.api_key.tenant_id, client_id=client.id
            )
            db.add(tenant_client)

        db.commit()

        service = get_api_access_service(db)
        service.trigger_webhook(
            "client.created",
            {"client_id": client.id, "name": client.name, "email": client.email},
            g.api_key.tenant_id,
        )

        return (
            jsonify(
                {
                    "success": True,
                    "client": {
                        "id": client.id,
                        "name": client.name,
                        "status": client.status,
                    },
                }
            ),
            201,
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/clients/<int:client_id>", methods=["PUT"])
@require_api_key(scopes=["write:clients"])
def api_v1_clients_update(client_id):
    """Update client information"""
    db = get_db()
    try:
        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Client not found"}), 404

        data = request.get_json() or {}

        updatable_fields = [
            "first_name",
            "last_name",
            "email",
            "phone",
            "address_street",
            "address_city",
            "address_state",
            "address_zip",
            "status",
            "admin_notes",
        ]

        for field in updatable_fields:
            if field in data:
                setattr(client, field, data[field])

        if "first_name" in data or "last_name" in data:
            client.name = f"{client.first_name or ''} {client.last_name or ''}".strip()

        client.updated_at = datetime.utcnow()
        db.commit()

        service = get_api_access_service(db)
        service.trigger_webhook(
            "client.updated",
            {"client_id": client.id, "name": client.name},
            g.api_key.tenant_id,
        )

        return jsonify(
            {
                "success": True,
                "client": {
                    "id": client.id,
                    "name": client.name,
                    "status": client.status,
                },
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/cases", methods=["GET"])
@require_api_key(scopes=["read:cases"])
def api_v1_cases_list():
    """List cases (paginated)"""
    db = get_db()
    try:
        page = request.args.get("page", 1, type=int)
        per_page = min(request.args.get("per_page", 20, type=int), 100)
        status = request.args.get("status")
        client_id = request.args.get("client_id", type=int)

        query = db.query(Case)

        if status:
            query = query.filter(Case.status == status)
        if client_id:
            query = query.filter(Case.client_id == client_id)

        if g.api_key.tenant_id:
            tenant_clients = db.query(TenantClient.client_id).filter(
                TenantClient.tenant_id == g.api_key.tenant_id
            )
            query = query.filter(Case.client_id.in_(tenant_clients))

        total = query.count()
        cases = (
            query.order_by(Case.created_at.desc())
            .offset((page - 1) * per_page)
            .limit(per_page)
            .all()
        )

        return jsonify(
            {
                "success": True,
                "cases": [
                    {
                        "id": c.id,
                        "client_id": c.client_id,
                        "case_number": c.case_number,
                        "status": c.status,
                        "pricing_tier": c.pricing_tier,
                        "created_at": (
                            c.created_at.isoformat() if c.created_at else None
                        ),
                    }
                    for c in cases
                ],
                "pagination": {
                    "page": page,
                    "per_page": per_page,
                    "total": total,
                    "pages": (total + per_page - 1) // per_page,
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/cases/<int:case_id>", methods=["GET"])
@require_api_key(scopes=["read:cases"])
def api_v1_cases_get(case_id):
    """Get case details"""
    db = get_db()
    try:
        case = db.query(Case).filter(Case.id == case_id).first()
        if not case:
            return jsonify({"success": False, "error": "Case not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == case.client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Case not found"}), 404

        client = db.query(Client).filter(Client.id == case.client_id).first()

        return jsonify(
            {
                "success": True,
                "case": {
                    "id": case.id,
                    "client_id": case.client_id,
                    "client_name": client.name if client else None,
                    "case_number": case.case_number,
                    "status": case.status,
                    "pricing_tier": case.pricing_tier,
                    "base_fee": case.base_fee,
                    "contingency_percent": case.contingency_percent,
                    "intake_at": case.intake_at.isoformat() if case.intake_at else None,
                    "stage1_completed_at": (
                        case.stage1_completed_at.isoformat()
                        if case.stage1_completed_at
                        else None
                    ),
                    "stage2_completed_at": (
                        case.stage2_completed_at.isoformat()
                        if case.stage2_completed_at
                        else None
                    ),
                    "delivered_at": (
                        case.delivered_at.isoformat() if case.delivered_at else None
                    ),
                    "created_at": (
                        case.created_at.isoformat() if case.created_at else None
                    ),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/cases/<int:case_id>/violations", methods=["GET"])
@require_api_key(scopes=["read:cases"])
def api_v1_cases_violations(case_id):
    """Get violations for a case"""
    db = get_db()
    try:
        case = db.query(Case).filter(Case.id == case_id).first()
        if not case:
            return jsonify({"success": False, "error": "Case not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == case.client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Case not found"}), 404

        violations = (
            db.query(Violation).filter(Violation.client_id == case.client_id).all()
        )

        return jsonify(
            {
                "success": True,
                "violations": [
                    {
                        "id": v.id,
                        "bureau": v.bureau,
                        "account_name": v.account_name,
                        "fcra_section": v.fcra_section,
                        "violation_type": v.violation_type,
                        "description": v.description,
                        "is_willful": v.is_willful,
                        "statutory_damages_min": v.statutory_damages_min,
                        "statutory_damages_max": v.statutory_damages_max,
                        "created_at": (
                            v.created_at.isoformat() if v.created_at else None
                        ),
                    }
                    for v in violations
                ],
                "count": len(violations),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/cases/<int:case_id>/disputes", methods=["GET"])
@require_api_key(scopes=["read:disputes"])
def api_v1_cases_disputes(case_id):
    """Get disputes for a case"""
    db = get_db()
    try:
        case = db.query(Case).filter(Case.id == case_id).first()
        if not case:
            return jsonify({"success": False, "error": "Case not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == case.client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Case not found"}), 404

        disputes = (
            db.query(DisputeItem).filter(DisputeItem.client_id == case.client_id).all()
        )

        return jsonify(
            {
                "success": True,
                "disputes": [
                    {
                        "id": d.id,
                        "account_name": d.account_name,
                        "bureau": d.bureau,
                        "status": d.status,
                        "dispute_round": d.dispute_round,
                        "dispute_reason": d.dispute_reason,
                        "created_at": (
                            d.created_at.isoformat() if d.created_at else None
                        ),
                    }
                    for d in disputes
                ],
                "count": len(disputes),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/disputes", methods=["GET"])
@require_api_key(scopes=["read:disputes"])
def api_v1_disputes_list():
    """List disputes (paginated)"""
    db = get_db()
    try:
        page = request.args.get("page", 1, type=int)
        per_page = min(request.args.get("per_page", 20, type=int), 100)
        client_id = request.args.get("client_id", type=int)
        status = request.args.get("status")
        bureau = request.args.get("bureau")

        query = db.query(DisputeItem)

        if client_id:
            query = query.filter(DisputeItem.client_id == client_id)
        if status:
            query = query.filter(DisputeItem.status == status)
        if bureau:
            query = query.filter(DisputeItem.bureau == bureau)

        if g.api_key.tenant_id:
            tenant_clients = db.query(TenantClient.client_id).filter(
                TenantClient.tenant_id == g.api_key.tenant_id
            )
            query = query.filter(DisputeItem.client_id.in_(tenant_clients))

        total = query.count()
        disputes = (
            query.order_by(DisputeItem.created_at.desc())
            .offset((page - 1) * per_page)
            .limit(per_page)
            .all()
        )

        return jsonify(
            {
                "success": True,
                "disputes": [
                    {
                        "id": d.id,
                        "client_id": d.client_id,
                        "account_name": d.account_name,
                        "bureau": d.bureau,
                        "status": d.status,
                        "dispute_round": d.dispute_round,
                        "dispute_reason": d.dispute_reason,
                        "response_type": d.response_type,
                        "created_at": (
                            d.created_at.isoformat() if d.created_at else None
                        ),
                    }
                    for d in disputes
                ],
                "pagination": {
                    "page": page,
                    "per_page": per_page,
                    "total": total,
                    "pages": (total + per_page - 1) // per_page,
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/violations", methods=["GET"])
@require_api_key(scopes=["read:cases"])
def api_v1_violations_list():
    """List violations (paginated)"""
    db = get_db()
    try:
        page = request.args.get("page", 1, type=int)
        per_page = min(request.args.get("per_page", 20, type=int), 100)
        client_id = request.args.get("client_id", type=int)
        bureau = request.args.get("bureau")
        is_willful = request.args.get("is_willful")

        query = db.query(Violation)

        if client_id:
            query = query.filter(Violation.client_id == client_id)
        if bureau:
            query = query.filter(Violation.bureau == bureau)
        if is_willful is not None:
            query = query.filter(Violation.is_willful == (is_willful.lower() == "true"))

        if g.api_key.tenant_id:
            tenant_clients = db.query(TenantClient.client_id).filter(
                TenantClient.tenant_id == g.api_key.tenant_id
            )
            query = query.filter(Violation.client_id.in_(tenant_clients))

        total = query.count()
        violations = (
            query.order_by(Violation.created_at.desc())
            .offset((page - 1) * per_page)
            .limit(per_page)
            .all()
        )

        return jsonify(
            {
                "success": True,
                "violations": [
                    {
                        "id": v.id,
                        "client_id": v.client_id,
                        "analysis_id": v.analysis_id,
                        "bureau": v.bureau,
                        "account_name": v.account_name,
                        "fcra_section": v.fcra_section,
                        "violation_type": v.violation_type,
                        "description": v.description,
                        "is_willful": v.is_willful,
                        "statutory_damages_min": v.statutory_damages_min,
                        "statutory_damages_max": v.statutory_damages_max,
                        "violation_date": (
                            v.violation_date.isoformat() if v.violation_date else None
                        ),
                        "created_at": (
                            v.created_at.isoformat() if v.created_at else None
                        ),
                    }
                    for v in violations
                ],
                "pagination": {
                    "page": page,
                    "per_page": per_page,
                    "total": total,
                    "pages": (total + per_page - 1) // per_page,
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/disputes", methods=["POST"])
@require_api_key(scopes=["write:disputes"])
def api_v1_disputes_create():
    """Create a new dispute"""
    db = get_db()
    try:
        data = request.get_json() or {}

        required_fields = ["client_id", "account_name", "bureau"]
        missing = [f for f in required_fields if not data.get(f)]
        if missing:
            return (
                jsonify(
                    {"success": False, "error": f"Missing required fields: {missing}"}
                ),
                400,
            )

        client_id = data.get("client_id")

        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Client not found"}), 404

        dispute = DisputeItem(
            client_id=client_id,
            account_name=data.get("account_name"),
            bureau=data.get("bureau"),
            account_number_partial=data.get("account_number"),
            status="pending",
            dispute_round=client.current_dispute_round or 1,
            dispute_reason=data.get("dispute_reason", "Inaccurate information"),
        )

        db.add(dispute)
        db.commit()

        service = get_api_access_service(db)
        service.trigger_webhook(
            "dispute.created",
            {
                "dispute_id": dispute.id,
                "client_id": client_id,
                "account_name": dispute.account_name,
                "bureau": dispute.bureau,
            },
            g.api_key.tenant_id,
        )

        return (
            jsonify(
                {
                    "success": True,
                    "dispute": {
                        "id": dispute.id,
                        "client_id": dispute.client_id,
                        "account_name": dispute.account_name,
                        "bureau": dispute.bureau,
                        "status": dispute.status,
                    },
                }
            ),
            201,
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/disputes/<int:dispute_id>/status", methods=["GET"])
@require_api_key(scopes=["read:disputes"])
def api_v1_disputes_status(dispute_id):
    """Get dispute status"""
    db = get_db()
    try:
        dispute = db.query(DisputeItem).filter(DisputeItem.id == dispute_id).first()
        if not dispute:
            return jsonify({"success": False, "error": "Dispute not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == dispute.client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Dispute not found"}), 404

        return jsonify(
            {
                "success": True,
                "dispute": {
                    "id": dispute.id,
                    "account_name": dispute.account_name,
                    "bureau": dispute.bureau,
                    "status": dispute.status,
                    "dispute_round": dispute.dispute_round,
                    "dispute_reason": dispute.dispute_reason,
                    "response_type": dispute.response_type,
                    "response_date": (
                        dispute.response_date.isoformat()
                        if dispute.response_date
                        else None
                    ),
                    "created_at": (
                        dispute.created_at.isoformat() if dispute.created_at else None
                    ),
                    "updated_at": (
                        dispute.updated_at.isoformat() if dispute.updated_at else None
                    ),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/analyze", methods=["POST"])
@require_api_key(scopes=["analyze:reports"])
def api_v1_analyze():
    """Submit credit report for analysis"""
    db = get_db()
    try:
        data = request.get_json() or {}

        if not data.get("client_id"):
            return jsonify({"success": False, "error": "client_id is required"}), 400

        if not data.get("credit_report_html"):
            return (
                jsonify({"success": False, "error": "credit_report_html is required"}),
                400,
            )

        client_id = data.get("client_id")
        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Client not found"}), 404

        queue_item = AnalysisQueue(
            client_id=client_id,
            credit_provider=data.get("credit_provider", "Unknown"),
            dispute_round=data.get("dispute_round", 1),
            credit_report_html=data.get("credit_report_html"),
            status="queued",
            priority=data.get("priority", 5),
        )

        db.add(queue_item)
        db.commit()

        return (
            jsonify(
                {
                    "success": True,
                    "message": "Analysis queued successfully",
                    "queue_id": queue_item.id,
                    "status": "queued",
                }
            ),
            202,
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/analysis/<int:analysis_id>", methods=["GET"])
@require_api_key(scopes=["analyze:reports"])
def api_v1_analysis_get(analysis_id):
    """Get analysis results"""
    db = get_db()
    try:
        analysis = db.query(Analysis).filter(Analysis.id == analysis_id).first()
        if not analysis:
            return jsonify({"success": False, "error": "Analysis not found"}), 404

        if g.api_key.tenant_id:
            tenant_link = (
                db.query(TenantClient)
                .filter(
                    TenantClient.tenant_id == g.api_key.tenant_id,
                    TenantClient.client_id == analysis.client_id,
                )
                .first()
            )
            if not tenant_link:
                return jsonify({"success": False, "error": "Analysis not found"}), 404

        violations = (
            db.query(Violation).filter(Violation.analysis_id == analysis_id).all()
        )

        return jsonify(
            {
                "success": True,
                "analysis": {
                    "id": analysis.id,
                    "client_id": analysis.client_id,
                    "dispute_round": analysis.dispute_round,
                    "stage": analysis.stage,
                    "created_at": (
                        analysis.created_at.isoformat() if analysis.created_at else None
                    ),
                    "approved_at": (
                        analysis.approved_at.isoformat()
                        if analysis.approved_at
                        else None
                    ),
                },
                "violations": [
                    {
                        "id": v.id,
                        "bureau": v.bureau,
                        "account_name": v.account_name,
                        "fcra_section": v.fcra_section,
                        "violation_type": v.violation_type,
                        "is_willful": v.is_willful,
                    }
                    for v in violations
                ],
                "violation_count": len(violations),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/webhooks", methods=["GET"])
@require_api_key(scopes=["manage:webhooks"])
def api_v1_webhooks_list():
    """List webhooks"""
    service = get_api_access_service()
    webhooks = service.list_webhooks(g.api_key.tenant_id)

    return jsonify({"success": True, "webhooks": webhooks, "count": len(webhooks)})


@app.route("/api/v1/webhooks", methods=["POST"])
@require_api_key(scopes=["manage:webhooks"])
def api_v1_webhooks_create():
    """Create a new webhook"""
    data = request.get_json() or {}

    required_fields = ["name", "url", "events"]
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        return (
            jsonify({"success": False, "error": f"Missing required fields: {missing}"}),
            400,
        )

    service = get_api_access_service()
    result = service.create_webhook(
        name=data.get("name"),
        url=data.get("url"),
        events=data.get("events"),
        tenant_id=g.api_key.tenant_id,
    )

    if result.get("success"):
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/v1/webhooks/<int:webhook_id>", methods=["DELETE"])
@require_api_key(scopes=["manage:webhooks"])
def api_v1_webhooks_delete(webhook_id):
    """Delete a webhook"""
    db = get_db()
    try:
        webhook = db.query(APIWebhook).filter(APIWebhook.id == webhook_id).first()
        if not webhook:
            return jsonify({"success": False, "error": "Webhook not found"}), 404

        if g.api_key.tenant_id and webhook.tenant_id != g.api_key.tenant_id:
            return jsonify({"success": False, "error": "Webhook not found"}), 404

        service = get_api_access_service(db)
        result = service.delete_webhook(webhook_id)

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/v1/docs", methods=["GET"])
def api_v1_docs():
    """Get API documentation (OpenAPI spec)"""
    service = get_api_access_service()
    spec = service.get_api_documentation()
    return jsonify(spec)


@app.route("/api-docs")
@app.route("/dashboard/api-docs")
def api_documentation():
    """API Documentation page"""
    return render_template("api_docs.html")


# ============================================================
# API KEY MANAGEMENT ROUTES (Staff Dashboard)
# ============================================================


@app.route("/dashboard/api-keys")
@require_staff()
def dashboard_api_keys():
    """API key management dashboard"""
    db = get_db()
    try:
        staff_user = db.query(Staff).filter_by(id=session["staff_id"]).first()

        if staff_user.role == "admin":
            api_keys = db.query(APIKey).order_by(APIKey.created_at.desc()).all()
            webhooks = db.query(APIWebhook).order_by(APIWebhook.created_at.desc()).all()
        else:
            api_keys = (
                db.query(APIKey)
                .filter(APIKey.staff_id == session["staff_id"])
                .order_by(APIKey.created_at.desc())
                .all()
            )
            webhooks = []

        stats = {
            "total_keys": len(api_keys),
            "active_keys": sum(1 for k in api_keys if k.is_active),
            "total_webhooks": len(webhooks),
            "active_webhooks": sum(1 for w in webhooks if w.is_active),
        }

        return render_template(
            "api_management.html",
            api_keys=api_keys,
            webhooks=webhooks,
            stats=stats,
            scopes=API_SCOPES,
            webhook_events=WEBHOOK_EVENTS,
        )
    except Exception as e:
        return f"Error: {e}", 500
    finally:
        db.close()


@app.route("/api/keys", methods=["GET"])
@require_staff()
def api_keys_list():
    """List API keys (masked)"""
    db = get_db()
    try:
        staff_user = db.query(Staff).filter_by(id=session["staff_id"]).first()

        if staff_user.role == "admin":
            keys = db.query(APIKey).order_by(APIKey.created_at.desc()).all()
        else:
            keys = (
                db.query(APIKey)
                .filter(APIKey.staff_id == session["staff_id"])
                .order_by(APIKey.created_at.desc())
                .all()
            )

        return jsonify(
            {
                "success": True,
                "api_keys": [k.to_dict() for k in keys],
                "count": len(keys),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/keys", methods=["POST"])
@require_staff()
def api_keys_create():
    """Generate new API key"""
    data = request.get_json() or request.form.to_dict()

    name = data.get("name")
    if not name:
        return jsonify({"success": False, "error": "Key name is required"}), 400

    scopes = data.get("scopes", [])
    if isinstance(scopes, str):
        scopes = [s.strip() for s in scopes.split(",") if s.strip()]

    rate_limit_per_minute = int(data.get("rate_limit_per_minute", 60))
    rate_limit_per_day = int(data.get("rate_limit_per_day", 10000))
    tenant_id = data.get("tenant_id", type=int)
    expires_in_days = data.get("expires_in_days", type=int)

    service = get_api_access_service()
    result = service.generate_api_key(
        name=name,
        staff_id=session["staff_id"],
        scopes=scopes,
        rate_limit_per_minute=rate_limit_per_minute,
        rate_limit_per_day=rate_limit_per_day,
        tenant_id=tenant_id,
        expires_in_days=expires_in_days,
    )

    if result.get("success"):
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/keys/<int:key_id>", methods=["DELETE"])
@require_staff()
def api_keys_revoke(key_id):
    """Revoke an API key"""
    db = get_db()
    try:
        staff_user = db.query(Staff).filter_by(id=session["staff_id"]).first()
        api_key = db.query(APIKey).filter(APIKey.id == key_id).first()

        if not api_key:
            return jsonify({"success": False, "error": "API key not found"}), 404

        if staff_user.role != "admin" and api_key.staff_id != session["staff_id"]:
            return jsonify({"success": False, "error": "Permission denied"}), 403

        service = get_api_access_service(db)
        result = service.revoke_api_key(key_id)

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/keys/<int:key_id>/usage", methods=["GET"])
@require_staff()
def api_keys_usage(key_id):
    """Get API key usage statistics"""
    db = get_db()
    try:
        staff_user = db.query(Staff).filter_by(id=session["staff_id"]).first()
        api_key = db.query(APIKey).filter(APIKey.id == key_id).first()

        if not api_key:
            return jsonify({"success": False, "error": "API key not found"}), 404

        if staff_user.role != "admin" and api_key.staff_id != session["staff_id"]:
            return jsonify({"success": False, "error": "Permission denied"}), 403

        days = request.args.get("days", 30, type=int)

        service = get_api_access_service(db)
        result = service.get_key_usage_stats(key_id, days)

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/keys/<int:key_id>/rotate", methods=["POST"])
@require_staff()
def api_keys_rotate(key_id):
    """Rotate an API key - generates new key, invalidates old"""
    db = get_db()
    try:
        staff_user = db.query(Staff).filter_by(id=session["staff_id"]).first()
        api_key = db.query(APIKey).filter(APIKey.id == key_id).first()

        if not api_key:
            return jsonify({"success": False, "error": "API key not found"}), 404

        if staff_user.role != "admin" and api_key.staff_id != session["staff_id"]:
            return jsonify({"success": False, "error": "Permission denied"}), 403

        service = get_api_access_service(db)
        result = service.rotate_api_key(key_id, session["staff_id"])

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/keys/scopes", methods=["GET"])
def api_keys_scopes():
    """List available API key scopes (public endpoint)"""
    return jsonify({"success": True, "scopes": AVAILABLE_SCOPES})


@app.route("/api/keys/verify", methods=["GET"])
@require_api_key()
def api_keys_verify():
    """
    Verify an API key and return its info.
    Use this to test your API key is working.
    """
    api_key = g.api_key
    return jsonify(
        {
            "success": True,
            "valid": True,
            "key_id": api_key.id,
            "name": api_key.name,
            "scopes": api_key.scopes or [],
            "rate_limits": {
                "per_minute": api_key.rate_limit_per_minute,
                "per_day": api_key.rate_limit_per_day,
                "remaining_minute": g.rate_info.get("minute_remaining", 0),
                "remaining_day": g.rate_info.get("day_remaining", 0),
            },
            "expires_at": (
                api_key.expires_at.isoformat() if api_key.expires_at else None
            ),
            "usage_count": api_key.usage_count,
        }
    )


# ============================================================
# WEBHOOK MANAGEMENT ROUTES (Staff Dashboard)
# ============================================================


@app.route("/api/webhooks", methods=["GET"])
@require_staff(roles=["admin"])
def admin_webhooks_list():
    """List all webhooks (admin only)"""
    service = get_api_access_service()
    webhooks = service.list_webhooks()

    return jsonify({"success": True, "webhooks": webhooks, "count": len(webhooks)})


@app.route("/api/webhooks", methods=["POST"])
@require_staff(roles=["admin"])
def admin_webhooks_create():
    """Create a webhook (admin only)"""
    data = request.get_json() or request.form.to_dict()

    required_fields = ["name", "url", "events"]
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        return (
            jsonify({"success": False, "error": f"Missing required fields: {missing}"}),
            400,
        )

    events = data.get("events", [])
    if isinstance(events, str):
        events = [e.strip() for e in events.split(",") if e.strip()]

    tenant_id = data.get("tenant_id", type=int)

    service = get_api_access_service()
    result = service.create_webhook(
        name=data.get("name"), url=data.get("url"), events=events, tenant_id=tenant_id
    )

    if result.get("success"):
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/webhooks/<int:webhook_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def admin_webhooks_delete(webhook_id):
    """Delete a webhook (admin only)"""
    service = get_api_access_service()
    result = service.delete_webhook(webhook_id)

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 404


# ============================================================
# AUDIT LOGGING ROUTES
# ============================================================


@app.route("/dashboard/audit")
@require_staff(roles=["admin"])
def dashboard_audit():
    """Audit log dashboard - admin only"""
    db = get_db()
    try:
        audit_service = get_audit_service(db)
        stats = audit_service.get_statistics(days=30)

        return render_template(
            "audit_dashboard.html",
            stats=stats,
            event_types=AUDIT_EVENT_TYPES,
            resource_types=AUDIT_RESOURCE_TYPES,
        )
    except Exception as e:
        print(f"Audit dashboard error: {e}")
        return f"Error loading audit dashboard: {e}", 500
    finally:
        db.close()


@app.route("/api/audit/logs", methods=["GET"])
@require_staff(roles=["admin"])
def api_audit_logs():
    """Get filtered audit logs with pagination"""
    try:
        event_type = request.args.get("event_type")
        resource_type = request.args.get("resource_type")
        user_type = request.args.get("user_type")
        severity = request.args.get("severity")
        search = request.args.get("search")
        page = request.args.get("page", 1, type=int)
        per_page = request.args.get("per_page", 50, type=int)

        start_date = None
        end_date = None

        if request.args.get("start_date"):
            try:
                start_date = datetime.fromisoformat(
                    request.args.get("start_date").replace("Z", "+00:00")
                )
            except:
                start_date = datetime.strptime(
                    request.args.get("start_date"), "%Y-%m-%d"
                )

        if request.args.get("end_date"):
            try:
                end_date = datetime.fromisoformat(
                    request.args.get("end_date").replace("Z", "+00:00")
                )
            except:
                end_date = datetime.strptime(request.args.get("end_date"), "%Y-%m-%d")
                end_date = end_date.replace(hour=23, minute=59, second=59)

        audit_service = get_audit_service()
        logs, total = audit_service.get_logs(
            event_type=event_type,
            resource_type=resource_type,
            user_type=user_type,
            severity=severity,
            start_date=start_date,
            end_date=end_date,
            search_query=search,
            page=page,
            per_page=per_page,
        )

        return jsonify(
            {
                "success": True,
                "logs": logs,
                "total": total,
                "page": page,
                "per_page": per_page,
                "pages": (total + per_page - 1) // per_page,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/user/<int:user_id>/activity", methods=["GET"])
@require_staff(roles=["admin"])
def api_audit_user_activity(user_id):
    """Get activity report for a specific user"""
    try:
        user_type = request.args.get("user_type")
        days = request.args.get("days", 30, type=int)

        start_date = datetime.utcnow() - timedelta(days=days)
        end_date = datetime.utcnow()

        if request.args.get("start_date"):
            try:
                start_date = datetime.fromisoformat(
                    request.args.get("start_date").replace("Z", "+00:00")
                )
            except:
                start_date = datetime.strptime(
                    request.args.get("start_date"), "%Y-%m-%d"
                )

        if request.args.get("end_date"):
            try:
                end_date = datetime.fromisoformat(
                    request.args.get("end_date").replace("Z", "+00:00")
                )
            except:
                end_date = datetime.strptime(request.args.get("end_date"), "%Y-%m-%d")

        audit_service = get_audit_service()
        activity = audit_service.get_user_activity(
            user_id=user_id,
            user_type=user_type,
            start_date=start_date,
            end_date=end_date,
        )

        return jsonify(
            {
                "success": True,
                "user_id": user_id,
                "activity": activity,
                "count": len(activity),
                "period": {
                    "start": start_date.isoformat(),
                    "end": end_date.isoformat(),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/resource/<resource_type>/<resource_id>/trail", methods=["GET"])
@require_staff(roles=["admin"])
def api_audit_resource_trail(resource_type, resource_id):
    """Get audit trail for a specific resource"""
    try:
        limit = request.args.get("limit", 100, type=int)

        audit_service = get_audit_service()
        trail = audit_service.get_audit_trail(
            resource_type=resource_type, resource_id=resource_id, limit=limit
        )

        return jsonify(
            {
                "success": True,
                "resource_type": resource_type,
                "resource_id": resource_id,
                "trail": trail,
                "count": len(trail),
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/security", methods=["GET"])
@require_staff(roles=["admin"])
def api_audit_security():
    """Get security events report"""
    try:
        days = request.args.get("days", 7, type=int)
        severity = request.args.get("severity")

        start_date = datetime.utcnow() - timedelta(days=days)
        end_date = datetime.utcnow()

        if request.args.get("start_date"):
            try:
                start_date = datetime.fromisoformat(
                    request.args.get("start_date").replace("Z", "+00:00")
                )
            except:
                start_date = datetime.strptime(
                    request.args.get("start_date"), "%Y-%m-%d"
                )

        if request.args.get("end_date"):
            try:
                end_date = datetime.fromisoformat(
                    request.args.get("end_date").replace("Z", "+00:00")
                )
            except:
                end_date = datetime.strptime(request.args.get("end_date"), "%Y-%m-%d")

        audit_service = get_audit_service()
        events = audit_service.get_security_events(
            start_date=start_date, end_date=end_date, severity=severity
        )

        return jsonify(
            {
                "success": True,
                "events": events,
                "count": len(events),
                "period": {
                    "start": start_date.isoformat(),
                    "end": end_date.isoformat(),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/phi", methods=["GET"])
@require_staff(roles=["admin"])
def api_audit_phi():
    """Get PHI access logs for HIPAA compliance"""
    try:
        days = request.args.get("days", 30, type=int)
        user_id = request.args.get("user_id", type=int)

        start_date = datetime.utcnow() - timedelta(days=days)
        end_date = datetime.utcnow()

        audit_service = get_audit_service()
        logs = audit_service.get_phi_access_logs(
            start_date=start_date, end_date=end_date, user_id=user_id
        )

        return jsonify(
            {
                "success": True,
                "phi_access_logs": logs,
                "count": len(logs),
                "period": {
                    "start": start_date.isoformat(),
                    "end": end_date.isoformat(),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/compliance/<report_type>", methods=["GET"])
@require_staff(roles=["admin"])
def api_audit_compliance(report_type):
    """Generate compliance report (SOC 2 or HIPAA)"""
    if report_type not in ["soc2", "hipaa"]:
        return (
            jsonify(
                {"success": False, "error": "Invalid report type. Use soc2 or hipaa"}
            ),
            400,
        )

    try:
        days = request.args.get("days", 30, type=int)

        start_date = datetime.utcnow() - timedelta(days=days)
        end_date = datetime.utcnow()

        if request.args.get("start_date"):
            try:
                start_date = datetime.fromisoformat(
                    request.args.get("start_date").replace("Z", "+00:00")
                )
            except:
                start_date = datetime.strptime(
                    request.args.get("start_date"), "%Y-%m-%d"
                )

        if request.args.get("end_date"):
            try:
                end_date = datetime.fromisoformat(
                    request.args.get("end_date").replace("Z", "+00:00")
                )
            except:
                end_date = datetime.strptime(request.args.get("end_date"), "%Y-%m-%d")

        audit_service = get_audit_service()
        report = audit_service.generate_compliance_report(
            report_type=report_type, start_date=start_date, end_date=end_date
        )

        audit_service.log_event(
            event_type="export",
            resource_type="audit_logs",
            action=f"Generated {report_type.upper()} compliance report",
            details={
                "report_type": report_type,
                "period_start": start_date.isoformat(),
                "period_end": end_date.isoformat(),
            },
        )

        return jsonify({"success": True, "report": report})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/export", methods=["POST"])
@require_staff(roles=["admin"])
def api_audit_export():
    """Export audit logs to CSV or JSON"""
    data = request.get_json() or {}

    export_format = data.get("format", "csv").lower()
    if export_format not in ["csv", "json"]:
        return jsonify({"success": False, "error": "Format must be csv or json"}), 400

    try:
        start_date = None
        end_date = None

        if data.get("start_date"):
            try:
                start_date = datetime.fromisoformat(
                    data.get("start_date").replace("Z", "+00:00")
                )
            except:
                start_date = datetime.strptime(data.get("start_date"), "%Y-%m-%d")

        if data.get("end_date"):
            try:
                end_date = datetime.fromisoformat(
                    data.get("end_date").replace("Z", "+00:00")
                )
            except:
                end_date = datetime.strptime(data.get("end_date"), "%Y-%m-%d")

        audit_service = get_audit_service()
        content, filename = audit_service.export_logs(
            format=export_format,
            start_date=start_date,
            end_date=end_date,
            event_type=data.get("event_type"),
            resource_type=data.get("resource_type"),
        )

        if export_format == "csv":
            output = io.BytesIO(content.encode("utf-8"))
            return send_file(
                output, mimetype="text/csv", as_attachment=True, download_name=filename
            )
        else:
            output = io.BytesIO(content.encode("utf-8"))
            return send_file(
                output,
                mimetype="application/json",
                as_attachment=True,
                download_name=filename,
            )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/statistics", methods=["GET"])
@require_staff(roles=["admin"])
def api_audit_statistics():
    """Get audit log statistics for dashboard"""
    try:
        days = request.args.get("days", 30, type=int)

        audit_service = get_audit_service()
        stats = audit_service.get_statistics(days=days)

        return jsonify({"success": True, "statistics": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/audit/cleanup", methods=["POST"])
@require_staff(roles=["admin"])
def api_audit_cleanup():
    """Clean up old audit logs (GDPR retention compliance)"""
    data = request.get_json() or {}

    retention_days = data.get("retention_days", 365)
    if retention_days < 90:
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Minimum retention period is 90 days for compliance",
                }
            ),
            400,
        )

    try:
        audit_service = get_audit_service()
        deleted_count = audit_service.cleanup_old_logs(retention_days=retention_days)

        return jsonify(
            {
                "success": True,
                "deleted_count": deleted_count,
                "retention_days": retention_days,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ============================================================
# ACTIVITY LOGS ROUTES (Paul's Logging System)
# ============================================================
# "You should be able to skim through yourself without any technical training"


@app.route("/dashboard/logs")
@require_staff(roles=["admin"])
def dashboard_logs():
    """Activity log viewer - see what's happening in real-time"""
    return render_template("logs.html")


@app.route("/api/logs", methods=["GET"])
@require_staff(roles=["admin"])
def api_get_logs():
    """Get activity logs for the dashboard viewer"""
    from services.activity_logger import (
        RECENT_ACTIVITIES,
        get_activities_from_file,
        get_recent_activities,
        read_app_log,
        read_error_log,
    )

    status_filter = request.args.get("status")
    search = request.args.get("search")
    log_type = request.args.get("type", "activity")
    limit = request.args.get("limit", 200, type=int)

    logs = []
    stats = {"success": 0, "error": 0, "warning": 0, "total": 0}

    try:
        if log_type == "activity":
            # Get from memory first, then file
            logs = get_recent_activities(limit=limit, status_filter=status_filter)
            if not logs:
                logs = get_activities_from_file(limit=limit, search=search)

            # Calculate stats from memory
            for a in RECENT_ACTIVITIES[:500]:
                stats["total"] += 1
                if a.get("status") == "success":
                    stats["success"] += 1
                elif a.get("status") == "error":
                    stats["error"] += 1
                elif a.get("status") == "warning":
                    stats["warning"] += 1

        elif log_type == "errors":
            error_lines = read_error_log(limit=limit)
            logs = [
                {"raw": line}
                for line in error_lines
                if not search or search.lower() in line.lower()
            ]
            stats["error"] = len(logs)
            stats["total"] = len(logs)

        elif log_type == "app":
            app_lines = read_app_log(limit=limit)
            logs = [
                {"raw": line}
                for line in app_lines
                if not search or search.lower() in line.lower()
            ]
            stats["total"] = len(logs)

        return jsonify({"logs": logs, "stats": stats})

    except Exception as e:
        return jsonify({"logs": [{"raw": f"Error: {e}"}], "stats": stats})


# =============================================================================
# AI USAGE TRACKING
# =============================================================================


@app.route("/dashboard/ai-usage")
@require_staff(roles=["admin"])
def dashboard_ai_usage():
    """AI usage and cost tracking dashboard"""
    from services.ai_usage_service import (
        get_recent_logs,
        get_usage_by_client,
        get_usage_summary,
    )

    days = request.args.get("days", 30, type=int)

    summary = get_usage_summary(days=days)
    top_clients = get_usage_by_client(days=days, limit=10)
    recent_logs = get_recent_logs(limit=20)

    return render_template(
        "ai_usage_dashboard.html",
        summary=summary,
        top_clients=top_clients,
        recent_logs=recent_logs,
    )


@app.route("/api/ai-usage/summary", methods=["GET"])
@require_staff(roles=["admin"])
def api_ai_usage_summary():
    """Get AI usage summary statistics"""
    from services.ai_usage_service import get_usage_summary

    days = request.args.get("days", 30, type=int)
    client_id = request.args.get("client_id", type=int)

    summary = get_usage_summary(days=days, client_id=client_id)
    return jsonify(summary)


@app.route("/api/ai-usage/by-client", methods=["GET"])
@require_staff(roles=["admin"])
def api_ai_usage_by_client():
    """Get AI usage breakdown by client"""
    from services.ai_usage_service import get_usage_by_client

    days = request.args.get("days", 30, type=int)
    limit = request.args.get("limit", 20, type=int)

    clients = get_usage_by_client(days=days, limit=limit)
    return jsonify({"clients": clients})


@app.route("/api/ai-usage/recent", methods=["GET"])
@require_staff(roles=["admin"])
def api_ai_usage_recent():
    """Get recent AI API calls"""
    from services.ai_usage_service import get_recent_logs

    limit = request.args.get("limit", 50, type=int)

    logs = get_recent_logs(limit=limit)
    return jsonify({"logs": logs})


@app.route("/api/ai-usage/monthly", methods=["GET"])
@require_staff(roles=["admin"])
def api_ai_usage_monthly():
    """Get monthly AI usage report"""
    from services.ai_usage_service import get_monthly_report

    year = request.args.get("year", type=int)
    month = request.args.get("month", type=int)

    report = get_monthly_report(year=year, month=month)
    return jsonify(report)


@app.route("/api/ai-usage/export", methods=["GET"])
@require_staff(roles=["admin"])
def api_ai_usage_export():
    """Export AI usage data as CSV"""
    import csv
    from io import StringIO

    from services.ai_usage_service import get_recent_logs

    limit = request.args.get("limit", 1000, type=int)
    logs = get_recent_logs(limit=limit)

    output = StringIO()
    writer = csv.writer(output)
    writer.writerow(
        [
            "Date",
            "Service",
            "Operation",
            "Model",
            "Input Tokens",
            "Output Tokens",
            "Total Tokens",
            "Cost ($)",
            "Duration (ms)",
            "Client ID",
            "Success",
        ]
    )

    for log in logs:
        writer.writerow(
            [
                log.get("created_at", ""),
                log.get("service", ""),
                log.get("operation", ""),
                log.get("model", ""),
                log.get("input_tokens", 0),
                log.get("output_tokens", 0),
                log.get("total_tokens", 0),
                log.get("cost_dollars", 0),
                log.get("duration_ms", 0),
                log.get("client_id", ""),
                log.get("success", True),
            ]
        )

    output.seek(0)
    return send_file(
        io.BytesIO(output.getvalue().encode()),
        mimetype="text/csv",
        as_attachment=True,
        download_name=f"ai_usage_export_{datetime.utcnow().strftime('%Y%m%d')}.csv",
    )


# ============================================================
# PERFORMANCE MONITORING ROUTES
# ============================================================


@app.route("/dashboard/performance")
@require_staff(roles=["admin"])
@with_branding
def performance_dashboard():
    """Performance monitoring dashboard (admin only)"""
    db = get_db()
    try:
        perf_service = get_performance_service(db)

        summary = perf_service.get_performance_summary(period_minutes=60)
        slow_endpoints = perf_service.get_slow_endpoints(threshold_ms=100)
        cache_stats = perf_service.get_cache_stats()
        db_stats = perf_service.get_database_stats()
        index_recommendations = perf_service.get_index_recommendations()

        return render_template(
            "performance_dashboard.html",
            summary=summary,
            slow_endpoints=slow_endpoints,
            cache_stats=cache_stats,
            db_stats=db_stats,
            index_recommendations=index_recommendations,
            branding=getattr(g, "whitelabel_branding", None),
        )
    except Exception as e:
        print(f"Performance dashboard error: {e}")
        return (
            render_template("error.html", error="Dashboard Error", message=str(e)),
            500,
        )
    finally:
        db.close()


@app.route("/api/performance/metrics", methods=["GET"])
@require_staff(roles=["admin"])
def api_performance_metrics():
    """Get current performance metrics for all endpoints"""
    try:
        period = request.args.get("period", 60, type=int)
        endpoint = request.args.get("endpoint")
        method = request.args.get("method")

        db = get_db()
        try:
            perf_service = get_performance_service(db)

            if endpoint and method:
                metrics = perf_service.get_endpoint_metrics(endpoint, method)
            else:
                metrics = perf_service.get_endpoint_metrics()

            summary = perf_service.get_performance_summary(period_minutes=period)

            return jsonify(
                {
                    "success": True,
                    "metrics": metrics,
                    "summary": summary,
                    "period_minutes": period,
                }
            )
        finally:
            db.close()
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/performance/slow-endpoints", methods=["GET"])
@require_staff(roles=["admin"])
def api_slow_endpoints():
    """Identify slow endpoints with recommendations"""
    try:
        threshold_ms = request.args.get("threshold", 100, type=float)

        db = get_db()
        try:
            perf_service = get_performance_service(db)
            slow_endpoints = perf_service.get_slow_endpoints(threshold_ms=threshold_ms)

            return jsonify(
                {
                    "success": True,
                    "slow_endpoints": slow_endpoints,
                    "threshold_ms": threshold_ms,
                    "count": len(slow_endpoints),
                }
            )
        finally:
            db.close()
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/performance/cache-stats", methods=["GET"])
@require_staff(roles=["admin"])
def api_cache_stats():
    """Get cache statistics"""
    try:
        perf_service = get_performance_service()
        cache_stats = perf_service.get_cache_stats()

        return jsonify({"success": True, "cache_stats": cache_stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/performance/cache/clear", methods=["POST"])
@require_staff(roles=["admin"])
def api_clear_cache():
    """Clear cache entries matching pattern"""
    data = request.get_json() or {}
    pattern = data.get("pattern")

    try:
        perf_service = get_performance_service()
        result = perf_service.clear_cache(pattern=pattern)

        return jsonify({"success": True, "result": result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/performance/db-stats", methods=["GET"])
@require_staff(roles=["admin"])
def api_db_stats():
    """Get database connection pool and performance stats"""
    try:
        db = get_db()
        try:
            perf_service = get_performance_service(db)
            db_stats = perf_service.get_database_stats()
            index_recommendations = perf_service.get_index_recommendations()

            return jsonify(
                {
                    "success": True,
                    "db_stats": db_stats,
                    "index_recommendations": index_recommendations,
                }
            )
        finally:
            db.close()
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/performance/query/analyze", methods=["POST"])
@require_staff(roles=["admin"])
def api_analyze_query():
    """Analyze a SQL query for optimization opportunities"""
    data = request.get_json() or {}
    query = data.get("query", "")

    if not query:
        return jsonify({"success": False, "error": "Query required"}), 400

    try:
        perf_service = get_performance_service()
        analysis = perf_service.optimize_query(query)

        return jsonify({"success": True, "analysis": analysis})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/performance/cleanup", methods=["POST"])
@require_staff(roles=["admin"])
def api_performance_cleanup():
    """Clean up old performance metrics and expired cache entries"""
    data = request.get_json() or {}
    max_age_minutes = data.get("max_age_minutes", 60)

    try:
        perf_service = get_performance_service()

        metrics_cleared = perf_service.clear_old_metrics(
            max_age_minutes=max_age_minutes
        )
        cache_expired = app_cache.cleanup_expired()

        return jsonify(
            {
                "success": True,
                "metrics_cleared": metrics_cleared,
                "cache_entries_expired": cache_expired,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ============================================================
# END PERFORMANCE MONITORING ROUTES
# ============================================================


# üö® GLOBAL ERROR HANDLER: Always return JSON, never HTML
@app.errorhandler(500)
def handle_500_error(error):
    """Handle any unhandled server errors and return sanitized JSON"""
    from services.error_sanitizer_service import handle_exception
    return handle_exception(error, status_code=500)


# ============================================================
# SUSPENSE ACCOUNT DETECTION ROUTES
# ============================================================


@app.route("/dashboard/suspense-accounts")
@require_staff(roles=["admin", "paralegal", "attorney"])
def dashboard_suspense_accounts():
    """Dashboard page showing suspense account findings"""
    db = get_db()
    try:
        findings = (
            db.query(SuspenseAccountFinding)
            .order_by(SuspenseAccountFinding.created_at.desc())
            .all()
        )

        total_findings = len(findings)
        false_lates = sum(f.false_lates_count or 0 for f in findings)
        total_suspense = sum(f.total_suspense_amount or 0 for f in findings)
        clients_affected = len(set(f.client_id for f in findings))

        clients = db.query(Client).filter(Client.status.in_(["active", "signup"])).all()

        findings_with_clients = []
        for f in findings:
            client = db.query(Client).filter_by(id=f.client_id).first()
            findings_with_clients.append(
                {"finding": f, "client_name": client.name if client else "Unknown"}
            )

        return render_template(
            "suspense_accounts.html",
            findings=findings_with_clients,
            total_findings=total_findings,
            false_lates=false_lates,
            total_suspense=total_suspense,
            clients_affected=clients_affected,
            clients=clients,
        )
    finally:
        db.close()


@app.route("/api/mortgage-ledger/upload", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_upload_mortgage_ledger():
    """Upload mortgage payment history CSV"""
    import csv
    from io import StringIO

    if "file" not in request.files:
        return jsonify({"success": False, "error": "No file uploaded"}), 400

    file = request.files["file"]
    client_id = request.form.get("client_id")

    if not client_id:
        return jsonify({"success": False, "error": "Client ID required"}), 400

    if not file.filename.endswith(".csv"):
        return jsonify({"success": False, "error": "Only CSV files are supported"}), 400

    db = get_db()
    try:
        client = db.query(Client).filter_by(id=int(client_id)).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        content = file.read().decode("utf-8")
        csv_reader = csv.DictReader(StringIO(content))

        records_created = 0
        for row in csv_reader:
            try:
                payment_date = None
                due_date = None

                if row.get("payment_date"):
                    try:
                        payment_date = datetime.strptime(
                            row["payment_date"], "%Y-%m-%d"
                        ).date()
                    except:
                        try:
                            payment_date = datetime.strptime(
                                row["payment_date"], "%m/%d/%Y"
                            ).date()
                        except:
                            continue

                if row.get("due_date"):
                    try:
                        due_date = datetime.strptime(row["due_date"], "%Y-%m-%d").date()
                    except:
                        try:
                            due_date = datetime.strptime(
                                row["due_date"], "%m/%d/%Y"
                            ).date()
                        except:
                            pass

                ledger = MortgagePaymentLedger(
                    client_id=int(client_id),
                    creditor_name=row.get(
                        "creditor_name", row.get("lender", "Unknown")
                    ),
                    account_number_masked=(
                        row.get("account_number", row.get("account", ""))[-4:]
                        if row.get("account_number") or row.get("account")
                        else ""
                    ),
                    loan_type=row.get("loan_type", "conventional"),
                    payment_date=payment_date,
                    payment_amount=float(
                        row.get("payment_amount", row.get("amount", 0)) or 0
                    ),
                    due_date=due_date,
                    applied_to_principal=float(row.get("principal", 0) or 0),
                    applied_to_interest=float(row.get("interest", 0) or 0),
                    applied_to_escrow=float(row.get("escrow", 0) or 0),
                    applied_to_fees=float(row.get("fees", 0) or 0),
                    held_in_suspense=float(
                        row.get("suspense", row.get("held_in_suspense", 0)) or 0
                    ),
                    is_suspense=float(
                        row.get("suspense", row.get("held_in_suspense", 0)) or 0
                    )
                    > 0,
                    suspense_reason=row.get("suspense_reason", ""),
                    reported_as_late=row.get("reported_late", "").lower()
                    in ["true", "yes", "1", "y"],
                    days_late_reported=int(row.get("days_late", 0) or 0),
                )
                db.add(ledger)
                records_created += 1
            except Exception as e:
                print(f"Error processing row: {e}")
                continue

        db.commit()
        return jsonify(
            {
                "success": True,
                "message": f"Successfully uploaded {records_created} payment records",
                "records_created": records_created,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/suspense-accounts/analyze/<int:client_id>", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_analyze_suspense_accounts(client_id):
    """Analyze client's mortgage payments for suspense issues"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        ledger_entries = (
            db.query(MortgagePaymentLedger)
            .filter_by(client_id=client_id)
            .order_by(MortgagePaymentLedger.payment_date)
            .all()
        )

        if not ledger_entries:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "No mortgage payment records found for this client",
                    }
                ),
                404,
            )

        findings_created = 0
        creditor_groups = {}
        for entry in ledger_entries:
            if entry.creditor_name not in creditor_groups:
                creditor_groups[entry.creditor_name] = []
            creditor_groups[entry.creditor_name].append(entry)

        for creditor, entries in creditor_groups.items():
            suspense_entries = [
                e
                for e in entries
                if e.is_suspense or (e.held_in_suspense and e.held_in_suspense > 0)
            ]
            false_late_entries = [
                e
                for e in entries
                if e.reported_as_late and e.held_in_suspense and e.held_in_suspense > 0
            ]

            if suspense_entries or false_late_entries:
                total_suspense = sum(e.held_in_suspense or 0 for e in suspense_entries)
                months_affected = len(
                    set(
                        e.payment_date.strftime("%Y-%m")
                        for e in suspense_entries
                        if e.payment_date
                    )
                )
                false_lates = len(false_late_entries)

                finding_type = "false_late" if false_lates > 0 else "payment_held"
                if any(
                    e.suspense_reason and "misapplied" in e.suspense_reason.lower()
                    for e in suspense_entries
                ):
                    finding_type = "misapplied_payment"
                elif any(
                    e.suspense_reason and "escrow" in e.suspense_reason.lower()
                    for e in suspense_entries
                ):
                    finding_type = "escrow_mishandling"

                timeline = []
                for e in entries[-12:]:
                    timeline.append(
                        {
                            "date": (
                                e.payment_date.strftime("%Y-%m-%d")
                                if e.payment_date
                                else None
                            ),
                            "amount": e.payment_amount,
                            "suspense": e.held_in_suspense,
                            "reported_late": e.reported_as_late,
                            "days_late": e.days_late_reported,
                        }
                    )

                finding = SuspenseAccountFinding(
                    client_id=client_id,
                    creditor_name=creditor,
                    account_number_masked=(
                        entries[0].account_number_masked if entries else ""
                    ),
                    finding_type=finding_type,
                    finding_description=f"Detected {months_affected} months of suspense account activity with {false_lates} potential false late payments reported",
                    total_suspense_amount=total_suspense,
                    months_affected=months_affected,
                    false_lates_count=false_lates,
                    evidence_summary=f"Analysis of {len(entries)} payment records reveals systematic mishandling of payments",
                    payment_timeline=timeline,
                    is_fcra_violation=false_lates > 0,
                    fcra_section="1681s-2(a)" if false_lates > 0 else None,
                    violation_description=(
                        f"Furnisher reported {false_lates} late payments while holding funds in suspense"
                        if false_lates > 0
                        else None
                    ),
                    estimated_damages=(
                        1000 * false_lates + total_suspense * 0.1
                        if false_lates > 0
                        else 0
                    ),
                    status="identified",
                )
                db.add(finding)
                findings_created += 1

        db.commit()
        return jsonify(
            {
                "success": True,
                "message": f"Analysis complete. Created {findings_created} findings.",
                "findings_created": findings_created,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/suspense-accounts/<int:id>", methods=["GET"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_get_suspense_finding(id):
    """Get suspense account finding details"""
    db = get_db()
    try:
        finding = db.query(SuspenseAccountFinding).filter_by(id=id).first()
        if not finding:
            return jsonify({"success": False, "error": "Finding not found"}), 404

        client = db.query(Client).filter_by(id=finding.client_id).first()

        return jsonify(
            {
                "success": True,
                "finding": {
                    "id": finding.id,
                    "client_id": finding.client_id,
                    "client_name": client.name if client else "Unknown",
                    "creditor_name": finding.creditor_name,
                    "account_number_masked": finding.account_number_masked,
                    "finding_type": finding.finding_type,
                    "finding_description": finding.finding_description,
                    "total_suspense_amount": finding.total_suspense_amount,
                    "months_affected": finding.months_affected,
                    "false_lates_count": finding.false_lates_count,
                    "evidence_summary": finding.evidence_summary,
                    "payment_timeline": finding.payment_timeline,
                    "is_fcra_violation": finding.is_fcra_violation,
                    "fcra_section": finding.fcra_section,
                    "violation_description": finding.violation_description,
                    "estimated_damages": finding.estimated_damages,
                    "status": finding.status,
                    "dispute_sent_date": (
                        finding.dispute_sent_date.isoformat()
                        if finding.dispute_sent_date
                        else None
                    ),
                    "resolution_date": (
                        finding.resolution_date.isoformat()
                        if finding.resolution_date
                        else None
                    ),
                    "resolution_outcome": finding.resolution_outcome,
                    "admin_notes": finding.admin_notes,
                    "created_at": (
                        finding.created_at.isoformat() if finding.created_at else None
                    ),
                },
            }
        )
    finally:
        db.close()


@app.route("/api/suspense-accounts/<int:id>/update", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_update_suspense_finding(id):
    """Update suspense account finding status"""
    db = get_db()
    try:
        finding = db.query(SuspenseAccountFinding).filter_by(id=id).first()
        if not finding:
            return jsonify({"success": False, "error": "Finding not found"}), 404

        data = request.get_json() or {}

        if "status" in data:
            finding.status = data["status"]
        if "admin_notes" in data:
            finding.admin_notes = data["admin_notes"]
        if "dispute_sent_date" in data:
            if data["dispute_sent_date"]:
                finding.dispute_sent_date = datetime.strptime(
                    data["dispute_sent_date"], "%Y-%m-%d"
                ).date()
            else:
                finding.dispute_sent_date = None
        if "resolution_date" in data:
            if data["resolution_date"]:
                finding.resolution_date = datetime.strptime(
                    data["resolution_date"], "%Y-%m-%d"
                ).date()
            else:
                finding.resolution_date = None
        if "resolution_outcome" in data:
            finding.resolution_outcome = data["resolution_outcome"]
        if "remediation_requested" in data:
            finding.remediation_requested = data["remediation_requested"]
        if "credit_correction_requested" in data:
            finding.credit_correction_requested = data["credit_correction_requested"]
        if "damages_claimed" in data:
            finding.damages_claimed = (
                float(data["damages_claimed"]) if data["damages_claimed"] else None
            )

        db.commit()
        return jsonify({"success": True, "message": "Finding updated successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/suspense-accounts/<int:id>/create-dispute", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_create_dispute_from_finding(id):
    """Create a dispute from a suspense account finding"""
    db = get_db()
    try:
        finding = db.query(SuspenseAccountFinding).filter_by(id=id).first()
        if not finding:
            return jsonify({"success": False, "error": "Finding not found"}), 404

        finding.status = "disputed"
        finding.dispute_sent_date = datetime.utcnow().date()

        if finding.is_fcra_violation:
            violation = Violation(
                analysis_id=None,
                client_id=finding.client_id,
                bureau="Furnisher",
                account_name=finding.creditor_name,
                violation_type="False Late Payment Reporting",
                fcra_section=finding.fcra_section or "1681s-2(a)",
                severity="high",
                description=finding.violation_description
                or finding.finding_description,
                evidence=finding.evidence_summary,
            )
            db.add(violation)
            db.flush()
            finding.violation_id = violation.id

        db.commit()
        return jsonify(
            {
                "success": True,
                "message": "Dispute created successfully",
                "finding_id": finding.id,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/credit-import")
@require_staff(roles=["admin", "paralegal", "attorney"])
def credit_import_dashboard():
    """Credit Report Auto-Import Dashboard"""
    db = get_db()
    try:
        credentials = (
            db.query(CreditMonitoringCredential)
            .order_by(CreditMonitoringCredential.created_at.desc())
            .all()
        )
        clients = (
            db.query(Client)
            .filter(Client.status != "cancelled")
            .order_by(Client.name)
            .all()
        )

        now = datetime.utcnow()
        day_ago = now - timedelta(days=1)

        stats = {
            "total": len(credentials),
            "active": sum(1 for c in credentials if c.is_active),
            "recent_imports": sum(
                1
                for c in credentials
                if c.last_import_at and c.last_import_at > day_ago
            ),
            "failed": sum(1 for c in credentials if c.last_import_status == "failed"),
        }

        credentials_data = [c.to_dict() for c in credentials]

        response = make_response(
            render_template(
                "credit_import.html",
                credentials=credentials_data,
                clients=clients,
                services=CREDIT_MONITORING_SERVICES,
                stats=stats,
            )
        )
        response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response
    finally:
        db.close()


@app.route("/api/credit-import/credentials", methods=["GET"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_list_credit_import_credentials():
    """List all credit monitoring credentials"""
    db = get_db()
    try:
        credentials = (
            db.query(CreditMonitoringCredential)
            .order_by(CreditMonitoringCredential.created_at.desc())
            .all()
        )
        return jsonify(
            {"success": True, "credentials": [c.to_dict() for c in credentials]}
        )
    finally:
        db.close()


@app.route("/api/credit-import/credentials", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_create_credit_import_credential():
    """Create new credit monitoring credential"""
    db = get_db()
    try:
        data = request.get_json()

        if not data.get("client_id"):
            return jsonify({"success": False, "error": "Client ID is required"}), 400
        if not data.get("service_name"):
            return jsonify({"success": False, "error": "Service name is required"}), 400
        if not data.get("username"):
            return jsonify({"success": False, "error": "Username is required"}), 400
        if not data.get("password"):
            return jsonify({"success": False, "error": "Password is required"}), 400

        client = db.query(Client).filter_by(id=data["client_id"]).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        existing = (
            db.query(CreditMonitoringCredential)
            .filter_by(client_id=data["client_id"], service_name=data["service_name"])
            .first()
        )
        if existing:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Credential already exists for this client and service",
                    }
                ),
                400,
            )

        encrypted_password = encrypt_value(data["password"])
        encrypted_ssn_last4 = (
            encrypt_value(data["ssn_last4"]) if data.get("ssn_last4") else None
        )

        credential = CreditMonitoringCredential(
            client_id=data["client_id"],
            service_name=data["service_name"],
            username=data["username"],
            password_encrypted=encrypted_password,
            ssn_last4_encrypted=encrypted_ssn_last4,
            is_active=True,
            import_frequency=data.get("import_frequency", "manual"),
            last_import_status="pending",
        )

        if credential.import_frequency == "daily":
            credential.next_scheduled_import = datetime.utcnow() + timedelta(days=1)
        elif credential.import_frequency == "weekly":
            credential.next_scheduled_import = datetime.utcnow() + timedelta(weeks=1)

        db.add(credential)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Credential created successfully",
                "credential": credential.to_dict(),
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/credit-import/credentials/<int:id>", methods=["PUT"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_update_credit_import_credential(id):
    """Update credit monitoring credential"""
    db = get_db()
    try:
        credential = db.query(CreditMonitoringCredential).filter_by(id=id).first()
        if not credential:
            return jsonify({"success": False, "error": "Credential not found"}), 404

        data = request.get_json()

        if "client_id" in data:
            credential.client_id = data["client_id"]
        if "service_name" in data:
            credential.service_name = data["service_name"]
        if "username" in data:
            credential.username = data["username"]
        if "password" in data and data["password"]:
            credential.password_encrypted = encrypt_value(data["password"])
        if "ssn_last4" in data and data["ssn_last4"]:
            credential.ssn_last4_encrypted = encrypt_value(data["ssn_last4"])
        if "is_active" in data:
            credential.is_active = data["is_active"]
        if "import_frequency" in data:
            credential.import_frequency = data["import_frequency"]
            if credential.import_frequency == "daily":
                credential.next_scheduled_import = datetime.utcnow() + timedelta(days=1)
            elif credential.import_frequency == "weekly":
                credential.next_scheduled_import = datetime.utcnow() + timedelta(
                    weeks=1
                )
            else:
                credential.next_scheduled_import = None

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Credential updated successfully",
                "credential": credential.to_dict(),
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/credit-import/credentials/<int:id>", methods=["DELETE"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_delete_credit_import_credential(id):
    """Delete credit monitoring credential"""
    db = get_db()
    try:
        credential = db.query(CreditMonitoringCredential).filter_by(id=id).first()
        if not credential:
            return jsonify({"success": False, "error": "Credential not found"}), 404

        db.delete(credential)
        db.commit()

        return jsonify({"success": True, "message": "Credential deleted successfully"})
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/credit-import/trigger/<int:client_id>", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_trigger_credit_import(client_id):
    """Trigger manual credit report import for a client using browser automation"""
    from services.credit_import_automation import run_import_sync
    from services.encryption import decrypt_value

    db = get_db()
    try:
        credentials = (
            db.query(CreditMonitoringCredential)
            .filter_by(client_id=client_id, is_active=True)
            .all()
        )

        if not credentials:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "No active credentials found for this client",
                    }
                ),
                404,
            )

        results = []
        for cred in credentials:
            cred.last_import_status = "pending"
            cred.last_import_error = None
            db.commit()

            print(
                f"üì• Starting credit import for client {client_id}, service: {cred.service_name}"
            )

            try:
                password = decrypt_value(cred.password_encrypted)
                ssn_last4 = (
                    decrypt_value(cred.ssn_last4_encrypted)
                    if cred.ssn_last4_encrypted
                    else ""
                )

                result = run_import_sync(
                    service_name=cred.service_name,
                    username=cred.username,
                    password=password,
                    ssn_last4=ssn_last4,
                    client_id=client_id,
                    client_name=(
                        cred.client.name if cred.client else f"Client {client_id}"
                    ),
                )

                if result["success"]:
                    cred.last_import_status = "success"
                    cred.last_import_at = datetime.utcnow()
                    cred.last_import_error = None
                    cred.last_report_path = result.get("report_path")
                    print(f"‚úÖ Import successful for {cred.service_name}")
                else:
                    cred.last_import_status = "failed"
                    cred.last_import_error = result.get("error", "Unknown error")
                    print(
                        f"‚ùå Import failed for {cred.service_name}: {result.get('error')}"
                    )

                results.append(
                    {
                        "service": cred.service_name,
                        "success": result["success"],
                        "error": result.get("error"),
                        "report_path": result.get("report_path"),
                    }
                )

            except Exception as e:
                cred.last_import_status = "failed"
                cred.last_import_error = str(e)
                results.append(
                    {"service": cred.service_name, "success": False, "error": str(e)}
                )

            db.commit()

        success_count = sum(1 for r in results if r["success"])

        return jsonify(
            {
                "success": success_count > 0,
                "message": f"Import completed: {success_count}/{len(results)} successful",
                "results": results,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/credit-import/trigger-all", methods=["POST"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_trigger_all_credit_imports():
    """Trigger all due credit report imports using browser automation"""
    from services.credit_import_automation import run_import_sync
    from services.encryption import decrypt_value

    db = get_db()
    try:
        now = datetime.utcnow()

        due_credentials = (
            db.query(CreditMonitoringCredential)
            .filter(
                CreditMonitoringCredential.is_active == True,
                CreditMonitoringCredential.import_frequency.in_(["daily", "weekly"]),
                (CreditMonitoringCredential.next_scheduled_import <= now)
                | (CreditMonitoringCredential.next_scheduled_import == None),
            )
            .all()
        )

        results = []
        for cred in due_credentials:
            cred.last_import_status = "pending"
            cred.last_import_error = None

            if cred.import_frequency == "daily":
                cred.next_scheduled_import = now + timedelta(days=1)
            elif cred.import_frequency == "weekly":
                cred.next_scheduled_import = now + timedelta(weeks=1)

            db.commit()

            print(
                f"üì• Starting credit import for client {cred.client_id}, service: {cred.service_name}"
            )

            try:
                password = decrypt_value(cred.password_encrypted)
                ssn_last4 = (
                    decrypt_value(cred.ssn_last4_encrypted)
                    if cred.ssn_last4_encrypted
                    else ""
                )

                result = run_import_sync(
                    service_name=cred.service_name,
                    username=cred.username,
                    password=password,
                    ssn_last4=ssn_last4,
                    client_id=cred.client_id,
                    client_name=(
                        cred.client.name if cred.client else f"Client {cred.client_id}"
                    ),
                )

                if result["success"]:
                    cred.last_import_status = "success"
                    cred.last_import_at = datetime.utcnow()
                    cred.last_import_error = None
                    cred.last_report_path = result.get("report_path")
                    print(f"‚úÖ Import successful for {cred.service_name}")
                else:
                    cred.last_import_status = "failed"
                    cred.last_import_error = result.get("error", "Unknown error")
                    print(
                        f"‚ùå Import failed for {cred.service_name}: {result.get('error')}"
                    )

                results.append(
                    {
                        "client_id": cred.client_id,
                        "service": cred.service_name,
                        "success": result["success"],
                        "error": result.get("error"),
                    }
                )

            except Exception as e:
                cred.last_import_status = "failed"
                cred.last_import_error = str(e)
                results.append(
                    {
                        "client_id": cred.client_id,
                        "service": cred.service_name,
                        "success": False,
                        "error": str(e),
                    }
                )

            db.commit()

        success_count = sum(1 for r in results if r["success"])

        return jsonify(
            {
                "success": True,
                "message": f"Import completed: {success_count}/{len(results)} successful",
                "total_processed": len(results),
                "successful": success_count,
                "results": results,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/credit-import/stats", methods=["GET"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_credit_import_stats():
    """Get credit import dashboard statistics"""
    db = get_db()
    try:
        credentials = db.query(CreditMonitoringCredential).all()
        now = datetime.utcnow()
        day_ago = now - timedelta(days=1)

        stats = {
            "total": len(credentials),
            "active": sum(1 for c in credentials if c.is_active),
            "recent_imports": sum(
                1
                for c in credentials
                if c.last_import_at and c.last_import_at > day_ago
            ),
            "failed": sum(1 for c in credentials if c.last_import_status == "failed"),
            "pending": sum(1 for c in credentials if c.last_import_status == "pending"),
            "due_for_import": sum(
                1
                for c in credentials
                if c.is_active
                and c.next_scheduled_import
                and c.next_scheduled_import <= now
            ),
        }

        return jsonify({"success": True, "stats": stats})
    finally:
        db.close()


@app.route("/api/credit-import/browser-status", methods=["GET"])
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_credit_import_browser_status():
    """Check if browser automation is available and working"""
    from services.credit_import_automation import test_browser_availability

    available, message = test_browser_availability()
    return jsonify(
        {"success": True, "browser_available": available, "message": message}
    )


@app.route("/api/credit-import/report/<int:credential_id>")
@require_staff(roles=["admin", "paralegal", "attorney"])
def api_view_credit_import_report(credential_id):
    """View downloaded credit report in clean three-bureau format"""
    from services.credit_report_parser import parse_credit_report

    db = get_db()
    try:
        cred = db.query(CreditMonitoringCredential).filter_by(id=credential_id).first()
        if not cred or not cred.last_report_path:
            return jsonify({"success": False, "error": "No report found"}), 404

        report_path = cred.last_report_path
        if not os.path.exists(report_path):
            return jsonify({"success": False, "error": "Report file not found"}), 404

        parsed_data = parse_credit_report(report_path, cred.service_name)

        client_name = cred.client.name if cred.client else f"Client {cred.client_id}"
        report_date = (
            cred.last_import_at.strftime("%B %d, %Y at %I:%M %p")
            if cred.last_import_at
            else "Unknown"
        )

        return render_template(
            "credit_report_view.html",
            client_name=client_name,
            service_name=cred.service_name,
            report_date=report_date,
            scores=parsed_data.get("scores", {}),
            personal_info=parsed_data.get("personal_info", {}),
            accounts=parsed_data.get("accounts", []),
            inquiries=parsed_data.get("inquiries", []),
            collections=parsed_data.get("collections", []),
            public_records=parsed_data.get("public_records", []),
            creditor_contacts=parsed_data.get("creditor_contacts", []),
            summary=parsed_data.get("summary", {}),
            analytics=parsed_data.get("analytics", {}),
        )
    finally:
        db.close()


# ============================================================
# AUTO-PULL CREDIT REPORTS API (P25)
# ============================================================


@app.route("/api/auto-pull/stats", methods=["GET"])
@require_staff()
def api_auto_pull_stats():
    """Get auto-pull dashboard statistics"""
    from services.auto_pull_service import AutoPullService

    service = AutoPullService()
    stats = service.get_pull_stats()

    return jsonify({"success": True, **stats})


@app.route("/api/auto-pull/services", methods=["GET"])
@require_staff()
def api_auto_pull_services():
    """Get list of supported credit monitoring services"""
    from services.auto_pull_service import AutoPullService

    services = AutoPullService.get_supported_services()
    frequencies = AutoPullService.get_frequencies()

    return jsonify({"success": True, "services": services, "frequencies": frequencies})


@app.route("/api/auto-pull/credentials", methods=["GET"])
@require_staff()
def api_auto_pull_credentials():
    """Get all active credentials"""
    from services.auto_pull_service import AutoPullService

    client_id = request.args.get("client_id", type=int)
    service_name = request.args.get("service")

    service = AutoPullService()
    credentials = service.get_credentials(
        client_id=client_id, service_name=service_name
    )

    return jsonify({"success": True, "credentials": credentials})


@app.route("/api/auto-pull/credentials", methods=["POST"])
@require_staff()
def api_auto_pull_add_credential():
    """Add new credential for auto-pull"""
    from services.auto_pull_service import AutoPullService

    data = request.json
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    required = ["client_id", "service_name", "username", "password"]
    for field in required:
        if not data.get(field):
            return (
                jsonify(
                    {"success": False, "error": f"Missing required field: {field}"}
                ),
                400,
            )

    service = AutoPullService()
    result = service.add_credential(
        client_id=data["client_id"],
        service_name=data["service_name"],
        username=data["username"],
        password=data["password"],
        ssn_last4=data.get("ssn_last4"),
        import_frequency=data.get("import_frequency", "manual"),
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/auto-pull/credentials/<int:credential_id>", methods=["PUT"])
@require_staff()
def api_auto_pull_update_credential(credential_id):
    """Update credential settings"""
    from services.auto_pull_service import AutoPullService

    data = request.json or {}

    service = AutoPullService()
    result = service.update_credential(
        credential_id=credential_id,
        username=data.get("username"),
        password=data.get("password"),
        import_frequency=data.get("import_frequency"),
        is_active=data.get("is_active"),
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/auto-pull/credentials/<int:credential_id>", methods=["DELETE"])
@require_staff()
def api_auto_pull_delete_credential(credential_id):
    """Deactivate a credential"""
    from services.auto_pull_service import AutoPullService

    service = AutoPullService()
    result = service.delete_credential(credential_id)

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/auto-pull/pull/<int:credential_id>", methods=["POST"])
@require_staff()
def api_auto_pull_initiate(credential_id):
    """Initiate a manual pull for a credential"""
    from services.auto_pull_service import AutoPullService

    staff_id = session.get("staff_id", "unknown")

    service = AutoPullService()
    result = service.initiate_pull(
        credential_id=credential_id,
        pull_type="manual",
        triggered_by=f"staff_{staff_id}",
    )

    if result.get("success"):
        return jsonify(result)
    else:
        return jsonify(result), 400


@app.route("/api/auto-pull/pull-client/<int:client_id>", methods=["POST"])
@require_staff()
def api_auto_pull_client(client_id):
    """Pull all active credentials for a client"""
    from services.auto_pull_service import AutoPullService

    staff_id = session.get("staff_id", "unknown")

    service = AutoPullService()
    credentials = service.get_credentials(client_id=client_id)

    results = {"total": len(credentials), "success": 0, "failed": 0, "pulls": []}

    for cred in credentials:
        result = service.initiate_pull(
            credential_id=cred["id"],
            pull_type="manual",
            triggered_by=f"staff_{staff_id}",
        )

        if result.get("success"):
            results["success"] += 1
        else:
            results["failed"] += 1

        results["pulls"].append(
            {
                "credential_id": cred["id"],
                "service": cred["service_name"],
                "success": result.get("success", False),
                "error": result.get("error"),
            }
        )

    return jsonify({"success": True, **results})


@app.route("/api/auto-pull/run-scheduled", methods=["POST"])
@require_staff(roles=["admin"])
def api_auto_pull_run_scheduled():
    """Run all scheduled pulls that are due"""
    from services.auto_pull_service import AutoPullService

    staff_id = session.get("staff_id", "unknown")

    service = AutoPullService()
    result = service.run_scheduled_pulls(triggered_by=f"staff_{staff_id}")

    return jsonify({"success": True, **result})


@app.route("/api/auto-pull/due", methods=["GET"])
@require_staff()
def api_auto_pull_due():
    """Get credentials due for scheduled pull"""
    from services.auto_pull_service import AutoPullService

    service = AutoPullService()
    due = service.get_due_pulls()

    return jsonify({"success": True, "due": due, "count": len(due)})


@app.route("/api/auto-pull/logs", methods=["GET"])
@require_staff()
def api_auto_pull_logs():
    """Get pull logs"""
    from services.auto_pull_service import AutoPullService

    client_id = request.args.get("client_id", type=int)
    credential_id = request.args.get("credential_id", type=int)
    status = request.args.get("status")
    limit = request.args.get("limit", 50, type=int)

    service = AutoPullService()
    logs = service.get_pull_logs(
        client_id=client_id, credential_id=credential_id, status=status, limit=limit
    )

    return jsonify({"success": True, "logs": logs})


@app.route("/api/auto-pull/validate/<int:credential_id>", methods=["POST"])
@require_staff()
def api_auto_pull_validate(credential_id):
    """Validate credentials"""
    from services.auto_pull_service import AutoPullService

    service = AutoPullService()
    result = service.validate_credentials(credential_id)

    return jsonify(result)


@app.route("/dashboard/auto-pull", methods=["GET"])
@require_staff()
def dashboard_auto_pull():
    """Auto-pull credit reports dashboard"""
    from services.auto_pull_service import SUPPORTED_SERVICES, AutoPullService

    service = AutoPullService()
    stats = service.get_pull_stats()
    credentials = service.get_credentials()
    due_for_pull = service.get_due_pulls()
    logs = service.get_pull_logs(limit=50)

    # Calculate service stats for dashboard breakdown
    service_stats = {}
    for key in SUPPORTED_SERVICES:
        service_creds = [c for c in credentials if c.get("service_name") == key]
        service_logs = [l for l in logs if l.get("service_name") == key]
        success_logs = [l for l in service_logs if l.get("status") == "success"]
        service_stats[key] = {
            "credentials": len(service_creds),
            "pulls": len(service_logs),
            "success": (
                int((len(success_logs) / len(service_logs) * 100))
                if service_logs
                else 0
            ),
        }

    db = get_db()
    try:
        clients = (
            db.query(Client)
            .filter(Client.dispute_status.notin_(["lead", "cancelled"]))
            .order_by(Client.name)
            .all()
        )

        return render_template(
            "auto_pull.html",
            active_page="auto-pull",
            stats=stats,
            services=SUPPORTED_SERVICES,
            service_stats=service_stats,
            credentials=credentials,
            logs=logs,
            due_for_pull=due_for_pull,
            clients=clients,
        )
    finally:
        db.close()


@app.route("/api/cron/auto-pull", methods=["GET", "POST"])
def api_cron_auto_pull():
    """Cron endpoint for running scheduled pulls"""
    from services.auto_pull_service import AutoPullService

    # Verify cron secret
    cron_secret = os.environ.get("CRON_SECRET", "")
    provided_secret = request.headers.get("X-Cron-Secret") or request.args.get("secret")

    if cron_secret and provided_secret != cron_secret:
        return jsonify({"success": False, "error": "Invalid cron secret"}), 403

    service = AutoPullService()
    result = service.run_scheduled_pulls(triggered_by="cron")

    return jsonify({"success": True, **result})


# ============================================================
# AUTOMATION API ROUTES
# ============================================================


@app.route("/api/automation/send-batch", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def api_automation_send_batch():
    """Send batch of dispute letters via SendCertifiedMail.com SFTP"""
    from services.sendcertified_sftp_service import send_letter_batch

    data = request.json
    letter_ids = data.get("letter_ids", [])

    if not letter_ids:
        return jsonify({"success": False, "error": "No letter_ids provided"}), 400

    db = get_db()
    try:
        result = send_letter_batch(db, letter_ids)
        return jsonify(
            {
                "success": True,
                "batch_id": result["batch_id"],
                "letter_count": result["letter_count"],
                "cost_cents": result["cost_cents"],
                "cost_dollars": result["cost_cents"] / 100,
                "deadline_ids": result["deadline_ids"],
                "sent_at": result["sent_at"],
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/automation/batch-status/<batch_id>")
@require_staff()
def api_automation_batch_status(batch_id):
    """Get status and tracking info for a letter batch"""
    from database import LetterBatch
    from services.sendcertified_sftp_service import check_tracking

    db = get_db()
    try:
        # Get batch record
        batch = db.query(LetterBatch).filter_by(batch_id=batch_id).first()

        if not batch:
            return jsonify({"success": False, "error": "Batch not found"}), 404

        # Check for tracking updates
        tracking_result = check_tracking(batch_id)

        return jsonify(
            {
                "success": True,
                "batch": {
                    "batch_id": batch.batch_id,
                    "letter_count": batch.letter_count,
                    "cost_cents": batch.cost_cents,
                    "status": batch.status,
                    "uploaded_at": (
                        batch.uploaded_at.isoformat() if batch.uploaded_at else None
                    ),
                    "tracking_received_at": (
                        batch.tracking_received_at.isoformat()
                        if batch.tracking_received_at
                        else None
                    ),
                    "error_message": batch.error_message,
                },
                "tracking": tracking_result,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/automation/metrics/<int:client_id>")
@require_staff()
def api_automation_metrics(client_id):
    """Get automation metrics for a client"""
    from database import AutomationMetrics

    db = get_db()
    try:
        metrics = db.query(AutomationMetrics).filter_by(client_id=client_id).first()

        if not metrics:
            # Return empty metrics if none exist yet
            return jsonify(
                {
                    "success": True,
                    "metrics": {
                        "client_id": client_id,
                        "total_letters": 0,
                        "total_cost_cents": 0,
                        "items_disputed": 0,
                        "items_deleted": 0,
                        "items_verified": 0,
                    },
                }
            )

        return jsonify(
            {
                "success": True,
                "metrics": {
                    "client_id": metrics.client_id,
                    "round_0_letters": metrics.round_0_letters,
                    "round_1_letters": metrics.round_1_letters,
                    "round_2_letters": metrics.round_2_letters,
                    "round_3_letters": metrics.round_3_letters,
                    "round_4_letters": metrics.round_4_letters,
                    "total_letters": metrics.total_letters,
                    "mail_cost_cents": metrics.mail_cost_cents,
                    "ai_cost_cents": metrics.ai_cost_cents,
                    "total_cost_cents": metrics.total_cost_cents,
                    "intake_to_analysis_minutes": metrics.intake_to_analysis_minutes,
                    "total_va_minutes": metrics.total_va_minutes,
                    "items_disputed": metrics.items_disputed,
                    "items_deleted": metrics.items_deleted,
                    "items_verified": metrics.items_verified,
                    "reinsertion_count": metrics.reinsertion_count,
                    "resolved_round": metrics.resolved_round,
                    "final_status": metrics.final_status,
                    "settlement_amount_cents": metrics.settlement_amount_cents,
                    "created_at": (
                        metrics.created_at.isoformat() if metrics.created_at else None
                    ),
                    "updated_at": (
                        metrics.updated_at.isoformat() if metrics.updated_at else None
                    ),
                },
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/automation/install-triggers", methods=["POST"])
@require_staff(roles=["admin"])
def api_automation_install_triggers():
    """Install automation workflow triggers - admin only"""
    from services.workflow_triggers_service import install_automation_triggers

    db = get_db()
    try:
        created_count = install_automation_triggers(db)

        return jsonify(
            {
                "success": True,
                "message": f"Successfully installed {created_count} automation triggers",
                "created_count": created_count,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/automation/sftp-status")
@require_staff()
def api_automation_sftp_status():
    """Check SFTP connection status to SendCertifiedMail.com"""
    import os

    from services.sendcertified_sftp_service import get_sftp_connection

    try:
        # Try to establish connection
        sftp, transport = get_sftp_connection()

        # Get connection details
        host = os.environ.get("SENDCERTIFIED_SFTP_HOST", "Not configured")

        # Close connection
        if sftp:
            sftp.close()
        if transport:
            transport.close()

        return jsonify(
            {
                "success": True,
                "connected": True,
                "host": host,
                "message": "SFTP connection successful",
            }
        )
    except Exception as e:
        return (
            jsonify(
                {
                    "success": False,
                    "connected": False,
                    "error": str(e),
                    "message": "SFTP connection failed",
                }
            ),
            200,
        )  # Return 200 to allow frontend to handle gracefully


# VA LETTER APPROVAL API ROUTES
# ============================================================


@app.route("/api/va/pending-letters")
@require_staff()
def api_va_pending_letters():
    """Get all pending VA dispute letters ready for approval"""
    from database import Client, DisputeLetter

    db = get_db()
    try:
        # Query letters that are ready but not yet sent
        letters = (
            db.query(DisputeLetter)
            .filter(
                DisputeLetter.sent_via_letterstream == False,
                DisputeLetter.file_path.isnot(None),  # Has PDF generated
            )
            .order_by(DisputeLetter.created_at.desc())
            .all()
        )

        letter_data = []
        for letter in letters:
            # Get client info
            client = db.query(Client).filter_by(id=letter.client_id).first()

            letter_data.append(
                {
                    "id": letter.id,
                    "client_id": letter.client_id,
                    "client_name": (
                        f"{client.first_name} {client.last_name}"
                        if client
                        else "Unknown"
                    ),
                    "bureau": letter.bureau,
                    "round_number": letter.round_number or 0,
                    "letter_type": letter.letter_type or "Dispute Letter",
                    "created_at": (
                        letter.created_at.isoformat() if letter.created_at else None
                    ),
                    "file_path": letter.file_path,
                }
            )

        return jsonify(
            {
                "success": True,
                "letters": letter_data,
                "total_count": len(letter_data),
                "estimated_cost_cents": len(letter_data) * 1100,
                "estimated_cost_dollars": len(letter_data) * 11,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/va/approve-batch", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def api_va_approve_batch():
    """Approve batch of VA letters and send via SFTP"""
    from services.sendcertified_sftp_service import send_letter_batch

    data = request.json
    letter_ids = data.get("letter_ids", [])

    if not letter_ids:
        return jsonify({"success": False, "error": "No letter_ids provided"}), 400

    db = get_db()
    try:
        # Send batch via SFTP
        result = send_letter_batch(db, letter_ids)

        return jsonify(
            {
                "success": True,
                "approved_count": result["letter_count"],
                "batch_id": result["batch_id"],
                "cost_cents": result["cost_cents"],
                "cost_dollars": result["cost_cents"] / 100,
                "deadline_ids": result["deadline_ids"],
                "sent_at": result["sent_at"],
                "message": f"Successfully approved and queued {result['letter_count']} letters for delivery",
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/admin/validate-lrm-csv", methods=["POST"])
@require_staff(roles=["admin"])
def api_validate_lrm_csv():
    """Validate LRM CSV before import (Admin only)"""
    from services.lrm_import_service import validate_lrm_csv

    data = request.json
    csv_path = data.get("csv_path", "/mnt/user-data/uploads/contacts__1_.csv")

    try:
        validation = validate_lrm_csv(csv_path)
        return jsonify({"success": True, "validation": validation})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/admin/import-lrm-clients", methods=["POST"])
@require_staff(roles=["admin"])
def api_import_lrm_clients():
    """Import clients from LRM CSV (Admin only)"""
    from services.lrm_import_service import import_lrm_contacts

    data = request.json
    csv_path = data.get("csv_path", "/mnt/user-data/uploads/contacts__1_.csv")

    try:
        # Run import
        stats = import_lrm_contacts(csv_path)

        return jsonify(
            {
                "success": True,
                "stats": {
                    "total": stats["total"],
                    "imported": stats["imported"],
                    "skipped": stats["skipped"],
                    "errors": stats["errors"],
                },
                "error_details": (
                    stats["error_details"][:10]
                    if len(stats["error_details"]) > 10
                    else stats["error_details"]
                ),  # Limit to first 10 errors
                "message": f"Import complete: {stats['imported']} imported, {stats['skipped']} skipped, {stats['errors']} errors out of {stats['total']} total rows",
            }
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/admin/config-status")
@require_staff(roles=["admin"])
def api_config_status():
    """Get configuration status for all services (Admin only)"""
    return jsonify(
        {
            "success": True,
            "environment": config.ENV,
            "is_production": config.IS_PRODUCTION,
            "services": config.get_status(),
            "log_level": config.LOG_LEVEL,
        }
    )


# =============================================================================
# CLIENT MANAGER - Bulk and Individual Round/Analysis Management
# =============================================================================


@app.route("/dashboard/client-manager")
@require_staff(roles=["admin", "paralegal"])
def dashboard_client_manager():
    """Client manager for bulk and individual round/analysis management"""
    db = get_db()
    try:
        # Pagination parameters
        page = int(request.args.get("page", 1))
        per_page = int(request.args.get("per_page", 25))

        # Validate per_page
        if per_page not in [10, 25, 50, 100]:
            per_page = 25

        # Get total count
        total_clients = db.query(Client).count()
        total_pages = (total_clients + per_page - 1) // per_page

        # Get paginated clients with their latest analysis info
        clients = (
            db.query(Client)
            .order_by(Client.name)
            .offset((page - 1) * per_page)
            .limit(per_page)
            .all()
        )

        # Get all tags for the tag selector
        all_tags = db.query(ClientTag).order_by(ClientTag.name).all()

        client_data = []
        for client in clients:
            # Get latest analysis for this client
            latest_analysis = (
                db.query(Analysis)
                .filter_by(client_id=client.id)
                .order_by(Analysis.created_at.desc())
                .first()
            )
            # Get credit report count
            report_count = db.query(CreditReport).filter_by(client_id=client.id).count()
            # Get analysis count
            analysis_count = db.query(Analysis).filter_by(client_id=client.id).count()
            # Get client's tags
            tag_assignments = (
                db.query(ClientTagAssignment).filter_by(client_id=client.id).all()
            )
            tag_ids = [a.tag_id for a in tag_assignments]
            client_tags = (
                db.query(ClientTag).filter(ClientTag.id.in_(tag_ids)).all()
                if tag_ids
                else []
            )

            client_data.append(
                {
                    "id": client.id,
                    "name": client.name,
                    "email": client.email,
                    "phone": client.phone,
                    "current_round": client.current_dispute_round or 0,
                    "dispute_status": client.dispute_status or "new",
                    "round_started_at": (
                        client.round_started_at.strftime("%Y-%m-%d")
                        if client.round_started_at
                        else None
                    ),
                    "report_count": report_count,
                    "analysis_count": analysis_count,
                    "latest_analysis_id": (
                        latest_analysis.id if latest_analysis else None
                    ),
                    "latest_analysis_stage": (
                        latest_analysis.stage if latest_analysis else None
                    ),
                    "latest_analysis_round": (
                        latest_analysis.dispute_round if latest_analysis else None
                    ),
                    "created_at": (
                        client.created_at.strftime("%Y-%m-%d")
                        if client.created_at
                        else None
                    ),
                    # Phase 8: Additional fields for BAG CRM parity
                    "status_2": client.status_2 or "",
                    "client_type": client.client_type or "L",
                    "phone_verified": client.phone_verified or False,
                    "is_affiliate": client.is_affiliate or False,
                    "starred": client.starred or False,
                    "mark_1": client.mark_1 or False,
                    "mark_2": client.mark_2 or False,
                    "portal_posted": client.portal_posted or False,
                    "employer_company": client.employer_company or "",
                    "follow_up_date": (
                        client.follow_up_date.strftime("%Y-%m-%d")
                        if client.follow_up_date
                        else None
                    ),
                    "tags": [
                        {"id": t.id, "name": t.name, "color": t.color}
                        for t in client_tags
                    ],
                }
            )

        return render_template(
            "client_manager.html",
            clients=client_data,
            active_page="client-manager",
            page=page,
            per_page=per_page,
            total_clients=total_clients,
            total_pages=total_pages,
            all_tags=[{"id": t.id, "name": t.name, "color": t.color} for t in all_tags],
        )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return f"Error: {str(e)}", 500
    finally:
        db.close()


@app.route("/api/client-manager/set-round", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def api_client_manager_set_round():
    """Set dispute round for a single client"""
    db = get_db()
    try:
        data = request.json
        client_id = data.get("client_id")
        new_round = data.get("round", 0)

        if client_id is None:
            return jsonify({"success": False, "error": "client_id is required"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        old_round = client.current_dispute_round or 0
        old_status = client.dispute_status
        client.current_dispute_round = new_round
        client.dispute_status = "active" if new_round > 0 else "new"
        client.round_started_at = datetime.utcnow() if new_round > 0 else None

        db.commit()

        # Fire status_changed trigger if status changed
        if old_status != client.dispute_status:
            try:
                WorkflowTriggersService.evaluate_triggers(
                    "status_changed",
                    {
                        "client_id": client.id,
                        "client_name": client.name,
                        "old_status": old_status,
                        "new_status": client.dispute_status,
                    },
                )
            except Exception as trigger_error:
                print(f"‚ö†Ô∏è  Workflow trigger error (non-fatal): {trigger_error}")

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "client_name": client.name,
                "old_round": old_round,
                "new_round": new_round,
                "message": f"Set {client.name} to Round {new_round}",
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/bulk-set-round", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def api_client_manager_bulk_set_round():
    """Set dispute round for multiple clients"""
    db = get_db()
    try:
        data = request.json
        client_ids = data.get("client_ids", [])
        new_round = data.get("round", 0)

        if not client_ids:
            return jsonify({"success": False, "error": "client_ids is required"}), 400

        updated = []
        errors = []

        status_changes = []  # Track status changes for triggers
        for client_id in client_ids:
            try:
                client = db.query(Client).filter_by(id=client_id).first()
                if client:
                    old_round = client.current_dispute_round or 0
                    old_status = client.dispute_status
                    client.current_dispute_round = new_round
                    client.dispute_status = "active" if new_round > 0 else "new"
                    client.round_started_at = (
                        datetime.utcnow() if new_round > 0 else None
                    )
                    updated.append(
                        {"id": client_id, "name": client.name, "old_round": old_round}
                    )
                    # Track for trigger firing after commit
                    if old_status != client.dispute_status:
                        status_changes.append(
                            {
                                "client_id": client.id,
                                "client_name": client.name,
                                "old_status": old_status,
                                "new_status": client.dispute_status,
                            }
                        )
                else:
                    errors.append({"id": client_id, "error": "Client not found"})
            except Exception as e:
                errors.append({"id": client_id, "error": str(e)})

        db.commit()

        # Fire status_changed triggers after commit
        for change in status_changes:
            try:
                WorkflowTriggersService.evaluate_triggers("status_changed", change)
            except Exception as trigger_error:
                print(f"‚ö†Ô∏è  Workflow trigger error (non-fatal): {trigger_error}")

        return jsonify(
            {
                "success": True,
                "updated_count": len(updated),
                "error_count": len(errors),
                "new_round": new_round,
                "updated": updated,
                "errors": errors,
                "message": f"Updated {len(updated)} clients to Round {new_round}",
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/run-analysis", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def api_client_manager_run_analysis():
    """Run analysis for a client using their latest credit report"""
    db = get_db()
    try:
        data = request.json
        client_id = data.get("client_id")
        dispute_round = data.get("round", 1)

        if not client_id:
            return jsonify({"success": False, "error": "client_id is required"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Get latest credit report for this client
        credit_report = (
            db.query(CreditReport)
            .filter_by(client_id=client_id)
            .order_by(CreditReport.created_at.desc())
            .first()
        )
        if not credit_report:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "No credit report found for this client. Please import a credit report first.",
                    }
                ),
                400,
            )

        if not credit_report.report_html:
            return (
                jsonify(
                    {"success": False, "error": "Credit report has no HTML content"}
                ),
                400,
            )

        # Create new analysis
        analysis = Analysis(
            credit_report_id=credit_report.id,
            client_id=client_id,
            client_name=client.name,
            dispute_round=dispute_round,
            analysis_mode="manual",
            stage=0,
        )
        db.add(analysis)
        db.commit()
        analysis_id = analysis.id

        # Update client round
        client.current_dispute_round = dispute_round
        client.dispute_status = "active"
        client.round_started_at = datetime.utcnow()
        db.commit()

        # Run Stage 1 analysis
        try:
            # Clean the HTML
            cleaned_html = clean_credit_report_html(credit_report.report_html)

            # Run stage 1 analysis
            # Signature: run_stage1_for_all_sections(client_name, cmm_id, provider, credit_report_text, analysis_mode, dispute_round, ...)
            stage1_result = run_stage1_for_all_sections(
                client_name=client.name,
                cmm_id=None,
                provider=credit_report.credit_provider or "Unknown",
                credit_report_text=cleaned_html,
                analysis_mode="manual",
                dispute_round=dispute_round,
            )

            # Update analysis with results
            analysis.stage_1_analysis = (
                json.dumps(stage1_result)
                if isinstance(stage1_result, dict)
                else stage1_result
            )
            analysis.stage = 1
            db.commit()

            # Update lead score after analysis
            try:
                from services.lead_scoring_service import score_client

                score_result = score_client(client_id)
                if score_result.get("success"):
                    print(
                        f"‚úÖ Lead score updated: {client.name} = {score_result.get('score')} ({score_result.get('priority')})"
                    )
            except Exception as score_error:
                print(f"‚ö†Ô∏è Lead scoring failed: {score_error}")

            return jsonify(
                {
                    "success": True,
                    "analysis_id": analysis_id,
                    "client_id": client_id,
                    "client_name": client.name,
                    "dispute_round": dispute_round,
                    "review_url": f"/analysis/{analysis_id}/review",
                    "message": f"Analysis started for {client.name} - Round {dispute_round}",
                }
            )
        except Exception as analysis_error:
            # Analysis failed but record was created
            return (
                jsonify(
                    {
                        "success": False,
                        "error": f"Analysis failed: {str(analysis_error)}",
                        "analysis_id": analysis_id,
                        "client_id": client_id,
                    }
                ),
                500,
            )

    except Exception as e:
        db.rollback()
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/bulk-run-analysis", methods=["POST"])
@require_staff(roles=["admin", "paralegal"])
def api_client_manager_bulk_run_analysis():
    """Queue bulk analysis for multiple clients"""
    db = get_db()
    try:
        data = request.json
        client_ids = data.get("client_ids", [])
        dispute_round = data.get("round", 1)

        if not client_ids:
            return jsonify({"success": False, "error": "client_ids is required"}), 400

        queued = []
        errors = []

        for client_id in client_ids:
            try:
                client = db.query(Client).filter_by(id=client_id).first()
                if not client:
                    errors.append({"id": client_id, "error": "Client not found"})
                    continue

                credit_report = (
                    db.query(CreditReport)
                    .filter_by(client_id=client_id)
                    .order_by(CreditReport.created_at.desc())
                    .first()
                )
                if not credit_report or not credit_report.report_html:
                    errors.append(
                        {
                            "id": client_id,
                            "name": client.name,
                            "error": "No credit report with HTML",
                        }
                    )
                    continue

                # Create analysis record (will be processed)
                analysis = Analysis(
                    credit_report_id=credit_report.id,
                    client_id=client_id,
                    client_name=client.name,
                    dispute_round=dispute_round,
                    analysis_mode="manual",
                    stage=0,
                )
                db.add(analysis)
                db.flush()

                # Update client round
                client.current_dispute_round = dispute_round
                client.dispute_status = "active"
                client.round_started_at = datetime.utcnow()

                queued.append(
                    {
                        "client_id": client_id,
                        "client_name": client.name,
                        "analysis_id": analysis.id,
                    }
                )
            except Exception as e:
                errors.append({"id": client_id, "error": str(e)})

        db.commit()

        return jsonify(
            {
                "success": True,
                "queued_count": len(queued),
                "error_count": len(errors),
                "dispute_round": dispute_round,
                "queued": queued,
                "errors": errors,
                "message": f"Queued {len(queued)} analyses for Round {dispute_round}. Run each individually to process.",
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/client/<int:client_id>/details")
@require_staff(roles=["admin", "paralegal", "attorney", "viewer"])
def api_client_manager_details(client_id):
    """Get detailed info for a single client"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Get all credit reports
        reports = (
            db.query(CreditReport)
            .filter_by(client_id=client_id)
            .order_by(CreditReport.created_at.desc())
            .all()
        )

        # Get all analyses
        analyses = (
            db.query(Analysis)
            .filter_by(client_id=client_id)
            .order_by(Analysis.created_at.desc())
            .all()
        )

        return jsonify(
            {
                "success": True,
                "client": {
                    "id": client.id,
                    "name": client.name,
                    "email": client.email,
                    "current_round": client.current_dispute_round or 0,
                    "dispute_status": client.dispute_status or "new",
                    "round_started_at": (
                        client.round_started_at.isoformat()
                        if client.round_started_at
                        else None
                    ),
                    "created_at": (
                        client.created_at.isoformat() if client.created_at else None
                    ),
                },
                "reports": [
                    {
                        "id": r.id,
                        "provider": r.credit_provider,
                        "date": r.report_date.isoformat() if r.report_date else None,
                        "created_at": (
                            r.created_at.isoformat() if r.created_at else None
                        ),
                        "has_html": bool(r.report_html),
                    }
                    for r in reports
                ],
                "analyses": [
                    {
                        "id": a.id,
                        "round": a.dispute_round,
                        "stage": a.stage,
                        "approved": bool(a.approved_at),
                        "approved_at": (
                            a.approved_at.isoformat() if a.approved_at else None
                        ),
                        "created_at": (
                            a.created_at.isoformat() if a.created_at else None
                        ),
                        "review_url": f"/analysis/{a.id}/review",
                    }
                    for a in analyses
                ],
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/delete-client", methods=["POST"])
@require_staff(roles=["admin"])
def api_client_manager_delete_client():
    """Delete a client and all associated data (Admin only)"""
    db = get_db()
    try:
        data = request.json
        client_id = data.get("client_id")

        if not client_id:
            return jsonify({"success": False, "error": "client_id is required"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        client_name = client.name

        # Delete associated records
        db.query(Violation).filter_by(client_id=client_id).delete()
        db.query(DisputeLetter).filter_by(client_id=client_id).delete()
        db.query(Analysis).filter_by(client_id=client_id).delete()
        db.query(CreditReport).filter_by(client_id=client_id).delete()
        db.query(Client).filter_by(id=client_id).delete()

        db.commit()

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "client_name": client_name,
                "message": f"Deleted client {client_name} and all associated data",
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ============================================================================
# CLIENT MANAGER - DOCUMENT UPLOAD ENDPOINTS
# ============================================================================


@app.route("/api/client-manager/upload-cra-response", methods=["POST"])
@require_staff()
def api_client_manager_upload_cra_response():
    """Upload a CRA response document for a client"""
    db = get_db()
    try:
        client_id = request.form.get("client_id")
        bureau = request.form.get("bureau")
        dispute_round = request.form.get("dispute_round", 1)
        response_type = request.form.get("response_type", "verified")
        response_date = request.form.get("response_date")

        if not client_id:
            return jsonify({"success": False, "error": "client_id is required"}), 400

        if "file" not in request.files:
            return jsonify({"success": False, "error": "No file uploaded"}), 400

        file = request.files["file"]
        if file.filename == "":
            return jsonify({"success": False, "error": "No file selected"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Create client-specific directory
        upload_dir = os.path.join("uploads", "cra_responses", str(client_id))
        os.makedirs(upload_dir, exist_ok=True)

        # Generate safe filename
        from werkzeug.utils import secure_filename

        original_filename = secure_filename(file.filename)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{bureau}_{dispute_round}_{timestamp}_{original_filename}"
        file_path = os.path.join(upload_dir, filename)

        # Save file
        file.save(file_path)
        file_size = os.path.getsize(file_path)

        # Create CRA response record
        cra_response = CRAResponse(
            client_id=int(client_id),
            bureau=bureau,
            dispute_round=int(dispute_round),
            response_type=response_type,
            response_date=(
                datetime.strptime(response_date, "%Y-%m-%d").date()
                if response_date
                else None
            ),
            received_date=datetime.now().date(),
            file_path=file_path,
            file_name=original_filename,
            file_size=file_size,
            uploaded_by_admin=True,
        )
        db.add(cra_response)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Uploaded CRA response from {bureau} for round {dispute_round}",
                "response_id": cra_response.id,
                "file_path": file_path,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/upload-letter-sent", methods=["POST"])
@require_staff()
def api_client_manager_upload_letter_sent():
    """Upload a copy of a dispute letter that was sent"""
    db = get_db()
    try:
        client_id = request.form.get("client_id")
        bureau = request.form.get("bureau")
        dispute_round = request.form.get("dispute_round", 1)
        sent_date = request.form.get("sent_date")
        letter_type = request.form.get(
            "letter_type", "dispute"
        )  # dispute, validation, intent_to_sue, etc.

        if not client_id:
            return jsonify({"success": False, "error": "client_id is required"}), 400

        if "file" not in request.files:
            return jsonify({"success": False, "error": "No file uploaded"}), 400

        file = request.files["file"]
        if file.filename == "":
            return jsonify({"success": False, "error": "No file selected"}), 400

        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Create client-specific directory
        upload_dir = os.path.join("uploads", "letters_sent", str(client_id))
        os.makedirs(upload_dir, exist_ok=True)

        # Generate safe filename
        from werkzeug.utils import secure_filename

        original_filename = secure_filename(file.filename)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = (
            f"{bureau}_{letter_type}_{dispute_round}_{timestamp}_{original_filename}"
        )
        file_path = os.path.join(upload_dir, filename)

        # Save file
        file.save(file_path)
        file_size = os.path.getsize(file_path)

        # Use ClientUpload model for manual letter uploads
        client_upload = ClientUpload(
            client_id=int(client_id),
            category="letter_sent",
            document_type=letter_type,
            bureau=bureau,
            dispute_round=int(dispute_round),
            file_path=file_path,
            file_name=original_filename,
            file_size=file_size,
            file_type=os.path.splitext(original_filename)[1].lower(),
            document_date=(
                datetime.strptime(sent_date, "%Y-%m-%d").date() if sent_date else None
            ),
            uploaded_at=datetime.now(),
        )
        db.add(client_upload)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Uploaded letter sent to {bureau} for round {dispute_round}",
                "upload_id": client_upload.id,
                "file_path": file_path,
            }
        )
    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/client/<int:client_id>/uploads")
@require_staff()
def api_client_manager_get_uploads(client_id):
    """Get all uploads (CRA responses and letters sent) for a client"""
    db = get_db()
    try:
        client = db.query(Client).filter_by(id=client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Get CRA responses
        cra_responses = (
            db.query(CRAResponse)
            .filter_by(client_id=client_id)
            .order_by(CRAResponse.received_date.desc())
            .all()
        )

        # Get letters sent from ClientUpload (manual uploads)
        letters_sent = (
            db.query(ClientUpload)
            .filter_by(client_id=client_id, category="letter_sent")
            .order_by(ClientUpload.uploaded_at.desc())
            .all()
        )

        return jsonify(
            {
                "success": True,
                "client_id": client_id,
                "client_name": client.name,
                "cra_responses": [
                    {
                        "id": r.id,
                        "bureau": r.bureau,
                        "dispute_round": r.dispute_round,
                        "response_type": r.response_type,
                        "response_date": (
                            r.response_date.isoformat() if r.response_date else None
                        ),
                        "received_date": (
                            r.received_date.isoformat() if r.received_date else None
                        ),
                        "file_name": r.file_name,
                        "file_path": r.file_path,
                    }
                    for r in cra_responses
                ],
                "letters_sent": [
                    {
                        "id": l.id,
                        "bureau": l.bureau,
                        "round_number": l.dispute_round,
                        "letter_type": l.document_type,
                        "sent_at": (
                            l.document_date.isoformat()
                            if l.document_date
                            else l.uploaded_at.isoformat() if l.uploaded_at else None
                        ),
                        "file_path": l.file_path,
                        "file_name": l.file_name,
                    }
                    for l in letters_sent
                ],
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/client-manager/download/<path:file_path>")
@require_staff()
def api_client_manager_download_file(file_path):
    """Download an uploaded file"""
    from flask import send_file

    # Security check - ensure path is within uploads directory
    full_path = os.path.abspath(file_path)
    uploads_dir = os.path.abspath("uploads")

    if not full_path.startswith(uploads_dir):
        return jsonify({"success": False, "error": "Invalid file path"}), 403

    if not os.path.exists(full_path):
        return jsonify({"success": False, "error": "File not found"}), 404

    return send_file(full_path, as_attachment=True)


# ============================================================
# LEAD CAPTURE ROUTES (Public Landing Pages)
# ============================================================


@app.route("/get-started")
def get_started():
    """Lead capture landing page for prospective clients"""
    # Check for whitelabel branding
    whitelabel_branding = None
    try:
        db = get_db()
        if request.host:
            from services.whitelabel import get_white_label_service

            wl_service = get_white_label_service(db)
            tenant = wl_service.get_tenant_by_domain(request.host)
            if tenant:
                whitelabel_branding = wl_service.get_branding_for_tenant(tenant.id)
        db.close()
    except Exception:
        pass

    # Get calendly URL from config if set
    calendly_url = getattr(config, "CALENDLY_URL", "")

    return render_template(
        "get_started.html",
        whitelabel_branding=whitelabel_branding,
        calendly_url=calendly_url,
    )


@app.route("/affiliate/signup")
def affiliate_signup():
    """Affiliate signup redirect - sends to credit monitoring affiliate link"""
    # Default affiliate links (can be configured per tenant)
    affiliate_links = {
        "identityiq": "https://www.identityiq.com/sc-enrollment.aspx?offercode=431291KD",
        "myscoreiq": "https://www.myscoreiq.com/",
        "smartcredit": "https://www.smartcredit.com/",
    }

    # Default to IdentityIQ (highest commission usually)
    default_link = affiliate_links.get("identityiq", "https://www.identityiq.com/")

    return redirect(default_link)


@app.route("/api/leads/capture", methods=["POST"])
def api_leads_capture():
    """Capture a lead from the get-started form and optionally pull their credit report"""
    db = get_db()
    try:
        data = request.get_json() or {}

        # Validate required fields
        first_name = data.get("first_name", "").strip()
        last_name = data.get("last_name", "").strip()
        email = data.get("email", "").strip()

        if not first_name or not last_name:
            return (
                jsonify(
                    {"success": False, "error": "First and last name are required"}
                ),
                400,
            )

        if not email:
            return (
                jsonify({"success": False, "error": "Email address is required"}),
                400,
            )

        # Check if client already exists
        existing = db.query(Client).filter_by(email=email).first()

        if existing:
            # Update existing client info
            client = existing
            client.first_name = first_name
            client.last_name = last_name
            client.name = f"{first_name} {last_name}"
        else:
            # Create new client as a lead
            client = Client(
                name=f"{first_name} {last_name}",
                first_name=first_name,
                last_name=last_name,
                email=email,
                phone=data.get("phone", "").strip() or None,
                address_street=data.get("address", "").strip() or None,
                address_city=data.get("city", "").strip() or None,
                address_state=data.get("state", "").strip() or None,
                address_zip=data.get("zip", "").strip() or None,
                dispute_status="lead",  # Mark as lead, not active client
                current_dispute_round=0,
                sms_opt_in=data.get("sms_opt_in", False),
                email_opt_in=data.get("email_opt_in", True),
            )
            db.add(client)

        # Store credit monitoring info if provided
        monitoring_service = data.get("monitoring_service", "").strip()
        if monitoring_service and monitoring_service not in ["none", ""]:
            client.credit_monitoring_service = monitoring_service

            monitoring_username = data.get("monitoring_username", "").strip()
            monitoring_password = data.get("monitoring_password", "").strip()
            ssn_last_four = data.get("ssn_last_four", "").strip()

            if monitoring_username:
                client.credit_monitoring_username = monitoring_username

            if monitoring_password:
                # Encrypt password before storing
                try:
                    from services.encryption import encryption_service

                    encrypted = encryption_service.encrypt(monitoring_password)
                    client.credit_monitoring_password_encrypted = encrypted
                except Exception:
                    # Store as-is if encryption fails (dev mode)
                    client.credit_monitoring_password_encrypted = monitoring_password

            # Store SSN last 4 for identity verification
            if ssn_last_four and len(ssn_last_four) == 4 and ssn_last_four.isdigit():
                client.ssn_last_four = ssn_last_four

        # Generate free analysis token if not exists
        if not client.free_analysis_token:
            client.free_analysis_token = secrets.token_urlsafe(32)

        # Set client stage
        if not client.client_stage or client.client_stage == "lead":
            client.client_stage = "lead"

        db.commit()
        db.refresh(client)

        # Log new client creation (not updates to existing)
        if not existing:
            log_client_created(client.id, client.name)

        # Try to pull credit report if credentials provided
        preview_data = None
        monitoring_username = data.get("monitoring_username", "").strip()
        monitoring_password = data.get("monitoring_password", "").strip()
        ssn_last_four = data.get("ssn_last_four", "").strip()

        if (
            monitoring_service
            and monitoring_service not in ["none", ""]
            and monitoring_username
            and monitoring_password
        ):
            try:
                import asyncio

                from services.credit_import_automation import CreditImportAutomation

                # Map service names to the format expected by automation
                service_map = {
                    "identityiq": "IdentityIQ.com",
                    "myscoreiq": "MyScoreIQ.com",
                    "smartcredit": "SmartCredit.com",
                    "myfreescorenow": "MyFreeScoreNow.com",
                    "privacyguard": "PrivacyGuard.com",
                }
                service_key = service_map.get(
                    monitoring_service.lower().replace(".com", "").replace(" ", ""),
                    monitoring_service,
                )

                # Run the async import
                async def do_import():
                    automation = CreditImportAutomation()
                    try:
                        result = await automation.import_report(
                            service_name=service_key,
                            username=monitoring_username,
                            password=monitoring_password,
                            ssn_last4=ssn_last_four or "",
                            client_id=client.id,
                            client_name=client.name,
                        )
                        return result
                    finally:
                        await automation._close_browser()

                # Run async function
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                try:
                    import_result = loop.run_until_complete(do_import())
                finally:
                    loop.close()

                if import_result and import_result.get("success"):
                    scores = import_result.get("scores", {})
                    preview_data = {
                        "bureau": "TransUnion",
                        "score": scores.get("transunion", scores.get("tu", "---")),
                        "negative_items": import_result.get("negative_count", "--"),
                        "total_accounts": import_result.get("account_count", "--"),
                        "equifax_score": scores.get("equifax", scores.get("eq", "---")),
                        "experian_score": scores.get(
                            "experian", scores.get("ex", "---")
                        ),
                        "report_path": import_result.get("report_path"),
                    }

                    # Update client with report info
                    if import_result.get("report_path"):
                        client.last_report_path = import_result.get("report_path")
                        client.last_report_date = datetime.utcnow()
                        db.commit()
                else:
                    # Import failed - return placeholder with error note
                    preview_data = {
                        "bureau": "TransUnion",
                        "score": "---",
                        "negative_items": "--",
                        "total_accounts": "--",
                        "error": import_result.get("error", "Could not pull report"),
                    }

            except Exception as e:
                print(f"Credit import error: {e}")
                import traceback

                traceback.print_exc()
                # Return placeholder on error
                preview_data = {
                    "bureau": "TransUnion",
                    "score": "---",
                    "negative_items": "--",
                    "total_accounts": "--",
                    "error": str(e),
                }

        return jsonify(
            {
                "success": True,
                "message": "Thank you! We've received your information.",
                "client_id": client.id,
                "analysis_token": client.free_analysis_token,
                "analysis_url": f"/analysis/{client.free_analysis_token}",
                "preview": preview_data,
            }
        )

    except Exception as e:
        db.rollback()
        print(f"Lead capture error: {e}")
        return (
            jsonify(
                {"success": False, "error": "An error occurred. Please try again."}
            ),
            500,
        )
    finally:
        db.close()


@app.route("/upload-report")
def upload_report():
    """Simple report upload page - minimal form for quick lead capture"""
    return render_template("upload_report.html")


@app.route("/api/leads/upload-report", methods=["POST"])
def api_leads_upload_report():
    """Handle simple report upload from leads - minimal info required"""
    db = get_db()
    try:
        from werkzeug.utils import secure_filename

        from services.workflow_triggers_service import trigger_event

        name = request.form.get("name", "").strip()
        email = request.form.get("email", "").strip().lower()
        file = request.files.get("report")

        # Validate required fields
        if not name:
            return jsonify({"success": False, "error": "Name is required"}), 400
        if not email:
            return jsonify({"success": False, "error": "Email is required"}), 400
        if not file or not file.filename:
            return (
                jsonify({"success": False, "error": "Please upload a credit report"}),
                400,
            )

        # Validate file type
        allowed_extensions = {"pdf", "jpg", "jpeg", "png"}
        ext = file.filename.rsplit(".", 1)[-1].lower() if "." in file.filename else ""
        if ext not in allowed_extensions:
            return (
                jsonify({"success": False, "error": "File must be PDF, JPG, or PNG"}),
                400,
            )

        # Split name into first/last
        name_parts = name.split(" ", 1)
        first_name = name_parts[0]
        last_name = name_parts[1] if len(name_parts) > 1 else ""

        # Check if client already exists
        existing = db.query(Client).filter_by(email=email).first()

        if existing:
            client = existing
            # Update name if not already set
            if not client.first_name:
                client.first_name = first_name
            if not client.last_name:
                client.last_name = last_name
            if not client.name:
                client.name = name
        else:
            # Create new client as a lead
            client = Client(
                name=name,
                first_name=first_name,
                last_name=last_name,
                email=email,
                dispute_status="report_uploaded",
                current_dispute_round=0,
                email_opt_in=True,
            )
            db.add(client)
            db.flush()  # Get client ID

        # Save the uploaded file
        filename = secure_filename(file.filename)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        final_filename = f"report_{timestamp}_{filename}"

        upload_dir = os.path.join("static", "client_uploads", str(client.id), "reports")
        os.makedirs(upload_dir, exist_ok=True)
        file_path = os.path.join(upload_dir, final_filename)
        file.save(file_path)

        # Create upload record
        try:
            upload = ClientUpload(
                client_id=client.id,
                document_type="credit_report",
                file_name=filename,
                file_path=file_path,
                file_size=os.path.getsize(file_path),
                category="credit_report",
                notes="Uploaded via simple upload form",
            )
            db.add(upload)
        except Exception as e:
            print(f"Upload record error: {e}")

        db.commit()

        # Send confirmation email
        try:
            from services.email_service import send_email

            send_email(
                to_email=email,
                subject="We've Received Your Credit Report - Brightpath Ascend",
                html_content=f"""
                <h2>Thank you, {first_name}!</h2>
                <p>We've received your credit report and our team will analyze it shortly.</p>
                <p>You can expect to hear from us within 24 hours with your free credit analysis.</p>
                <p>In the meantime, feel free to:</p>
                <ul>
                    <li><a href="https://brightpathascend.com/get-started">Complete your profile</a> for faster processing</li>
                    <li>Reply to this email with any questions</li>
                </ul>
                <p>Best regards,<br>The Brightpath Ascend Team</p>
                """,
            )
        except Exception as e:
            print(f"Confirmation email error: {e}")

        # Trigger workflow event for staff notification
        try:
            trigger_event(
                "document_uploaded",
                {
                    "client_id": client.id,
                    "document_type": "credit_report",
                    "file_name": filename,
                    "source": "simple_upload_form",
                },
            )
        except Exception as e:
            print(f"Trigger error: {e}")

        return jsonify(
            {
                "success": True,
                "message": "Report uploaded successfully",
                "client_id": client.id,
            }
        )

    except Exception as e:
        db.rollback()
        print(f"Report upload error: {e}")
        return (
            jsonify(
                {"success": False, "error": "An error occurred. Please try again."}
            ),
            500,
        )
    finally:
        db.close()


# =============================================================================
# FREE ANALYSIS FLOW - Teaser ‚Üí Purchase ‚Üí Full Analysis
# =============================================================================


@app.route("/analysis/<token>")
def view_free_analysis(token):
    """View the free teaser analysis page (no login required)"""
    from services.free_analysis_service import get_free_analysis_service

    db = get_db()
    try:
        service = get_free_analysis_service(db)
        result = service.get_teaser_analysis(token)

        if not result.get("success"):
            return (
                render_template(
                    "error.html",
                    error="Analysis not found",
                    message="This analysis link is invalid or has expired.",
                ),
                404,
            )

        return render_template(
            "free_analysis.html",
            token=token,
            client_name=result.get("client_name", "there"),
            client_stage=result.get("client_stage", "lead"),
            analysis_paid=result.get("analysis_paid", False),
            teaser=result.get("teaser", {}),
        )
    finally:
        db.close()


@app.route("/analysis/<token>/purchase", methods=["GET", "POST"])
def purchase_full_analysis(token):
    """Purchase the full $199 analysis"""
    db = get_db()
    try:
        # Find client by token
        client = db.query(Client).filter(Client.free_analysis_token == token).first()

        if not client:
            return (
                render_template(
                    "error.html",
                    error="Analysis not found",
                    message="This analysis link is invalid or has expired.",
                ),
                404,
            )

        # Check if already paid
        if client.client_stage in [
            "analysis_paid",
            "onboarding",
            "pending_payment",
            "active",
        ]:
            return redirect(f"/analysis/{token}")

        if request.method == "GET":
            # Show payment page
            return render_template(
                "analysis_purchase.html",
                token=token,
                client_name=client.first_name or client.name.split()[0],
                price=199,
                stripe_publishable_key=getattr(config, "STRIPE_PUBLISHABLE_KEY", ""),
            )

        # POST - Process payment
        from services.stripe_client import stripe_client

        try:
            # Create Stripe payment intent for $199
            payment_intent = stripe_client.create_payment_intent(
                amount=19900,  # $199 in cents
                customer_email=client.email,
                metadata={
                    "client_id": client.id,
                    "type": "full_analysis",
                    "token": token,
                },
            )

            return jsonify(
                {"success": True, "client_secret": payment_intent.client_secret}
            )

        except Exception as e:
            print(f"Stripe error: {e}")
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Payment processing failed. Please try again.",
                    }
                ),
                500,
            )

    finally:
        db.close()


@app.route("/api/analysis/confirm-payment", methods=["POST"])
def confirm_analysis_payment():
    """Confirm payment and unlock full analysis"""
    from services.free_analysis_service import get_free_analysis_service

    db = get_db()
    try:
        data = request.get_json() or {}
        token = data.get("token")
        payment_intent_id = data.get("payment_intent_id")

        if not token or not payment_intent_id:
            return (
                jsonify({"success": False, "error": "Missing payment information"}),
                400,
            )

        # Find client
        client = db.query(Client).filter(Client.free_analysis_token == token).first()

        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Mark analysis as paid
        service = get_free_analysis_service(db)
        result = service.mark_analysis_paid(client.id, payment_intent_id)

        if result.get("success"):
            return jsonify(
                {
                    "success": True,
                    "message": "Payment confirmed! Your full analysis is now available.",
                    "redirect_url": f"/analysis/{token}",
                }
            )
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": result.get("error", "Failed to confirm payment"),
                    }
                ),
                500,
            )

    except Exception as e:
        print(f"Payment confirmation error: {e}")
        return (
            jsonify(
                {"success": False, "error": "An error occurred confirming payment"}
            ),
            500,
        )
    finally:
        db.close()


@app.route("/analysis/<token>/proceed", methods=["POST"])
def proceed_to_program(token):
    """Move from analysis_paid to onboarding (ready to start program)"""
    from services.free_analysis_service import get_free_analysis_service

    db = get_db()
    try:
        client = db.query(Client).filter(Client.free_analysis_token == token).first()

        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if client.client_stage != "analysis_paid":
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Please purchase the full analysis first",
                    }
                ),
                400,
            )

        service = get_free_analysis_service(db)
        result = service.proceed_to_onboarding(client.id)

        if result.get("success"):
            # Generate portal password reset link if no password set
            if not client.portal_password_hash:
                client.password_reset_token = secrets.token_urlsafe(32)
                client.password_reset_expires = datetime.utcnow() + timedelta(days=7)
                db.commit()

                return jsonify(
                    {
                        "success": True,
                        "message": "Welcome to the program!",
                        "redirect_url": f"/portal/login?token={client.password_reset_token}",
                    }
                )

            return jsonify(
                {
                    "success": True,
                    "message": "Welcome to the program!",
                    "redirect_url": "/portal/onboarding",
                }
            )
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": result.get("error", "Failed to proceed"),
                    }
                ),
                500,
            )

    finally:
        db.close()


# =============================================================================
# ROUND PAYMENT SYSTEM - Charge per round when letters are sent
# =============================================================================


@app.route("/api/clients/<int:client_id>/payment/round", methods=["POST"])
@require_staff()
def api_create_round_payment(client_id):
    """
    Create a payment intent for a dispute round.
    Staff calls this before sending letters.
    """
    from services.client_payment_service import get_client_payment_service

    db = get_db()
    try:
        data = request.get_json() or {}
        round_number = data.get("round_number")

        service = get_client_payment_service(db)
        result = service.create_round_payment_intent(client_id, round_number)

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/payment/round/confirm", methods=["POST"])
@require_staff()
def api_confirm_round_payment(client_id):
    """
    Confirm a round payment was successful.
    Enables letter sending for that round.
    """
    from services.client_payment_service import get_client_payment_service

    db = get_db()
    try:
        data = request.get_json() or {}
        payment_intent_id = data.get("payment_intent_id")
        round_number = data.get("round_number")

        if not payment_intent_id or not round_number:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Missing payment_intent_id or round_number",
                    }
                ),
                400,
            )

        service = get_client_payment_service(db)
        result = service.confirm_round_payment(
            client_id, payment_intent_id, round_number
        )

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/payment/charge-round", methods=["POST"])
@require_staff()
def api_charge_for_round(client_id):
    """
    Charge a client for a round using saved payment method.
    Called by staff when ready to send letters.
    """
    from services.client_payment_service import get_client_payment_service

    db = get_db()
    try:
        data = request.get_json() or {}
        round_number = data.get("round_number")
        payment_method_id = data.get("payment_method_id")

        if not round_number:
            return jsonify({"success": False, "error": "Round number required"}), 400

        service = get_client_payment_service(db)
        result = service.charge_for_round(client_id, round_number, payment_method_id)

        if result.get("success"):
            return jsonify(result)
        else:
            status_code = 400 if result.get("requires_payment") else 500
            return jsonify(result), status_code
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/payment/summary", methods=["GET"])
@require_staff()
def api_get_payment_summary(client_id):
    """Get payment summary for a client."""
    from services.client_payment_service import get_client_payment_service

    db = get_db()
    try:
        service = get_client_payment_service(db)
        result = service.get_payment_summary(client_id)

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/payment/prepay", methods=["POST"])
@require_staff()
def api_create_prepay_checkout(client_id):
    """
    Create a checkout session for a prepay package.
    """
    from services.client_payment_service import get_client_payment_service

    db = get_db()
    try:
        data = request.get_json() or {}
        package_key = data.get("package")
        financed = data.get("financed", False)
        success_url = data.get("success_url")
        cancel_url = data.get("cancel_url")

        if not package_key:
            return jsonify({"success": False, "error": "Package required"}), 400

        service = get_client_payment_service(db)
        result = service.create_prepay_checkout(
            client_id, package_key, financed, success_url, cancel_url
        )

        if result.get("success"):
            return jsonify(result)
        else:
            return jsonify(result), 400
    finally:
        db.close()


@app.route("/api/settlement-fee/calculate", methods=["POST"])
@require_staff()
def api_calculate_settlement_fee():
    """Calculate the settlement fee for a given amount."""
    from services.client_payment_service import get_client_payment_service

    db = get_db()
    try:
        data = request.get_json() or {}
        settlement_amount = data.get("settlement_amount")

        if not settlement_amount:
            return (
                jsonify({"success": False, "error": "Settlement amount required"}),
                400,
            )

        # Convert to cents if provided in dollars
        if isinstance(settlement_amount, float) or settlement_amount < 1000:
            settlement_amount = int(settlement_amount * 100)

        service = get_client_payment_service(db)
        result = service.calculate_settlement_fee(settlement_amount)
        result["success"] = True

        return jsonify(result)
    finally:
        db.close()


# =============================================================================
# SCHEDULED JOBS - Auto-capture, reminders, etc.
# =============================================================================


@app.route("/api/jobs/capture-due-payments", methods=["POST"])
@require_staff()
def api_run_capture_due_payments():
    """
    Run the capture_due_payments job.
    Activates clients whose 3-day cancellation period has ended.
    """
    from services.scheduled_jobs_service import get_scheduled_jobs_service

    db = get_db()
    try:
        service = get_scheduled_jobs_service(db)
        result = service.capture_due_payments()
        return jsonify(result)
    finally:
        db.close()


@app.route("/api/jobs/expire-stale-holds", methods=["POST"])
@require_staff()
def api_run_expire_stale_holds():
    """
    Run the expire_stale_holds job.
    Cancels clients stuck in onboarding for too long.
    """
    from services.scheduled_jobs_service import get_scheduled_jobs_service

    db = get_db()
    try:
        data = request.get_json() or {}
        days_old = data.get("days_old", 7)

        service = get_scheduled_jobs_service(db)
        result = service.expire_stale_holds(days_old)
        return jsonify(result)
    finally:
        db.close()


@app.route("/api/jobs/send-reminders", methods=["POST"])
@require_staff()
def api_run_send_reminders():
    """
    Run the send_payment_reminders job.
    Sends emails for upcoming and failed payments.
    """
    from services.scheduled_jobs_service import get_scheduled_jobs_service

    db = get_db()
    try:
        service = get_scheduled_jobs_service(db)
        result = service.send_payment_reminders()
        return jsonify(result)
    finally:
        db.close()


@app.route("/api/jobs/pending-activations", methods=["GET"])
@require_staff()
def api_get_pending_activations():
    """
    Get clients ready for activation (cancellation period ended).
    """
    from services.scheduled_jobs_service import get_scheduled_jobs_service

    db = get_db()
    try:
        service = get_scheduled_jobs_service(db)
        result = service.get_pending_activations()
        return jsonify(result)
    finally:
        db.close()


@app.route("/api/jobs/run-all", methods=["POST"])
@require_staff()
def api_run_all_jobs():
    """
    Run all scheduled jobs at once.
    Useful for manual trigger from staff dashboard.
    """
    from services.scheduled_jobs_service import get_scheduled_jobs_service

    db = get_db()
    try:
        service = get_scheduled_jobs_service(db)
        result = service.run_all_jobs()
        return jsonify(result)
    finally:
        db.close()


# =============================================================================
# STRIPE WEBHOOKS - Payment event handlers
# =============================================================================


@app.route("/api/webhooks/stripe", methods=["POST"])
def stripe_webhook_handler():
    """
    Handle Stripe webhook events for Client Journey workflow.

    Events handled:
    - payment_intent.succeeded
    - payment_intent.payment_failed
    - charge.refunded
    - checkout.session.completed
    """
    from services.stripe_webhooks_service import get_stripe_webhooks_service

    payload = request.get_data()
    sig_header = request.headers.get("Stripe-Signature")

    db = get_db()
    try:
        # Verify webhook signature (if configured)
        try:
            from services.stripe_client import (
                get_webhook_secret,
                verify_webhook_signature,
            )

            webhook_secret = get_webhook_secret()
            if webhook_secret:
                event = verify_webhook_signature(payload, sig_header, webhook_secret)
            else:
                # No webhook secret - parse without verification (dev mode)
                import json

                event = json.loads(payload)
        except Exception as e:
            print(f"Webhook signature verification failed: {e}")
            # In development, still process the event
            import json

            event = json.loads(payload)

        # Process the event
        service = get_stripe_webhooks_service(db)
        result = service.handle_event(event)

        return jsonify(result), 200

    except Exception as e:
        print(f"Webhook error: {e}")
        return jsonify({"error": str(e)}), 400
    finally:
        db.close()


# =============================================================================
# AFFIRM BNPL - Buy Now Pay Later Integration
# =============================================================================


@app.route("/api/payment/affirm/create", methods=["POST"])
@require_staff()
def affirm_create_checkout():
    """
    Create an Affirm checkout session.

    Request body:
    {
        "client_id": 123,
        "amount_cents": 49700,  // $497.00
        "description": "Credit Restoration - Round 1",
        "success_url": "https://example.com/payment/success",
        "cancel_url": "https://example.com/payment/cancel"
    }
    """
    from services.affirm_service import AffirmError, get_affirm_service

    data = request.get_json() or {}

    required_fields = [
        "client_id",
        "amount_cents",
        "description",
        "success_url",
        "cancel_url",
    ]
    for field in required_fields:
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}"}), 400

    db = get_db()
    try:
        # Get client for prefill data
        client = db.query(Client).filter(Client.id == data["client_id"]).first()
        if not client:
            return jsonify({"error": "Client not found"}), 404

        service = get_affirm_service()

        if not service.is_configured():
            return jsonify({"error": "Affirm is not configured"}), 503

        result = service.create_checkout(
            client_id=data["client_id"],
            amount_cents=data["amount_cents"],
            description=data["description"],
            success_url=data["success_url"],
            cancel_url=data["cancel_url"],
            client_email=client.email,
            client_name=client.name,
            client_phone=client.phone,
            metadata={
                "service": "fcra_credit_restoration",
                "round": data.get("round", 1),
            },
        )

        # Store checkout token on client
        client.affirm_checkout_token = result.get("checkout_token")
        client.affirm_status = "pending"
        db.commit()

        return jsonify(result)

    except AffirmError as e:
        return jsonify({"error": str(e), "code": e.error_code}), 400
    except Exception as e:
        print(f"Affirm checkout error: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/payment/affirm/confirm", methods=["POST"])
@require_staff()
def affirm_confirm_payment():
    """
    Confirm an Affirm payment after client approval.

    Called when client is redirected back from Affirm with checkout_token.

    Request body:
    {
        "client_id": 123,
        "checkout_token": "token_from_affirm_redirect"
    }
    """
    from services.affirm_service import AffirmError, get_affirm_service

    data = request.get_json() or {}

    if "checkout_token" not in data:
        return jsonify({"error": "Missing checkout_token"}), 400
    if "client_id" not in data:
        return jsonify({"error": "Missing client_id"}), 400

    db = get_db()
    try:
        client = db.query(Client).filter(Client.id == data["client_id"]).first()
        if not client:
            return jsonify({"error": "Client not found"}), 404

        service = get_affirm_service()

        # Authorize the charge
        auth_result = service.authorize_charge(
            checkout_token=data["checkout_token"], order_id=f"client_{client.id}"
        )

        # Immediately capture (or delay for manual review)
        capture_result = service.capture_charge(auth_result["charge_id"])

        # Update client record
        client.affirm_charge_id = capture_result["charge_id"]
        client.affirm_status = "captured"
        client.payment_status = "paid"
        client.payment_method = "affirm"
        client.payment_received_at = datetime.utcnow()

        # Update total paid
        amount_cents = auth_result.get("amount", 0)
        client.total_paid = (client.total_paid or 0) + amount_cents

        db.commit()

        return jsonify(
            {
                "success": True,
                "charge_id": capture_result["charge_id"],
                "status": capture_result["status"],
                "amount_cents": amount_cents,
            }
        )

    except AffirmError as e:
        # Update client status on failure
        if "client_id" in data:
            client = db.query(Client).filter(Client.id == data["client_id"]).first()
            if client:
                client.affirm_status = "failed"
                db.commit()
        return jsonify({"error": str(e), "code": e.error_code}), 400
    except Exception as e:
        print(f"Affirm confirm error: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/payment/affirm/status/<int:client_id>", methods=["GET"])
@require_staff()
def affirm_get_status(client_id):
    """Get Affirm payment status for a client."""
    from services.affirm_service import AffirmError, get_affirm_service

    db = get_db()
    try:
        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"error": "Client not found"}), 404

        result = {
            "client_id": client_id,
            "affirm_status": client.affirm_status,
            "affirm_charge_id": client.affirm_charge_id,
        }

        # If we have a charge ID, get current status from Affirm
        if client.affirm_charge_id:
            service = get_affirm_service()
            if service.is_configured():
                try:
                    charge = service.get_charge(client.affirm_charge_id)
                    result["affirm_details"] = charge
                except AffirmError:
                    pass  # Ignore errors fetching details

        return jsonify(result)

    except Exception as e:
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/payment/affirm/refund", methods=["POST"])
@require_staff()
def affirm_refund():
    """
    Refund an Affirm payment.

    Request body:
    {
        "client_id": 123,
        "amount_cents": null  // null for full refund, or specific amount
    }
    """
    from services.affirm_service import AffirmError, get_affirm_service

    data = request.get_json() or {}

    if "client_id" not in data:
        return jsonify({"error": "Missing client_id"}), 400

    db = get_db()
    try:
        client = db.query(Client).filter(Client.id == data["client_id"]).first()
        if not client:
            return jsonify({"error": "Client not found"}), 404

        if not client.affirm_charge_id:
            return jsonify({"error": "No Affirm charge found for this client"}), 400

        service = get_affirm_service()
        result = service.refund_charge(
            charge_id=client.affirm_charge_id, amount_cents=data.get("amount_cents")
        )

        # Update client status
        client.affirm_status = "refunded"
        client.payment_status = "refunded"
        db.commit()

        return jsonify(result)

    except AffirmError as e:
        return jsonify({"error": str(e), "code": e.error_code}), 400
    except Exception as e:
        print(f"Affirm refund error: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/payment/affirm/estimate", methods=["GET"])
def affirm_estimate():
    """
    Get monthly payment estimates for Affirm financing.

    Query params:
    - amount_cents: Total amount in cents (required)
    - months: Financing term (optional, default 12)
    """
    from services.affirm_service import get_affirm_service

    amount_cents = request.args.get("amount_cents", type=int)
    months = request.args.get("months", 12, type=int)

    if not amount_cents:
        return jsonify({"error": "Missing amount_cents parameter"}), 400

    if months not in [3, 6, 12]:
        return jsonify({"error": "months must be 3, 6, or 12"}), 400

    service = get_affirm_service()
    result = service.get_monthly_payment(amount_cents, months)

    return jsonify(result)


@app.route("/api/webhooks/affirm", methods=["POST"])
def affirm_webhook_handler():
    """
    Handle Affirm webhook events.

    Events handled:
    - charge.created
    - charge.captured
    - charge.voided
    - charge.refunded
    - charge.failed
    """
    from services.affirm_service import AffirmError, get_affirm_service

    payload = request.get_data()
    signature = request.headers.get("X-Affirm-Signature")

    try:
        service = get_affirm_service()

        # Verify signature (optional in sandbox)
        if service.environment == "production":
            if not service.verify_webhook_signature(payload, signature):
                return jsonify({"error": "Invalid signature"}), 401

        # Parse event
        event_data = request.get_json()
        event_type = event_data.get("type", "")

        # Process webhook
        result = service.handle_webhook(event_type, event_data)

        # Update client record if charge ID is present
        charge_id = event_data.get("id") or event_data.get("charge_id")
        if charge_id:
            db = get_db()
            try:
                client = (
                    db.query(Client)
                    .filter(Client.affirm_charge_id == charge_id)
                    .first()
                )
                if client:
                    # Map event type to status
                    status_map = {
                        "charge.created": "authorized",
                        "charge.captured": "captured",
                        "charge.voided": "voided",
                        "charge.refunded": "refunded",
                        "charge.failed": "failed",
                    }
                    new_status = status_map.get(event_type)
                    if new_status:
                        client.affirm_status = new_status
                        if new_status == "captured":
                            client.payment_status = "paid"
                        elif new_status in ["voided", "refunded"]:
                            client.payment_status = new_status
                        elif new_status == "failed":
                            client.payment_status = "failed"
                        db.commit()
            finally:
                db.close()

        return jsonify(result), 200

    except Exception as e:
        print(f"Affirm webhook error: {e}")
        return jsonify({"error": str(e)}), 400


# =============================================================================
# CRON ENDPOINT - For external schedulers (Replit, Railway, etc.)
# =============================================================================


@app.route("/api/cron/hourly", methods=["POST", "GET"])
def cron_hourly():
    """
    Hourly cron endpoint for external schedulers.
    Runs: capture_due_payments

    Secured by CRON_SECRET environment variable.
    """
    from services.scheduled_jobs_service import get_scheduled_jobs_service

    # Verify cron secret
    cron_secret = os.environ.get("CRON_SECRET")
    provided_secret = request.headers.get("X-Cron-Secret") or request.args.get("secret")

    if cron_secret and provided_secret != cron_secret:
        return jsonify({"error": "Unauthorized"}), 401

    db = get_db()
    try:
        service = get_scheduled_jobs_service(db)
        result = service.capture_due_payments()
        return jsonify(result)
    finally:
        db.close()


@app.route("/api/cron/daily", methods=["POST", "GET"])
def cron_daily():
    """
    Daily cron endpoint for external schedulers.
    Runs: expire_stale_holds, send_payment_reminders

    Secured by CRON_SECRET environment variable.
    """
    from services.scheduled_jobs_service import get_scheduled_jobs_service

    # Verify cron secret
    cron_secret = os.environ.get("CRON_SECRET")
    provided_secret = request.headers.get("X-Cron-Secret") or request.args.get("secret")

    if cron_secret and provided_secret != cron_secret:
        return jsonify({"error": "Unauthorized"}), 401

    db = get_db()
    try:
        service = get_scheduled_jobs_service(db)
        results = {
            "expire_stale_holds": service.expire_stale_holds(),
            "send_payment_reminders": service.send_payment_reminders(),
        }
        return jsonify(
            {"success": True, "run_at": datetime.utcnow().isoformat(), "jobs": results}
        )
    finally:
        db.close()


# =============================================================================
# BOOKING SYSTEM - Q&A Call Scheduling
# =============================================================================


@app.route("/api/booking-slots", methods=["GET"])
@require_staff()
def api_get_booking_slots():
    """Get all booking slots (staff view)"""
    db = get_db()
    try:
        from datetime import date, timedelta

        from database import Booking, BookingSlot, Client

        # Parse filters
        start_date = request.args.get("start_date")
        end_date = request.args.get("end_date")
        show_booked = request.args.get("show_booked", "true").lower() == "true"

        query = db.query(BookingSlot)

        # Default to next 30 days if no date range specified
        if not start_date:
            start_date = date.today()
        else:
            start_date = datetime.strptime(start_date, "%Y-%m-%d").date()

        if not end_date:
            end_date = start_date + timedelta(days=30)
        else:
            end_date = datetime.strptime(end_date, "%Y-%m-%d").date()

        query = query.filter(
            BookingSlot.slot_date >= start_date, BookingSlot.slot_date <= end_date
        )

        if not show_booked:
            query = query.filter(BookingSlot.is_booked == False)

        slots = query.order_by(BookingSlot.slot_date, BookingSlot.slot_time).all()

        result = []
        for slot in slots:
            slot_data = {
                "id": slot.id,
                "date": slot.slot_date.isoformat(),
                "time": slot.slot_time.strftime("%H:%M"),
                "duration": slot.duration_minutes,
                "is_available": slot.is_available,
                "is_booked": slot.is_booked,
                "booking": None,
            }

            if slot.is_booked and slot.booking:
                client = (
                    db.query(Client).filter(Client.id == slot.booking.client_id).first()
                )
                slot_data["booking"] = {
                    "id": slot.booking.id,
                    "client_id": slot.booking.client_id,
                    "client_name": client.name if client else "Unknown",
                    "client_email": client.email if client else "",
                    "notes": slot.booking.notes,
                    "status": slot.booking.status,
                }

            result.append(slot_data)

        return jsonify({"success": True, "slots": result})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/booking-slots", methods=["POST"])
@require_staff()
def api_create_booking_slots():
    """Create booking slots (bulk create by staff)"""
    db = get_db()
    try:
        from datetime import time, timedelta

        from database import BookingSlot

        data = request.get_json()

        # Support single slot or bulk creation
        if "slots" in data:
            # Bulk create: list of {date, time} objects
            slots_data = data["slots"]
        elif "start_date" in data and "end_date" in data:
            # Generate slots for date range
            start_date = datetime.strptime(data["start_date"], "%Y-%m-%d").date()
            end_date = datetime.strptime(data["end_date"], "%Y-%m-%d").date()
            start_time = datetime.strptime(
                data.get("start_time", "09:00"), "%H:%M"
            ).time()
            end_time = datetime.strptime(data.get("end_time", "17:00"), "%H:%M").time()
            days_of_week = data.get("days_of_week", [0, 1, 2, 3, 4])  # Mon-Fri default

            slots_data = []
            current_date = start_date
            while current_date <= end_date:
                if current_date.weekday() in days_of_week:
                    current_time = datetime.combine(current_date, start_time)
                    end_datetime = datetime.combine(current_date, end_time)

                    while current_time < end_datetime:
                        slots_data.append(
                            {
                                "date": current_date.isoformat(),
                                "time": current_time.strftime("%H:%M"),
                            }
                        )
                        current_time += timedelta(minutes=15)

                current_date += timedelta(days=1)
        else:
            # Single slot
            slots_data = [{"date": data["date"], "time": data["time"]}]

        created_count = 0
        staff_id = session.get("staff_id")

        for slot_data in slots_data:
            slot_date = datetime.strptime(slot_data["date"], "%Y-%m-%d").date()
            slot_time = datetime.strptime(slot_data["time"], "%H:%M").time()

            # Check for existing slot at same date/time
            existing = (
                db.query(BookingSlot)
                .filter(
                    BookingSlot.slot_date == slot_date,
                    BookingSlot.slot_time == slot_time,
                )
                .first()
            )

            if not existing:
                slot = BookingSlot(
                    slot_date=slot_date,
                    slot_time=slot_time,
                    duration_minutes=15,
                    is_available=True,
                    is_booked=False,
                    staff_id=staff_id,
                )
                db.add(slot)
                created_count += 1

        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Created {created_count} booking slots",
                "created_count": created_count,
            }
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/booking-slots/<int:slot_id>", methods=["PUT"])
@require_staff()
def api_update_booking_slot(slot_id):
    """Update a booking slot (toggle availability)"""
    db = get_db()
    try:
        from database import BookingSlot

        slot = db.query(BookingSlot).filter(BookingSlot.id == slot_id).first()
        if not slot:
            return jsonify({"success": False, "error": "Slot not found"}), 404

        data = request.get_json()

        if "is_available" in data:
            slot.is_available = data["is_available"]

        slot.updated_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": "Slot updated",
                "slot": {
                    "id": slot.id,
                    "is_available": slot.is_available,
                    "is_booked": slot.is_booked,
                },
            }
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/booking-slots/<int:slot_id>", methods=["DELETE"])
@require_staff()
def api_delete_booking_slot(slot_id):
    """Delete a booking slot (only if not booked)"""
    db = get_db()
    try:
        from database import BookingSlot

        slot = db.query(BookingSlot).filter(BookingSlot.id == slot_id).first()
        if not slot:
            return jsonify({"success": False, "error": "Slot not found"}), 404

        if slot.is_booked:
            return (
                jsonify({"success": False, "error": "Cannot delete booked slot"}),
                400,
            )

        db.delete(slot)
        db.commit()

        return jsonify({"success": True, "message": "Slot deleted"})

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==================== Calendar Sync API (P33) ====================


@app.route("/api/calendar/integrations", methods=["GET"])
@require_staff()
def api_get_calendar_integrations():
    """Get all calendar integrations for current staff"""
    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    service = get_calendar_service()
    integrations = service.get_integrations(staff_id)

    return jsonify(
        {
            "success": True,
            "integrations": [
                {
                    "id": i.id,
                    "provider": i.provider,
                    "calendar_id": i.calendar_id,
                    "calendar_name": i.calendar_name,
                    "sync_enabled": i.sync_enabled,
                    "sync_direction": i.sync_direction,
                    "check_free_busy": i.check_free_busy,
                    "is_active": i.is_active,
                    "connected_at": (
                        i.connected_at.isoformat() if i.connected_at else None
                    ),
                    "last_sync_at": (
                        i.last_sync_at.isoformat() if i.last_sync_at else None
                    ),
                    "last_sync_status": i.last_sync_status,
                }
                for i in integrations
            ],
        }
    )


@app.route("/api/calendar/stats", methods=["GET"])
@require_staff()
def api_get_calendar_stats():
    """Get calendar sync statistics"""
    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    service = get_calendar_service()
    stats = service.get_sync_stats(staff_id)

    return jsonify({"success": True, "stats": stats})


@app.route("/api/calendar/google/auth", methods=["GET"])
@require_staff()
def api_google_calendar_auth():
    """Get Google Calendar OAuth URL"""
    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    service = get_calendar_service()

    try:
        auth_url = service.get_google_auth_url(staff_id)
        return jsonify({"success": True, "auth_url": auth_url})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400


@app.route("/api/calendar/google/callback", methods=["GET"])
def api_google_calendar_callback():
    """Handle Google Calendar OAuth callback"""
    from services.calendar_sync_service import get_calendar_service

    code = request.args.get("code")
    state = request.args.get("state")  # Contains staff_id
    error = request.args.get("error")

    if error:
        return redirect(f"/dashboard/settings?calendar_error={error}")

    if not code or not state:
        return redirect("/dashboard/settings?calendar_error=missing_params")

    try:
        staff_id = int(state)
        service = get_calendar_service()
        service.exchange_google_code(code, staff_id)
        return redirect("/dashboard/settings?calendar_connected=google")
    except Exception as e:
        logger.error(f"Google Calendar callback error: {e}")
        return redirect(f"/dashboard/settings?calendar_error={str(e)[:100]}")


@app.route("/api/calendar/outlook/auth", methods=["GET"])
@require_staff()
def api_outlook_calendar_auth():
    """Get Outlook Calendar OAuth URL"""
    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    service = get_calendar_service()

    try:
        auth_url = service.get_outlook_auth_url(staff_id)
        return jsonify({"success": True, "auth_url": auth_url})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400


@app.route("/api/calendar/outlook/callback", methods=["GET"])
def api_outlook_calendar_callback():
    """Handle Outlook Calendar OAuth callback"""
    from services.calendar_sync_service import get_calendar_service

    code = request.args.get("code")
    state = request.args.get("state")  # Contains staff_id
    error = request.args.get("error")

    if error:
        return redirect(f"/dashboard/settings?calendar_error={error}")

    if not code or not state:
        return redirect("/dashboard/settings?calendar_error=missing_params")

    try:
        staff_id = int(state)
        service = get_calendar_service()
        service.exchange_outlook_code(code, staff_id)
        return redirect("/dashboard/settings?calendar_connected=outlook")
    except Exception as e:
        logger.error(f"Outlook Calendar callback error: {e}")
        return redirect(f"/dashboard/settings?calendar_error={str(e)[:100]}")


@app.route("/api/calendar/integrations/<int:integration_id>/calendars", methods=["GET"])
@require_staff()
def api_list_calendars(integration_id):
    """List available calendars for an integration"""
    from database import CalendarIntegration
    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    db = get_db()

    try:
        integration = (
            db.query(CalendarIntegration)
            .filter_by(id=integration_id, staff_id=staff_id)
            .first()
        )

        if not integration:
            return jsonify({"success": False, "error": "Integration not found"}), 404

        service = get_calendar_service()
        calendars = service.list_calendars(integration)

        return jsonify({"success": True, "calendars": calendars})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/calendar/integrations/<int:integration_id>/calendar", methods=["PUT"])
@require_staff()
def api_set_calendar(integration_id):
    """Set which calendar to use for sync"""
    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    data = request.json
    calendar_id = data.get("calendar_id")
    calendar_name = data.get("calendar_name")

    if not calendar_id:
        return jsonify({"success": False, "error": "calendar_id required"}), 400

    service = get_calendar_service()
    success = service.set_calendar(integration_id, staff_id, calendar_id, calendar_name)

    if success:
        return jsonify({"success": True, "message": "Calendar updated"})
    return jsonify({"success": False, "error": "Integration not found"}), 404


@app.route("/api/calendar/integrations/<int:integration_id>/settings", methods=["PUT"])
@require_staff()
def api_update_calendar_settings(integration_id):
    """Update calendar sync settings"""
    from database import CalendarIntegration

    staff_id = session.get("staff_id")
    data = request.json
    db = get_db()

    try:
        integration = (
            db.query(CalendarIntegration)
            .filter_by(id=integration_id, staff_id=staff_id)
            .first()
        )

        if not integration:
            return jsonify({"success": False, "error": "Integration not found"}), 404

        if "sync_enabled" in data:
            integration.sync_enabled = data["sync_enabled"]
        if "sync_direction" in data:
            integration.sync_direction = data["sync_direction"]
        if "check_free_busy" in data:
            integration.check_free_busy = data["check_free_busy"]

        db.commit()
        return jsonify({"success": True, "message": "Settings updated"})

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route(
    "/api/calendar/integrations/<int:integration_id>/disconnect", methods=["POST"]
)
@require_staff()
def api_disconnect_calendar(integration_id):
    """Disconnect a calendar integration"""
    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    service = get_calendar_service()
    success = service.disconnect(integration_id, staff_id)

    if success:
        return jsonify({"success": True, "message": "Calendar disconnected"})
    return jsonify({"success": False, "error": "Integration not found"}), 404


@app.route("/api/calendar/free-busy", methods=["GET"])
@require_staff()
def api_get_free_busy():
    """Get free/busy times for a date range"""
    from datetime import datetime

    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    start = request.args.get("start")
    end = request.args.get("end")

    if not start or not end:
        return jsonify({"success": False, "error": "start and end required"}), 400

    try:
        start_time = datetime.fromisoformat(start.replace("Z", "+00:00"))
        end_time = datetime.fromisoformat(end.replace("Z", "+00:00"))
    except ValueError:
        return jsonify({"success": False, "error": "Invalid date format"}), 400

    service = get_calendar_service()
    busy_times = service.get_free_busy(staff_id, start_time, end_time)

    return jsonify({"success": True, "busy_times": busy_times})


@app.route("/api/calendar/check-availability", methods=["POST"])
@require_staff()
def api_check_availability():
    """Check if a specific time slot is available"""
    from datetime import datetime

    from services.calendar_sync_service import get_calendar_service

    staff_id = session.get("staff_id")
    data = request.json
    start = data.get("start")
    end = data.get("end")

    if not start or not end:
        return jsonify({"success": False, "error": "start and end required"}), 400

    try:
        start_time = datetime.fromisoformat(start.replace("Z", "+00:00"))
        end_time = datetime.fromisoformat(end.replace("Z", "+00:00"))
    except ValueError:
        return jsonify({"success": False, "error": "Invalid date format"}), 400

    service = get_calendar_service()
    is_available = service.is_time_available(staff_id, start_time, end_time)

    return jsonify({"success": True, "available": is_available})


@app.route("/api/bookings", methods=["GET"])
@require_staff()
def api_get_bookings():
    """Get all bookings (staff view)"""
    db = get_db()
    try:
        from database import Booking, BookingSlot, Client

        status_filter = request.args.get("status")

        query = db.query(Booking).join(BookingSlot)

        if status_filter:
            query = query.filter(Booking.status == status_filter)

        bookings = query.order_by(
            BookingSlot.slot_date.desc(), BookingSlot.slot_time.desc()
        ).all()

        result = []
        for booking in bookings:
            client = db.query(Client).filter(Client.id == booking.client_id).first()
            result.append(
                {
                    "id": booking.id,
                    "slot": {
                        "id": booking.slot.id,
                        "date": booking.slot.slot_date.isoformat(),
                        "time": booking.slot.slot_time.strftime("%H:%M"),
                        "duration": booking.slot.duration_minutes,
                    },
                    "client": {
                        "id": client.id if client else None,
                        "name": client.name if client else "Unknown",
                        "email": client.email if client else "",
                        "phone": client.phone or client.mobile if client else "",
                    },
                    "booking_type": booking.booking_type,
                    "notes": booking.notes,
                    "status": booking.status,
                    "booked_at": (
                        booking.booked_at.isoformat() if booking.booked_at else None
                    ),
                    "confirmation_sent": booking.confirmation_sent,
                }
            )

        return jsonify({"success": True, "bookings": result})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/bookings/<int:booking_id>/status", methods=["PUT"])
@require_staff()
def api_update_booking_status(booking_id):
    """Update booking status (complete, no_show, etc.)"""
    db = get_db()
    try:
        from database import Booking

        booking = db.query(Booking).filter(Booking.id == booking_id).first()
        if not booking:
            return jsonify({"success": False, "error": "Booking not found"}), 404

        data = request.get_json()
        new_status = data.get("status")

        if new_status not in ["confirmed", "cancelled", "completed", "no_show"]:
            return jsonify({"success": False, "error": "Invalid status"}), 400

        booking.status = new_status

        if new_status == "completed":
            booking.completed_at = datetime.utcnow()
        elif new_status == "cancelled":
            booking.cancelled_at = datetime.utcnow()
            # Free up the slot
            booking.slot.is_booked = False
            # Delete from calendar
            try:
                from services.calendar_sync_service import get_calendar_service

                calendar_service = get_calendar_service()
                calendar_service.delete_calendar_event(booking.id)
            except Exception as e:
                logger.warning(f"Calendar event deletion failed: {e}")

        booking.updated_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": f"Booking marked as {new_status}",
                "status": new_status,
            }
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# Portal Booking Endpoints (for clients)


@app.route("/api/portal/booking-slots", methods=["GET"])
def api_portal_get_available_slots():
    """Get available booking slots for clients to book"""
    db = get_db()
    try:
        from datetime import date, timedelta

        from database import BookingSlot

        # Only show slots in the next 14 days
        start_date = date.today()
        end_date = start_date + timedelta(days=14)

        slots = (
            db.query(BookingSlot)
            .filter(
                BookingSlot.slot_date >= start_date,
                BookingSlot.slot_date <= end_date,
                BookingSlot.is_available == True,
                BookingSlot.is_booked == False,
            )
            .order_by(BookingSlot.slot_date, BookingSlot.slot_time)
            .all()
        )

        # Group by date for easier UI display
        slots_by_date = {}
        for slot in slots:
            date_str = slot.slot_date.isoformat()
            if date_str not in slots_by_date:
                slots_by_date[date_str] = {
                    "date": date_str,
                    "day_name": slot.slot_date.strftime("%A"),
                    "slots": [],
                }
            slots_by_date[date_str]["slots"].append(
                {
                    "id": slot.id,
                    "time": slot.slot_time.strftime("%H:%M"),
                    "time_display": slot.slot_time.strftime("%I:%M %p"),
                    "duration": slot.duration_minutes,
                }
            )

        return jsonify({"success": True, "dates": list(slots_by_date.values())})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/bookings", methods=["POST"])
def api_portal_create_booking():
    """Create a booking (client books a slot)"""
    db = get_db()
    try:
        from database import Booking, BookingSlot, Client
        from services.email_service import send_email

        # Get client from session
        client_id = session.get("portal_client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Please log in to book"}), 401

        data = request.get_json()
        slot_id = data.get("slot_id")
        notes = data.get("notes", "").strip()

        if not slot_id:
            return (
                jsonify({"success": False, "error": "Please select a time slot"}),
                400,
            )

        # Check slot is available
        slot = db.query(BookingSlot).filter(BookingSlot.id == slot_id).first()
        if not slot:
            return jsonify({"success": False, "error": "Time slot not found"}), 404

        if not slot.is_available or slot.is_booked:
            return (
                jsonify(
                    {"success": False, "error": "This time slot is no longer available"}
                ),
                400,
            )

        # Create booking
        booking = Booking(
            slot_id=slot_id,
            client_id=client_id,
            booking_type="qa_call",
            notes=notes,
            status="confirmed",
            booked_at=datetime.utcnow(),
        )
        db.add(booking)

        # Mark slot as booked
        slot.is_booked = True

        db.commit()
        db.refresh(booking)

        # Sync to staff's calendar if connected
        try:
            from services.calendar_sync_service import get_calendar_service

            calendar_service = get_calendar_service()
            calendar_service.sync_booking_to_calendar(booking)
        except Exception as e:
            logger.warning(f"Calendar sync failed for booking {booking.id}: {e}")

        # Get client info for confirmation email
        client = db.query(Client).filter(Client.id == client_id).first()

        # Send confirmation email
        if client and client.email:
            try:
                html_content = f"""
                <h2>Booking Confirmed!</h2>
                <p>Hi {client.name},</p>
                <p>Your Q&A call has been scheduled:</p>
                <ul>
                    <li><strong>Date:</strong> {slot.slot_date.strftime('%A, %B %d, %Y')}</li>
                    <li><strong>Time:</strong> {slot.slot_time.strftime('%I:%M %p')}</li>
                    <li><strong>Duration:</strong> 15 minutes</li>
                </ul>
                <p>We'll call you at the phone number on file. Please have any questions ready!</p>
                <p>If you need to reschedule, please log into your portal.</p>
                <p>Thank you,<br>Brightpath Ascend Team</p>
                """
                result = send_email(
                    to_email=client.email,
                    subject="Q&A Call Confirmed - Brightpath Ascend",
                    html_content=html_content,
                )
                if result.get("success"):
                    booking.confirmation_sent = True
                    booking.confirmation_sent_at = datetime.utcnow()
                    db.commit()
            except Exception as e:
                print(f"Failed to send confirmation email: {e}")

        return jsonify(
            {
                "success": True,
                "message": "Your Q&A call has been scheduled!",
                "booking": {
                    "id": booking.id,
                    "date": slot.slot_date.isoformat(),
                    "time": slot.slot_time.strftime("%I:%M %p"),
                    "duration": slot.duration_minutes,
                },
            }
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/bookings", methods=["GET"])
def api_portal_get_my_bookings():
    """Get client's own bookings"""
    db = get_db()
    try:
        from database import Booking, BookingSlot

        client_id = session.get("portal_client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Please log in"}), 401

        bookings = (
            db.query(Booking)
            .join(BookingSlot)
            .filter(
                Booking.client_id == client_id,
                Booking.status.in_(["confirmed", "completed"]),
            )
            .order_by(BookingSlot.slot_date.desc(), BookingSlot.slot_time.desc())
            .all()
        )

        result = []
        for booking in bookings:
            result.append(
                {
                    "id": booking.id,
                    "date": booking.slot.slot_date.isoformat(),
                    "date_display": booking.slot.slot_date.strftime("%A, %B %d, %Y"),
                    "time": booking.slot.slot_time.strftime("%I:%M %p"),
                    "duration": booking.slot.duration_minutes,
                    "status": booking.status,
                    "notes": booking.notes,
                }
            )

        return jsonify({"success": True, "bookings": result})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/bookings/<int:booking_id>", methods=["DELETE"])
def api_portal_cancel_booking(booking_id):
    """Cancel a booking (client cancels their own booking)"""
    db = get_db()
    try:
        from database import Booking

        client_id = session.get("portal_client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Please log in"}), 401

        booking = (
            db.query(Booking)
            .filter(Booking.id == booking_id, Booking.client_id == client_id)
            .first()
        )

        if not booking:
            return jsonify({"success": False, "error": "Booking not found"}), 404

        if booking.status != "confirmed":
            return (
                jsonify({"success": False, "error": "Cannot cancel this booking"}),
                400,
            )

        # Cancel booking and free up slot
        booking.status = "cancelled"
        booking.cancelled_at = datetime.utcnow()
        booking.slot.is_booked = False

        # Delete from calendar
        try:
            from services.calendar_sync_service import get_calendar_service

            calendar_service = get_calendar_service()
            calendar_service.delete_calendar_event(booking.id)
        except Exception as e:
            logger.warning(f"Calendar event deletion failed: {e}")

        db.commit()

        return jsonify({"success": True, "message": "Booking cancelled successfully"})

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# =============================================================
# CLIENT PORTAL MESSAGING (LIVE SUPPORT)
# =============================================================


@app.route("/api/portal/messages", methods=["GET"])
def api_portal_get_messages():
    """Get all messages for the current client"""
    db = get_db()
    try:
        from database import ClientMessage, Staff

        client_id = session.get("portal_client_id") or session.get("client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Please log in"}), 401

        messages = (
            db.query(ClientMessage)
            .filter(ClientMessage.client_id == client_id)
            .order_by(ClientMessage.created_at.asc())
            .all()
        )

        # Mark unread staff messages as read
        for msg in messages:
            if msg.sender_type == "staff" and not msg.is_read:
                msg.is_read = True
                msg.read_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "messages": [
                    {
                        "id": m.id,
                        "message": m.message,
                        "sender_type": m.sender_type,
                        "is_read": m.is_read,
                        "created_at": (
                            m.created_at.isoformat() if m.created_at else None
                        ),
                        "staff_name": (
                            db.query(Staff).get(m.staff_id).full_name
                            if m.staff_id
                            else None
                        ),
                    }
                    for m in messages
                ],
            }
        )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/messages", methods=["POST"])
def api_portal_send_message():
    """Send a message from the client"""
    db = get_db()
    try:
        from database import ClientMessage

        client_id = session.get("portal_client_id") or session.get("client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Please log in"}), 401

        data = request.get_json() or {}
        message_text = data.get("message", "").strip()

        if not message_text:
            return jsonify({"success": False, "error": "Message is required"}), 400

        if len(message_text) > 5000:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "Message too long (max 5000 characters)",
                    }
                ),
                400,
            )

        message = ClientMessage(
            client_id=client_id,
            message=message_text,
            sender_type="client",
            is_read=False,
        )
        db.add(message)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": {
                    "id": message.id,
                    "message": message.message,
                    "sender_type": message.sender_type,
                    "created_at": (
                        message.created_at.isoformat() if message.created_at else None
                    ),
                },
            }
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/messages/unread-count", methods=["GET"])
def api_portal_unread_count():
    """Get count of unread messages for the client"""
    db = get_db()
    try:
        from database import ClientMessage

        client_id = session.get("portal_client_id") or session.get("client_id")
        if not client_id:
            return jsonify({"success": False, "error": "Please log in"}), 401

        count = (
            db.query(ClientMessage)
            .filter(
                ClientMessage.client_id == client_id,
                ClientMessage.sender_type == "staff",
                ClientMessage.is_read == False,
            )
            .count()
        )

        return jsonify({"success": True, "unread_count": count})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# =============================================================
# STAFF MESSAGING ENDPOINTS
# =============================================================


@app.route("/api/messages/clients", methods=["GET"])
@require_staff()
def api_get_messaging_clients():
    """Get all clients with messages (for staff view)"""
    db = get_db()
    try:
        from database import Client, ClientMessage

        # Get distinct clients with messages
        subq = db.query(ClientMessage.client_id).distinct()
        clients_with_messages = db.query(Client).filter(Client.id.in_(subq)).all()

        result = []
        for client in clients_with_messages:
            # Get latest message and unread count
            latest = (
                db.query(ClientMessage)
                .filter(ClientMessage.client_id == client.id)
                .order_by(ClientMessage.created_at.desc())
                .first()
            )

            unread = (
                db.query(ClientMessage)
                .filter(
                    ClientMessage.client_id == client.id,
                    ClientMessage.sender_type == "client",
                    ClientMessage.is_read == False,
                )
                .count()
            )

            result.append(
                {
                    "client_id": client.id,
                    "client_name": client.name,
                    "client_email": client.email,
                    "latest_message": latest.message[:100] if latest else None,
                    "latest_at": (
                        latest.created_at.isoformat()
                        if latest and latest.created_at
                        else None
                    ),
                    "unread_count": unread,
                }
            )

        # Sort by latest message, unread first
        result.sort(
            key=lambda x: (-(x["unread_count"] or 0), x["latest_at"] or ""),
            reverse=False,
        )

        return jsonify({"success": True, "clients": result})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/messages/client/<int:client_id>", methods=["GET"])
@require_staff()
def api_get_client_messages(client_id):
    """Get all messages for a specific client"""
    db = get_db()
    try:
        from database import ClientMessage, Staff

        messages = (
            db.query(ClientMessage)
            .filter(ClientMessage.client_id == client_id)
            .order_by(ClientMessage.created_at.asc())
            .all()
        )

        # Mark unread client messages as read
        for msg in messages:
            if msg.sender_type == "client" and not msg.is_read:
                msg.is_read = True
                msg.read_at = datetime.utcnow()
        db.commit()

        return jsonify(
            {
                "success": True,
                "messages": [
                    {
                        "id": m.id,
                        "message": m.message,
                        "sender_type": m.sender_type,
                        "is_read": m.is_read,
                        "created_at": (
                            m.created_at.isoformat() if m.created_at else None
                        ),
                        "staff_name": (
                            db.query(Staff).get(m.staff_id).full_name
                            if m.staff_id
                            else None
                        ),
                    }
                    for m in messages
                ],
            }
        )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/messages/client/<int:client_id>", methods=["POST"])
@require_staff()
def api_send_client_message(client_id):
    """Send a message to a client (from staff)"""
    db = get_db()
    try:
        from database import ClientMessage

        staff_id = session.get("staff_id")
        if not staff_id:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        data = request.get_json() or {}
        message_text = data.get("message", "").strip()

        if not message_text:
            return jsonify({"success": False, "error": "Message is required"}), 400

        message = ClientMessage(
            client_id=client_id,
            staff_id=staff_id,
            message=message_text,
            sender_type="staff",
            is_read=False,
        )
        db.add(message)
        db.commit()

        return jsonify(
            {
                "success": True,
                "message": {
                    "id": message.id,
                    "message": message.message,
                    "sender_type": message.sender_type,
                    "created_at": (
                        message.created_at.isoformat() if message.created_at else None
                    ),
                },
            }
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/messages/unread-total", methods=["GET"])
@require_staff()
def api_get_total_unread():
    """Get total unread messages from all clients"""
    db = get_db()
    try:
        from database import ClientMessage

        count = (
            db.query(ClientMessage)
            .filter(
                ClientMessage.sender_type == "client", ClientMessage.is_read == False
            )
            .count()
        )

        return jsonify({"success": True, "unread_count": count})

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# =============================================================================
# AI CHAT SUPPORT - Staff endpoints for escalated conversations
# =============================================================================


@app.route("/api/chat/escalated", methods=["GET"])
@require_staff()
def api_get_escalated_chats():
    """Get all escalated chat conversations for staff dashboard"""
    db = get_db()
    try:
        from services.chat_service import get_chat_service

        staff_id = session.get("staff_id")
        # Pass staff_id to filter by assigned, or None for all escalated
        filter_assigned = request.args.get("assigned", "false").lower() == "true"

        service = get_chat_service(db)
        result = service.get_escalated_conversations(
            staff_id=staff_id if filter_assigned else None
        )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/chat/conversation/<int:conversation_id>", methods=["GET"])
@require_staff()
def api_staff_get_conversation(conversation_id):
    """Get a conversation (staff can view any conversation)"""
    db = get_db()
    try:
        from services.chat_service import get_chat_service

        service = get_chat_service(db)
        result = service.get_conversation(conversation_id=conversation_id)

        if not result.get("success"):
            return (
                jsonify({"error": result.get("error", "Conversation not found")}),
                404,
            )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/chat/conversation/<int:conversation_id>/respond", methods=["POST"])
@require_staff()
def api_staff_respond_chat(conversation_id):
    """Staff responds to an escalated conversation"""
    db = get_db()
    try:
        from services.chat_service import get_chat_service

        staff_id = session.get("staff_id")
        if not staff_id:
            return jsonify({"success": False, "error": "Not authenticated"}), 401

        data = request.get_json() or {}
        message = data.get("message", "").strip()

        if not message:
            return jsonify({"success": False, "error": "message is required"}), 400

        service = get_chat_service(db)
        result = service.staff_respond(
            conversation_id=conversation_id, staff_id=staff_id, message=message
        )

        if not result.get("success"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": result.get("error", "Failed to send response"),
                    }
                ),
                400,
            )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/chat/conversation/<int:conversation_id>/close", methods=["POST"])
@require_staff()
def api_staff_close_chat(conversation_id):
    """Staff closes a conversation"""
    db = get_db()
    try:
        from services.chat_service import get_chat_service

        service = get_chat_service(db)
        result = service.close_conversation(conversation_id=conversation_id)

        if not result.get("success"):
            return (
                jsonify(
                    {"success": False, "error": result.get("error", "Failed to close")}
                ),
                400,
            )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/dashboard/chat")
@require_staff()
def dashboard_chat():
    """Staff dashboard page for managing escalated chats"""
    return render_template("chat_dashboard.html")


# =============================================================================
# WHATSAPP WEBHOOKS - Twilio WhatsApp message handlers
# =============================================================================


@app.route("/api/webhooks/whatsapp", methods=["POST"])
def whatsapp_webhook():
    """
    Handle incoming WhatsApp messages from Twilio.

    This endpoint receives:
    - Inbound messages from clients (text, images, documents)
    - Status updates for outbound messages

    Features:
    - Document intake: Clients can send photos of IDs, credit reports, etc.
    - Keyword commands: STATUS, HELP
    - Auto-replies within 24hr window
    """
    from twilio.request_validator import RequestValidator

    db = get_db()
    try:
        # Get Twilio signature for validation
        signature = request.headers.get("X-Twilio-Signature", "")

        # Validate Twilio signature (if auth token is configured)
        twilio_auth_token = os.environ.get("TWILIO_AUTH_TOKEN", "")
        if twilio_auth_token:
            validator = RequestValidator(twilio_auth_token)
            # Build the full URL including query params
            url = request.url
            params = request.form.to_dict()

            if not validator.validate(url, params, signature):
                print(f"WhatsApp webhook: Invalid Twilio signature")
                return "Invalid signature", 403

        # Parse the incoming message data
        from_number = request.form.get("From", "")  # whatsapp:+1234567890
        to_number = request.form.get("To", "")
        body = request.form.get("Body", "")
        message_sid = request.form.get("MessageSid", "")
        num_media = int(request.form.get("NumMedia", 0))
        profile_name = request.form.get("ProfileName", "")

        # Status callback fields (for outbound message updates)
        message_status = request.form.get("MessageStatus", "")
        error_code = request.form.get("ErrorCode", "")
        error_message = request.form.get("ErrorMessage", "")

        # Import the webhook service
        from services.whatsapp_webhook_service import get_whatsapp_webhook_service

        service = get_whatsapp_webhook_service(db)

        # Handle status callbacks for outbound messages
        if message_status and not from_number.startswith("whatsapp:"):
            result = service.handle_status_callback(
                message_sid=message_sid,
                status=message_status,
                error_code=error_code,
                error_message=error_message,
            )
            return "", 200

        # Handle incoming message
        media_urls = []
        media_types = []
        for i in range(num_media):
            media_url = request.form.get(f"MediaUrl{i}", "")
            media_type = request.form.get(f"MediaContentType{i}", "")
            if media_url:
                media_urls.append(media_url)
                media_types.append(media_type)

        result = service.process_incoming(
            from_number=from_number,
            to_number=to_number,
            body=body,
            message_sid=message_sid,
            profile_name=profile_name,
            media_urls=media_urls,
            media_types=media_types,
        )

        # Return TwiML response if provided
        twiml_response = result.get("twiml", "")
        if twiml_response:
            return twiml_response, 200, {"Content-Type": "application/xml"}

        return "", 200

    except Exception as e:
        print(f"WhatsApp webhook error: {e}")
        import traceback

        traceback.print_exc()
        return "", 200  # Always return 200 to Twilio to prevent retries
    finally:
        db.close()


@app.route("/api/portal/whatsapp/request-verification", methods=["POST"])
def portal_whatsapp_request_verification():
    """
    Request WhatsApp verification code.
    Client provides their WhatsApp number and receives a verification code.
    """
    import random
    from datetime import datetime, timedelta

    from flask import session

    client_id = session.get("client_id")
    if not client_id:
        return jsonify({"success": False, "error": "Not authenticated"}), 401

    data = request.get_json() or {}
    whatsapp_number = data.get("whatsapp_number", "").strip()

    if not whatsapp_number:
        return jsonify({"success": False, "error": "WhatsApp number is required"}), 400

    db = get_db()
    try:
        from database import Client
        from services.sms_service import format_whatsapp_number, send_whatsapp

        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Generate 6-digit verification code
        verification_code = "".join([str(random.randint(0, 9)) for _ in range(6)])

        # Store code and expiration (10 minutes)
        client.whatsapp_number = whatsapp_number
        client.whatsapp_verification_code = verification_code
        client.whatsapp_verification_expires = datetime.utcnow() + timedelta(minutes=10)
        client.whatsapp_verified = False
        db.commit()

        # Send verification code via WhatsApp
        # Note: This uses the 24hr reply window or requires an approved template
        message = f"Your verification code is: {verification_code}\n\nEnter this code in your portal to enable WhatsApp notifications."

        result = send_whatsapp(to_number=whatsapp_number, message=message)

        if result.get("success"):
            return jsonify(
                {"success": True, "message": "Verification code sent to your WhatsApp"}
            )
        else:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": result.get(
                            "error", "Failed to send verification code"
                        ),
                    }
                ),
                500,
            )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/whatsapp/verify", methods=["POST"])
def portal_whatsapp_verify():
    """
    Verify WhatsApp number with code.
    """
    from datetime import datetime

    from flask import session

    client_id = session.get("client_id")
    if not client_id:
        return jsonify({"success": False, "error": "Not authenticated"}), 401

    data = request.get_json() or {}
    code = data.get("code", "").strip()

    if not code:
        return (
            jsonify({"success": False, "error": "Verification code is required"}),
            400,
        )

    db = get_db()
    try:
        from database import Client

        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        # Check if code matches and hasn't expired
        if not client.whatsapp_verification_code:
            return jsonify({"success": False, "error": "No verification pending"}), 400

        if (
            client.whatsapp_verification_expires
            and client.whatsapp_verification_expires < datetime.utcnow()
        ):
            return (
                jsonify({"success": False, "error": "Verification code expired"}),
                400,
            )

        if client.whatsapp_verification_code != code:
            return (
                jsonify({"success": False, "error": "Invalid verification code"}),
                400,
            )

        # Mark as verified
        client.whatsapp_verified = True
        client.whatsapp_verified_at = datetime.utcnow()
        client.whatsapp_opt_in = True
        client.whatsapp_verification_code = None  # Clear code
        client.whatsapp_verification_expires = None
        db.commit()

        return jsonify({"success": True, "message": "WhatsApp verified successfully"})

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/whatsapp/status", methods=["GET"])
def portal_whatsapp_status():
    """
    Get client's WhatsApp verification status.
    """
    from flask import session

    client_id = session.get("client_id")
    if not client_id:
        return jsonify({"success": False, "error": "Not authenticated"}), 401

    db = get_db()
    try:
        from database import Client

        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        return jsonify(
            {
                "success": True,
                "whatsapp_opt_in": client.whatsapp_opt_in or False,
                "whatsapp_number": client.whatsapp_number,
                "whatsapp_verified": client.whatsapp_verified or False,
            }
        )

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/portal/whatsapp/opt-out", methods=["POST"])
def portal_whatsapp_opt_out():
    """
    Opt out of WhatsApp notifications.
    """
    from flask import session

    client_id = session.get("client_id")
    if not client_id:
        return jsonify({"success": False, "error": "Not authenticated"}), 401

    db = get_db()
    try:
        from database import Client

        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        client.whatsapp_opt_in = False
        db.commit()

        return jsonify(
            {"success": True, "message": "Opted out of WhatsApp notifications"}
        )

    except Exception as e:
        db.rollback()
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# Staff endpoint to request document via WhatsApp
@app.route("/api/clients/<int:client_id>/whatsapp/request-document", methods=["POST"])
@require_staff()
def api_request_document_via_whatsapp(client_id):
    """
    Staff can request a specific document from a client via WhatsApp.
    """
    data = request.get_json() or {}
    document_type = data.get("document_type", "")
    custom_message = data.get("custom_message", "")

    if not document_type:
        return jsonify({"success": False, "error": "Document type is required"}), 400

    db = get_db()
    try:
        from database import Client
        from services.whatsapp_automation import trigger_whatsapp_document_request

        client = db.query(Client).filter(Client.id == client_id).first()
        if not client:
            return jsonify({"success": False, "error": "Client not found"}), 404

        if not client.whatsapp_verified:
            return (
                jsonify(
                    {"success": False, "error": "Client has not verified WhatsApp"}
                ),
                400,
            )

        result = trigger_whatsapp_document_request(
            db=db,
            client_id=client_id,
            document_type=document_type,
            custom_message=custom_message,
        )

        return jsonify(result)

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


# ==============================================================================
# BATCH PROCESSING API (P18)
# ==============================================================================


@app.route("/api/batch/action-types", methods=["GET"])
@require_staff()
def api_batch_action_types():
    """Get available batch action types"""
    from services.batch_processing_service import BatchProcessingService

    service = BatchProcessingService()
    return jsonify(
        {
            "success": True,
            "action_types": service.get_action_types(),
            "status_options": service.get_status_options(),
        }
    )


@app.route("/api/batch/jobs", methods=["GET"])
@require_staff()
def api_batch_list_jobs():
    """List batch jobs with optional filtering"""
    from services.batch_processing_service import BatchProcessingService

    status = request.args.get("status")
    action_type = request.args.get("action_type")
    limit = int(request.args.get("limit", 50))
    offset = int(request.args.get("offset", 0))

    service = BatchProcessingService()
    jobs = service.list_jobs(
        status=status, action_type=action_type, limit=limit, offset=offset
    )

    return jsonify(
        {
            "success": True,
            "jobs": jobs,
        }
    )


@app.route("/api/batch/jobs", methods=["POST"])
@require_staff()
def api_batch_create_job():
    """Create a new batch job"""
    from services.batch_processing_service import BatchProcessingService

    data = request.json or {}
    name = data.get("name", "Batch Operation")
    action_type = data.get("action_type")
    client_ids = data.get("client_ids", [])
    action_params = data.get("action_params", {})
    execute_immediately = data.get("execute_immediately", True)

    if not action_type:
        return jsonify({"success": False, "error": "action_type is required"}), 400

    if not client_ids:
        return jsonify({"success": False, "error": "client_ids is required"}), 400

    staff_id = session.get("staff_id", 1)

    service = BatchProcessingService()
    success, message, job = service.create_job(
        name=name,
        action_type=action_type,
        client_ids=client_ids,
        action_params=action_params,
        staff_id=staff_id,
    )

    if not success:
        return jsonify({"success": False, "error": message}), 400

    # Execute immediately if requested
    if execute_immediately and job:
        exec_success, exec_message = service.execute_job(job["id"])
        job = service.get_job(job_id=job["id"])
        return jsonify(
            {
                "success": True,
                "message": exec_message,
                "job": job,
            }
        )

    return jsonify(
        {
            "success": True,
            "message": message,
            "job": job,
        }
    )


@app.route("/api/batch/jobs/<int:job_id>", methods=["GET"])
@require_staff()
def api_batch_get_job(job_id):
    """Get a batch job by ID"""
    from services.batch_processing_service import BatchProcessingService

    service = BatchProcessingService()
    job = service.get_job(job_id=job_id)

    if not job:
        return jsonify({"success": False, "error": "Job not found"}), 404

    return jsonify(
        {
            "success": True,
            "job": job,
        }
    )


@app.route("/api/batch/jobs/<int:job_id>/progress", methods=["GET"])
@require_staff()
def api_batch_job_progress(job_id):
    """Get real-time progress of a batch job"""
    from services.batch_processing_service import BatchProcessingService

    service = BatchProcessingService()
    progress = service.get_job_progress(job_id)

    if not progress:
        return jsonify({"success": False, "error": "Job not found"}), 404

    return jsonify(
        {
            "success": True,
            "progress": progress,
        }
    )


@app.route("/api/batch/jobs/<int:job_id>/execute", methods=["POST"])
@require_staff()
def api_batch_execute_job(job_id):
    """Execute a pending batch job"""
    from services.batch_processing_service import BatchProcessingService

    service = BatchProcessingService()
    success, message = service.execute_job(job_id)

    if not success:
        return jsonify({"success": False, "error": message}), 400

    job = service.get_job(job_id=job_id)
    return jsonify(
        {
            "success": True,
            "message": message,
            "job": job,
        }
    )


@app.route("/api/batch/jobs/<int:job_id>/cancel", methods=["POST"])
@require_staff()
def api_batch_cancel_job(job_id):
    """Cancel a batch job"""
    from services.batch_processing_service import BatchProcessingService

    staff_id = session.get("staff_id", 1)

    service = BatchProcessingService()
    success, message = service.cancel_job(job_id, staff_id)

    if not success:
        return jsonify({"success": False, "error": message}), 400

    return jsonify(
        {
            "success": True,
            "message": message,
        }
    )


@app.route("/api/batch/jobs/<int:job_id>/retry", methods=["POST"])
@require_staff()
def api_batch_retry_job(job_id):
    """Retry failed items in a batch job"""
    from services.batch_processing_service import BatchProcessingService

    service = BatchProcessingService()
    success, message = service.retry_failed_items(job_id)

    if not success:
        return jsonify({"success": False, "error": message}), 400

    # Re-execute the job
    exec_success, exec_message = service.execute_job(job_id)

    return jsonify(
        {
            "success": True,
            "message": f"{message}. {exec_message}",
        }
    )


@app.route("/api/batch/stats", methods=["GET"])
@require_staff()
def api_batch_stats():
    """Get batch processing statistics"""
    from services.batch_processing_service import BatchProcessingService

    service = BatchProcessingService()
    stats = service.get_stats()

    return jsonify(
        {
            "success": True,
            "stats": stats,
        }
    )


@app.route("/api/batch/history", methods=["GET"])
@require_staff()
def api_batch_history():
    """Get batch job history"""
    from services.batch_processing_service import BatchProcessingService

    days = int(request.args.get("days", 30))
    limit = int(request.args.get("limit", 100))

    service = BatchProcessingService()
    history = service.get_job_history(days=days, limit=limit)

    return jsonify(
        {
            "success": True,
            "history": history,
        }
    )


@app.route("/dashboard/batch-jobs", methods=["GET"])
@require_staff()
def dashboard_batch_jobs():
    """Batch jobs history page"""
    return render_template("batch_jobs.html")


# ==============================================================================
# STAFF PERFORMANCE API (P19)
# ==============================================================================


@app.route("/api/staff-performance/activity-types", methods=["GET"])
@require_staff()
def api_staff_performance_activity_types():
    """Get available activity types"""
    from services.staff_performance_service import ACTIVITY_TYPES

    return jsonify(
        {
            "success": True,
            "activity_types": ACTIVITY_TYPES,
        }
    )


@app.route("/api/staff-performance/log", methods=["POST"])
@require_staff()
def api_staff_performance_log():
    """Log a staff activity"""
    from services.staff_performance_service import StaffPerformanceService

    data = request.json or {}
    staff_id = data.get("staff_id") or session.get("staff_id")
    activity_type = data.get("activity_type")
    description = data.get("description")
    client_id = data.get("client_id")
    metadata = data.get("metadata")
    quality_score = data.get("quality_score")

    if not staff_id:
        return jsonify({"success": False, "error": "staff_id is required"}), 400
    if not activity_type:
        return jsonify({"success": False, "error": "activity_type is required"}), 400

    service = StaffPerformanceService()
    success, message, activity = service.log_activity(
        staff_id=staff_id,
        activity_type=activity_type,
        description=description,
        client_id=client_id,
        metadata=metadata,
        quality_score=quality_score,
    )

    if not success:
        return jsonify({"success": False, "error": message}), 400

    return jsonify(
        {
            "success": True,
            "message": message,
            "activity": activity,
        }
    )


@app.route("/api/staff-performance/dashboard", methods=["GET"])
@require_staff()
def api_staff_performance_dashboard():
    """Get staff performance dashboard summary"""
    from services.staff_performance_service import StaffPerformanceService

    service = StaffPerformanceService()
    summary = service.get_dashboard_summary()

    return jsonify(
        {
            "success": True,
            "dashboard": summary,
        }
    )


@app.route("/api/staff-performance/leaderboard", methods=["GET"])
@require_staff()
def api_staff_performance_leaderboard():
    """Get staff leaderboard"""
    from services.staff_performance_service import StaffPerformanceService

    period = request.args.get("period", "month")
    metric = request.args.get("metric", "points")
    limit = int(request.args.get("limit", 10))

    service = StaffPerformanceService()
    leaderboard = service.get_leaderboard(period=period, metric=metric, limit=limit)

    return jsonify(
        {
            "success": True,
            "leaderboard": leaderboard,
            "period": period,
            "metric": metric,
        }
    )


@app.route("/api/staff-performance/staff/<int:staff_id>/metrics", methods=["GET"])
@require_staff()
def api_staff_performance_metrics(staff_id):
    """Get performance metrics for a specific staff member"""
    from datetime import datetime, timedelta

    from services.staff_performance_service import StaffPerformanceService

    days = int(request.args.get("days", 30))
    start_date = datetime.utcnow() - timedelta(days=days)
    end_date = datetime.utcnow()

    service = StaffPerformanceService()
    metrics = service.get_staff_metrics(
        staff_id=staff_id, start_date=start_date, end_date=end_date
    )

    return jsonify(
        {
            "success": True,
            "metrics": metrics,
        }
    )


@app.route("/api/staff-performance/staff/<int:staff_id>/activities", methods=["GET"])
@require_staff()
def api_staff_performance_activities(staff_id):
    """Get recent activities for a staff member"""
    from services.staff_performance_service import StaffPerformanceService

    limit = int(request.args.get("limit", 50))
    offset = int(request.args.get("offset", 0))
    activity_type = request.args.get("activity_type")

    service = StaffPerformanceService()
    activities = service.get_staff_activities(
        staff_id=staff_id, limit=limit, offset=offset, activity_type=activity_type
    )

    return jsonify(
        {
            "success": True,
            "activities": activities,
        }
    )


@app.route("/api/staff-performance/team/metrics", methods=["GET"])
@require_staff()
def api_staff_performance_team_metrics():
    """Get aggregate metrics for all staff"""
    from datetime import datetime, timedelta

    from services.staff_performance_service import StaffPerformanceService

    days = int(request.args.get("days", 30))
    start_date = datetime.utcnow() - timedelta(days=days)
    end_date = datetime.utcnow()

    service = StaffPerformanceService()
    metrics = service.get_team_metrics(start_date=start_date, end_date=end_date)

    return jsonify(
        {
            "success": True,
            "metrics": metrics,
        }
    )


@app.route("/api/staff-performance/trend", methods=["GET"])
@require_staff()
def api_staff_performance_trend():
    """Get performance trend over time"""
    from services.staff_performance_service import StaffPerformanceService

    staff_id = request.args.get("staff_id")
    days = int(request.args.get("days", 30))

    service = StaffPerformanceService()
    trend = service.get_performance_trend(
        staff_id=int(staff_id) if staff_id else None, days=days
    )

    return jsonify(
        {
            "success": True,
            "trend": trend,
        }
    )


@app.route("/api/staff-performance/recent", methods=["GET"])
@require_staff()
def api_staff_performance_recent():
    """Get recent team activities"""
    from services.staff_performance_service import StaffPerformanceService

    limit = int(request.args.get("limit", 20))

    service = StaffPerformanceService()
    activities = service.get_recent_team_activities(limit=limit)

    return jsonify(
        {
            "success": True,
            "activities": activities,
        }
    )


@app.route("/dashboard/staff-performance", methods=["GET"])
@require_staff()
def dashboard_staff_performance():
    """Staff performance dashboard page"""
    return render_template("staff_performance.html")


# =====================================================================
# CLIENT SUCCESS METRICS API ENDPOINTS
# =====================================================================


@app.route("/api/client-success/dashboard", methods=["GET"])
@require_staff()
def api_client_success_dashboard():
    """Get dashboard summary for client success metrics"""
    from services.client_success_service import ClientSuccessService

    service = ClientSuccessService(g.db_session)
    summary = service.get_dashboard_summary()

    return jsonify(
        {
            "success": True,
            **summary,
        }
    )


@app.route("/api/client-success/aggregate", methods=["GET"])
@require_staff()
def api_client_success_aggregate():
    """Get aggregate success report"""
    from services.client_success_service import ClientSuccessService

    period = request.args.get("period", "all")

    service = ClientSuccessService(g.db_session)
    report = service.get_aggregate_report(period=period)

    return jsonify(
        {
            "success": True,
            **report,
        }
    )


@app.route("/api/client-success/client/<int:client_id>", methods=["GET"])
@require_staff()
def api_client_success_client(client_id):
    """Get success summary for a specific client"""
    from services.client_success_service import ClientSuccessService

    service = ClientSuccessService(g.db_session)
    summary = service.get_client_summary(client_id)

    if "error" in summary:
        return jsonify({"success": False, "error": summary["error"]}), 404

    return jsonify(
        {
            "success": True,
            **summary,
        }
    )


@app.route("/api/client-success/client/<int:client_id>/snapshot", methods=["POST"])
@require_staff()
def api_client_success_create_snapshot(client_id):
    """Create a new success metric snapshot for a client"""
    from services.client_success_service import ClientSuccessService

    data = request.get_json() or {}
    snapshot_type = data.get("snapshot_type", "manual")

    service = ClientSuccessService(g.db_session)
    snapshot = service.create_snapshot(client_id, snapshot_type)

    if not snapshot:
        return jsonify({"success": False, "error": "Failed to create snapshot"}), 400

    return jsonify(
        {
            "success": True,
            "snapshot": snapshot.to_dict(),
        }
    )


@app.route("/api/client-success/client/<int:client_id>/history", methods=["GET"])
@require_staff()
def api_client_success_history(client_id):
    """Get snapshot history for a client"""
    from services.client_success_service import ClientSuccessService

    limit = int(request.args.get("limit", 12))

    service = ClientSuccessService(g.db_session)
    history = service.get_snapshot_history(client_id, limit=limit)

    return jsonify(
        {
            "success": True,
            "history": [s.to_dict() for s in history],
        }
    )


@app.route("/api/client-success/top-performers", methods=["GET"])
@require_staff()
def api_client_success_top_performers():
    """Get top performing clients"""
    from services.client_success_service import ClientSuccessService

    limit = int(request.args.get("limit", 10))
    metric = request.args.get("metric", "deletion_rate")

    service = ClientSuccessService(g.db_session)
    performers = service.get_top_performers(limit=limit, metric=metric)

    return jsonify(
        {
            "success": True,
            "metric": metric,
            "performers": performers,
        }
    )


@app.route("/api/client-success/trend", methods=["GET"])
@require_staff()
def api_client_success_trend():
    """Get success metrics trend over time"""
    from services.client_success_service import ClientSuccessService

    period = request.args.get("period", "month")
    granularity = request.args.get("granularity", "day")

    service = ClientSuccessService(g.db_session)
    trend = service.get_success_trend(period=period, granularity=granularity)

    return jsonify(
        {
            "success": True,
            "period": period,
            "trend": trend,
        }
    )


@app.route("/api/client-success/bureau-breakdown", methods=["GET"])
@require_staff()
def api_client_success_bureau_breakdown():
    """Get success metrics broken down by bureau"""
    from services.client_success_service import ClientSuccessService

    service = ClientSuccessService(g.db_session)
    breakdown = service.get_bureau_breakdown()

    return jsonify(
        {
            "success": True,
            **breakdown,
        }
    )


@app.route("/api/client-success/update-all", methods=["POST"])
@require_staff()
def api_client_success_update_all():
    """Create snapshots for all active clients"""
    from services.client_success_service import ClientSuccessService

    data = request.get_json() or {}
    snapshot_type = data.get("snapshot_type", "periodic")

    service = ClientSuccessService(g.db_session)
    result = service.update_all_clients(snapshot_type=snapshot_type)

    return jsonify(
        {
            "success": True,
            **result,
        }
    )


@app.route("/api/client-success/export", methods=["GET"])
@require_staff()
def api_client_success_export():
    """Export success metrics data"""
    import csv
    import io

    from services.client_success_service import ClientSuccessService

    client_ids = request.args.get("client_ids")
    if client_ids:
        client_ids = [int(id) for id in client_ids.split(",")]
    else:
        client_ids = None

    service = ClientSuccessService(g.db_session)
    data = service.export_success_data(client_ids=client_ids)

    # Create CSV
    output = io.StringIO()
    if data:
        writer = csv.DictWriter(output, fieldnames=data[0].keys())
        writer.writeheader()
        writer.writerows(data)

    response = make_response(output.getvalue())
    response.headers["Content-Type"] = "text/csv"
    response.headers["Content-Disposition"] = (
        "attachment; filename=client_success_metrics.csv"
    )

    return response


@app.route("/dashboard/client-success", methods=["GET"])
@require_staff()
def dashboard_client_success():
    """Client success metrics dashboard page"""
    return render_template("client_success.html")


# =====================================================================
# AI DISPUTE WRITER API ENDPOINTS
# =====================================================================


@app.route("/api/ai-dispute-writer/dashboard", methods=["GET"])
@require_staff()
def api_ai_dispute_writer_dashboard():
    """Get dashboard data for AI Dispute Writer"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    client_id = request.args.get("client_id", type=int)

    service = AIDisputeWriterService(g.db_session)
    data = service.get_dashboard_data(client_id=client_id)

    if "error" in data:
        return jsonify({"success": False, "error": data["error"]}), 400

    return jsonify(
        {
            "success": True,
            **data,
        }
    )


@app.route("/api/ai-dispute-writer/rounds", methods=["GET"])
@require_staff()
def api_ai_dispute_writer_rounds():
    """Get information about all dispute rounds"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    service = AIDisputeWriterService(g.db_session)
    rounds = service.get_all_rounds_info()

    return jsonify(
        {
            "success": True,
            "rounds": rounds,
        }
    )


@app.route("/api/ai-dispute-writer/client/<int:client_id>/context", methods=["GET"])
@require_staff()
def api_ai_dispute_writer_context(client_id):
    """Get client context for letter generation"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    service = AIDisputeWriterService(g.db_session)
    context = service.get_client_context(client_id)

    if "error" in context:
        return jsonify({"success": False, "error": context["error"]}), 404

    # Serialize context
    return jsonify(
        {
            "success": True,
            "client": {
                "id": context["client"].id,
                "name": context["client"].name,
                "email": context["client"].email,
                "current_round": context["client"].current_dispute_round or 1,
            },
            "violations_count": len(context["violations"]),
            "dispute_items_count": len(context["dispute_items"]),
            "cra_responses_count": len(context["cra_responses"]),
            "current_round": context["current_round"],
        }
    )


@app.route("/api/ai-dispute-writer/client/<int:client_id>/suggest", methods=["GET"])
@require_staff()
def api_ai_dispute_writer_suggest(client_id):
    """Get AI suggestion for next action"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    service = AIDisputeWriterService(g.db_session)
    suggestion = service.suggest_next_action(client_id)

    if "error" in suggestion:
        return jsonify({"success": False, "error": suggestion["error"]}), 400

    return jsonify(
        {
            "success": True,
            **suggestion,
        }
    )


@app.route("/api/ai-dispute-writer/generate", methods=["POST"])
@require_staff()
def api_ai_dispute_writer_generate():
    """Generate dispute letters using AI"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    data = request.get_json() or {}

    client_id = data.get("client_id")
    if not client_id:
        return jsonify({"success": False, "error": "client_id required"}), 400

    round_number = data.get("round", 1)
    selected_item_ids = data.get("selected_items")
    bureaus = data.get("bureaus")
    custom_instructions = data.get("custom_instructions")
    tone = data.get("tone", "professional")

    service = AIDisputeWriterService(g.db_session)
    result = service.generate_letters(
        client_id=client_id,
        round_number=round_number,
        selected_item_ids=selected_item_ids,
        bureaus=bureaus,
        custom_instructions=custom_instructions,
        tone=tone,
    )

    if "error" in result:
        return jsonify({"success": False, "error": result["error"]}), 400

    return jsonify(result)


@app.route("/api/ai-dispute-writer/generate-quick", methods=["POST"])
@require_staff()
def api_ai_dispute_writer_generate_quick():
    """Generate a quick single letter"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    data = request.get_json() or {}

    client_id = data.get("client_id")
    bureau = data.get("bureau")
    item_description = data.get("item_description")
    violation_type = data.get("violation_type")

    if not all([client_id, bureau, item_description, violation_type]):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "client_id, bureau, item_description, and violation_type required",
                }
            ),
            400,
        )

    custom_text = data.get("custom_text")

    service = AIDisputeWriterService(g.db_session)
    result = service.generate_quick_letter(
        client_id=client_id,
        bureau=bureau,
        item_description=item_description,
        violation_type=violation_type,
        custom_text=custom_text,
    )

    if "error" in result:
        return jsonify({"success": False, "error": result["error"]}), 400

    return jsonify(result)


@app.route("/api/ai-dispute-writer/regenerate", methods=["POST"])
@require_staff()
def api_ai_dispute_writer_regenerate():
    """Regenerate a letter with feedback"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    data = request.get_json() or {}

    client_id = data.get("client_id")
    bureau = data.get("bureau")
    original_letter = data.get("original_letter")
    feedback = data.get("feedback")
    round_number = data.get("round", 1)

    if not all([client_id, bureau, original_letter, feedback]):
        return (
            jsonify(
                {
                    "success": False,
                    "error": "client_id, bureau, original_letter, and feedback required",
                }
            ),
            400,
        )

    service = AIDisputeWriterService(g.db_session)
    result = service.regenerate_with_feedback(
        client_id=client_id,
        bureau=bureau,
        original_letter=original_letter,
        feedback=feedback,
        round_number=round_number,
    )

    if "error" in result:
        return jsonify({"success": False, "error": result["error"]}), 400

    return jsonify(result)


@app.route("/api/ai-dispute-writer/save", methods=["POST"])
@require_staff()
def api_ai_dispute_writer_save():
    """Save a generated letter"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    data = request.get_json() or {}

    client_id = data.get("client_id")
    bureau = data.get("bureau")
    content = data.get("content")
    round_number = data.get("round", 1)
    analysis_id = data.get("analysis_id")

    if not all([client_id, bureau, content]):
        return (
            jsonify(
                {"success": False, "error": "client_id, bureau, and content required"}
            ),
            400,
        )

    service = AIDisputeWriterService(g.db_session)
    try:
        letter = service.save_letter(
            client_id=client_id,
            bureau=bureau,
            content=content,
            round_number=round_number,
            analysis_id=analysis_id,
        )
        return jsonify(
            {
                "success": True,
                "letter_id": letter.id,
                "message": "Letter saved successfully",
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 400


@app.route("/api/ai-dispute-writer/client/<int:client_id>/letters", methods=["GET"])
@require_staff()
def api_ai_dispute_writer_letters(client_id):
    """Get saved letters for a client"""
    from services.ai_dispute_writer_service import AIDisputeWriterService

    round_number = request.args.get("round", type=int)

    service = AIDisputeWriterService(g.db_session)
    letters = service.get_saved_letters(client_id, round_number=round_number)

    return jsonify(
        {
            "success": True,
            "letters": [
                {
                    "id": l.id,
                    "bureau": l.bureau,
                    "round": l.round_number,
                    "content": l.letter_content,
                    "created_at": l.created_at.isoformat() if l.created_at else None,
                    "sent_at": l.sent_at.isoformat() if l.sent_at else None,
                }
                for l in letters
            ],
        }
    )


@app.route("/dashboard/ai-dispute-writer", methods=["GET"])
@require_staff()
def dashboard_ai_dispute_writer():
    """AI Dispute Writer dashboard page"""
    return render_template("ai_dispute_writer.html")


# =============================================================================
# 5-DAY KNOCK-OUT (IDENTITY THEFT) ENDPOINTS
# =============================================================================


@app.route("/dashboard/5day-knockout", methods=["GET"])
@require_staff()
def dashboard_5day_knockout():
    """5-Day Knock-Out dashboard page"""
    return render_template("5day_knockout.html")


@app.route("/api/5day-knockout/strategies", methods=["GET"])
@require_staff()
def api_5day_knockout_strategies():
    """Get available special dispute strategies"""
    try:
        from services.ai_dispute_writer_service import AIDisputeWriterService

        with get_db() as db:
            service = AIDisputeWriterService(db)
            strategies = service.get_special_strategies_info()
            return jsonify(
                {
                    "success": True,
                    "strategies": strategies,
                    "bureau_fraud_addresses": service.BUREAU_FRAUD_ADDRESSES,
                }
            )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/5day-knockout/generate", methods=["POST"])
@require_staff()
def api_5day_knockout_generate():
    """Generate 5-Day Knock-Out documents for a client"""
    try:
        from services.ai_dispute_writer_service import AIDisputeWriterService

        data = request.get_json() or {}

        client_id = data.get("client_id")
        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400

        phase = data.get("phase", 1)
        police_case_number = data.get("police_case_number")
        ftc_reference_number = data.get("ftc_reference_number")
        disputed_items = data.get("disputed_items")

        # Phase 2 requires police case number
        if phase == 2 and not police_case_number:
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "police_case_number required for Phase 2",
                    }
                ),
                400,
            )

        with get_db() as db:
            service = AIDisputeWriterService(db)
            result = service.generate_5day_knockout(
                client_id=client_id,
                police_case_number=police_case_number,
                ftc_reference_number=ftc_reference_number,
                disputed_items=disputed_items,
                phase=phase,
            )

            if "error" in result:
                return jsonify({"success": False, "error": result["error"]}), 400

            return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/5day-knockout/client/<int:client_id>/items", methods=["GET"])
@require_staff()
def api_5day_knockout_client_items(client_id):
    """Get disputed items for a client (for 5-Day Knockout) - pulls from imported credit report"""
    try:
        with get_db() as db:
            client = db.query(Client).filter(Client.id == client_id).first()
            if not client:
                return jsonify({"success": False, "error": "Client not found"}), 404

            items = []

            # First try to get accounts from the latest Analysis (already parsed)
            analysis = (
                db.query(Analysis)
                .filter(Analysis.client_id == client_id)
                .order_by(Analysis.created_at.desc())
                .first()
            )

            if analysis and analysis.stage_1_analysis:
                try:
                    import ast
                    import json

                    # stage_1_analysis may be JSON string or Python dict string
                    analysis_data = analysis.stage_1_analysis
                    if isinstance(analysis_data, str):
                        try:
                            parsed = json.loads(analysis_data)
                        except json.JSONDecodeError:
                            parsed = ast.literal_eval(analysis_data)
                    else:
                        parsed = analysis_data

                    # Extract accounts from the analysis
                    accounts = parsed.get("accounts", [])
                    for idx, acct in enumerate(accounts):
                        # Determine bureau from account data
                        bureaus = []
                        if acct.get("equifax") or acct.get("efx_status"):
                            bureaus.append("Equifax")
                        if acct.get("experian") or acct.get("exp_status"):
                            bureaus.append("Experian")
                        if acct.get("transunion") or acct.get("tu_status"):
                            bureaus.append("TransUnion")

                        # If no bureau info, assume all 3
                        if not bureaus:
                            bureaus = ["Equifax", "Experian", "TransUnion"]

                        items.append(
                            {
                                "id": f"analysis_{idx}",
                                "creditor": acct.get("creditor")
                                or acct.get("creditor_name")
                                or "Unknown",
                                "account_number": acct.get("account_number")
                                or acct.get("account_num")
                                or "N/A",
                                "bureau": ", ".join(bureaus),
                                "type": acct.get("account_type")
                                or acct.get("type")
                                or "Unknown",
                                "status": acct.get("status")
                                or acct.get("account_status")
                                or "Unknown",
                                "balance": acct.get("balance")
                                or acct.get("balance_owed"),
                                "source": "analysis",
                            }
                        )
                except Exception as e:
                    print(f"Error parsing analysis data: {e}")

            # If no accounts from Analysis, try parsing CreditReport HTML directly
            if not items:
                credit_report = (
                    db.query(CreditReport)
                    .filter(CreditReport.client_id == client_id)
                    .order_by(CreditReport.created_at.desc())
                    .first()
                )

                if credit_report and credit_report.report_html:
                    try:
                        from services.credit_report_parser import CreditReportParser

                        parser = CreditReportParser(credit_report.report_html)
                        parsed_data = parser.parse()
                        accounts = parsed_data.get("accounts", [])

                        for idx, acct in enumerate(accounts):
                            bureaus = []
                            if acct.get("equifax") or acct.get("efx_status"):
                                bureaus.append("Equifax")
                            if acct.get("experian") or acct.get("exp_status"):
                                bureaus.append("Experian")
                            if acct.get("transunion") or acct.get("tu_status"):
                                bureaus.append("TransUnion")
                            if not bureaus:
                                bureaus = ["Equifax", "Experian", "TransUnion"]

                            items.append(
                                {
                                    "id": f"report_{idx}",
                                    "creditor": acct.get("creditor")
                                    or acct.get("creditor_name")
                                    or "Unknown",
                                    "account_number": acct.get("account_number")
                                    or "N/A",
                                    "bureau": ", ".join(bureaus),
                                    "type": acct.get("account_type") or "Unknown",
                                    "status": acct.get("status")
                                    or acct.get("account_status")
                                    or "Unknown",
                                    "balance": acct.get("balance")
                                    or acct.get("balance_owed"),
                                    "source": "credit_report",
                                }
                            )
                    except Exception as e:
                        print(f"Error parsing credit report HTML: {e}")

            # Try parsing from CreditMonitoringCredential's last_report_path (saved HTML file)
            if not items:
                credential = (
                    db.query(CreditMonitoringCredential)
                    .filter(
                        CreditMonitoringCredential.client_id == client_id,
                        CreditMonitoringCredential.last_report_path.isnot(None),
                    )
                    .order_by(CreditMonitoringCredential.last_import_at.desc())
                    .first()
                )

                if credential and credential.last_report_path:
                    try:
                        import os

                        report_path = credential.last_report_path
                        # Handle relative paths
                        if not os.path.isabs(report_path):
                            report_path = os.path.join(
                                os.path.dirname(__file__), report_path
                            )

                        if os.path.exists(report_path):
                            with open(report_path, "r", encoding="utf-8") as f:
                                html_content = f.read()

                            from services.credit_report_parser import CreditReportParser

                            parser = CreditReportParser(html_content)
                            parsed_data = parser.parse()
                            accounts = parsed_data.get("accounts", [])

                            print(
                                f"Parsed {len(accounts)} accounts from credential report: {report_path}"
                            )

                            for idx, acct in enumerate(accounts):
                                bureaus = []
                                if acct.get("equifax") or acct.get("efx_status"):
                                    bureaus.append("Equifax")
                                if acct.get("experian") or acct.get("exp_status"):
                                    bureaus.append("Experian")
                                if acct.get("transunion") or acct.get("tu_status"):
                                    bureaus.append("TransUnion")
                                if not bureaus:
                                    bureaus = ["Equifax", "Experian", "TransUnion"]

                                items.append(
                                    {
                                        "id": f"cred_{idx}",
                                        "creditor": acct.get("creditor")
                                        or acct.get("creditor_name")
                                        or "Unknown",
                                        "account_number": acct.get("account_number")
                                        or "N/A",
                                        "bureau": ", ".join(bureaus),
                                        "type": acct.get("account_type") or "Unknown",
                                        "status": acct.get("status")
                                        or acct.get("account_status")
                                        or "Unknown",
                                        "balance": acct.get("balance")
                                        or acct.get("balance_owed"),
                                        "source": "credential_import",
                                    }
                                )

                            # Also extract inquiries
                            inquiries = parsed_data.get("inquiries", [])
                            for idx, inq in enumerate(inquiries):
                                items.append(
                                    {
                                        "id": f"inq_{idx}",
                                        "creditor": inq.get("creditor") or "Unknown",
                                        "account_number": inq.get("date") or "N/A",
                                        "bureau": inq.get("bureau") or "Unknown",
                                        "type": "Inquiry",
                                        "status": inq.get("type") or "Hard Inquiry",
                                        "balance": None,
                                        "source": "inquiry",
                                    }
                                )
                    except Exception as e:
                        import traceback

                        print(f"Error parsing credential report HTML: {e}")
                        traceback.print_exc()

            # Fallback to DisputeItem table if still no items
            if not items:
                dispute_items = (
                    db.query(DisputeItem)
                    .filter(DisputeItem.client_id == client_id)
                    .all()
                )

                items = [
                    {
                        "id": item.id,
                        "creditor": item.creditor_name,
                        "account_number": item.account_id,
                        "bureau": item.bureau,
                        "type": item.item_type,
                        "status": item.status,
                        "balance": getattr(item, "balance", None),
                        "source": "dispute_item",
                    }
                    for item in dispute_items
                ]

            # Check if client has any credit report source
            has_report = bool(
                analysis
                or db.query(CreditReport)
                .filter(CreditReport.client_id == client_id)
                .first()
                or db.query(CreditMonitoringCredential)
                .filter(
                    CreditMonitoringCredential.client_id == client_id,
                    CreditMonitoringCredential.last_report_path.isnot(None),
                )
                .first()
            )

            return jsonify(
                {
                    "success": True,
                    "client": {
                        "id": client.id,
                        "name": client.name,
                        "email": client.email,
                    },
                    "items": items,
                    "has_credit_report": has_report,
                }
            )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/5day-knockout/create-packets", methods=["POST"])
@require_staff()
def api_5day_knockout_create_packets():
    """Create envelope-ready packets for SendCertifiedMail from 5DKO documents"""
    try:
        from services.ai_dispute_writer_service import AIDisputeWriterService

        data = request.get_json() or {}

        client_id = data.get("client_id")
        documents = data.get("documents", {})
        police_case_number = data.get("police_case_number")
        ftc_reference_number = data.get("ftc_reference_number")

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400

        if not documents:
            return jsonify({"success": False, "error": "documents required"}), 400

        if not police_case_number:
            return (
                jsonify({"success": False, "error": "police_case_number required"}),
                400,
            )

        with get_db() as db:
            service = AIDisputeWriterService(db)
            result = service.create_5day_knockout_packets(
                client_id=client_id,
                documents=documents,
                police_case_number=police_case_number,
                ftc_reference_number=ftc_reference_number,
            )

            if "error" in result:
                return jsonify({"success": False, "error": result["error"]}), 400

            # Convert packet PDF bytes to base64 for JSON response
            import base64

            packets_serialized = {}
            for bureau, packet in result.get("packets", {}).items():
                packet_copy = dict(packet)
                if "cover_sheet_pdf" in packet_copy:
                    packet_copy["cover_sheet_pdf_base64"] = base64.b64encode(
                        packet_copy["cover_sheet_pdf"]
                    ).decode("utf-8")
                    del packet_copy["cover_sheet_pdf"]
                packets_serialized[bureau] = packet_copy

            return jsonify(
                {
                    "success": True,
                    "client_id": result["client_id"],
                    "client_name": result["client_name"],
                    "packets": packets_serialized,
                    "total_packets": result["total_packets"],
                    "estimated_cost": result["estimated_cost"],
                    "created_at": result["created_at"],
                }
            )
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/5day-knockout/queue-packets", methods=["POST"])
@require_staff()
def api_5day_knockout_queue_packets():
    """Queue 5-Day Knock-Out packets to SendCertifiedMail"""
    try:
        import base64

        from services.ai_dispute_writer_service import AIDisputeWriterService
        from services.sendcertified_service import get_sendcertified_status

        data = request.get_json() or {}

        client_id = data.get("client_id")
        packets = data.get("packets", {})

        if not client_id:
            return jsonify({"success": False, "error": "client_id required"}), 400

        if not packets:
            return jsonify({"success": False, "error": "packets required"}), 400

        # Check if SendCertified is configured
        sendcertified_status = get_sendcertified_status()
        if not sendcertified_status.get("configured"):
            return (
                jsonify(
                    {
                        "success": False,
                        "error": "SendCertified is not configured. Go to Settings > Integrations to set up API credentials.",
                    }
                ),
                400,
            )

        # Convert base64 PDFs back to bytes
        packets_with_bytes = {}
        for bureau, packet in packets.items():
            packet_copy = dict(packet)
            if "cover_sheet_pdf_base64" in packet_copy:
                packet_copy["cover_sheet_pdf"] = base64.b64decode(
                    packet_copy["cover_sheet_pdf_base64"]
                )
                del packet_copy["cover_sheet_pdf_base64"]
            packets_with_bytes[bureau] = packet_copy

        with get_db() as db:
            service = AIDisputeWriterService(db)
            result = service.queue_packets_to_sendcertified(
                client_id=client_id,
                packets=packets_with_bytes,
            )

            return jsonify(result)
    except Exception as e:
        import traceback

        traceback.print_exc()
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/5day-knockout/sendcertified-status", methods=["GET"])
@require_staff()
def api_5day_knockout_sendcertified_status():
    """Check SendCertified integration status for 5DKO"""
    try:
        from services.sendcertified_service import (
            get_mailing_statistics,
            get_sendcertified_status,
        )

        status = get_sendcertified_status()
        stats = get_mailing_statistics()
        return jsonify(
            {
                "success": True,
                "status": status,
                "statistics": stats,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# =============================================================================
# ROI CALCULATOR ENDPOINTS
# =============================================================================


@app.route("/api/roi-calculator/dashboard", methods=["GET"])
@require_staff()
def api_roi_calculator_dashboard():
    """Get ROI calculator dashboard summary"""
    try:
        from services.roi_calculator_service import ROICalculatorService

        service = ROICalculatorService()
        summary = service.get_dashboard_summary()
        return jsonify({"success": True, **summary})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/roi-calculator/calculate/<int:client_id>", methods=["POST"])
@require_staff()
def api_roi_calculator_calculate(client_id):
    """Calculate ROI for a specific client"""
    try:
        from services.roi_calculator_service import ROICalculatorService

        data = request.get_json() or {}

        actual_damages = data.get("actual_damages")
        save = data.get("save", True)

        service = ROICalculatorService()
        result = service.calculate_roi(
            client_id=client_id,
            staff_id=session.get("staff_id"),
            actual_damages=actual_damages,
            save=save,
        )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/roi-calculator/quick-estimate", methods=["POST"])
@require_staff()
def api_roi_calculator_quick_estimate():
    """Quick ROI estimate without client data"""
    try:
        from services.roi_calculator_service import ROICalculatorService

        data = request.get_json() or {}

        service = ROICalculatorService()
        result = service.quick_estimate(
            violations_count=data.get("violations_count", 0),
            willful_count=data.get("willful_count", 0),
            collections_count=data.get("collections_count", 0),
            chargeoffs_count=data.get("chargeoffs_count", 0),
            late_payments_count=data.get("late_payments_count", 0),
            inquiries_count=data.get("inquiries_count", 0),
            public_records_count=data.get("public_records_count", 0),
            actual_damages=data.get("actual_damages", 0),
        )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/roi-calculator/client/<int:client_id>", methods=["GET"])
@require_staff()
def api_roi_calculator_client_history(client_id):
    """Get calculation history for a client"""
    try:
        from services.roi_calculator_service import ROICalculatorService

        limit = request.args.get("limit", 10, type=int)

        service = ROICalculatorService()
        calculations = service.get_client_calculations(client_id, limit=limit)

        return jsonify({"success": True, "calculations": calculations})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/roi-calculator/calculation/<int:calculation_id>", methods=["GET"])
@require_staff()
def api_roi_calculator_get_calculation(calculation_id):
    """Get a specific calculation"""
    try:
        from services.roi_calculator_service import ROICalculatorService

        service = ROICalculatorService()
        calculation = service.get_calculation(calculation_id)

        if calculation:
            return jsonify({"success": True, "calculation": calculation})
        return jsonify({"success": False, "error": "Calculation not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/roi-calculator/stats", methods=["GET"])
@require_staff()
def api_roi_calculator_stats():
    """Get aggregate statistics"""
    try:
        from services.roi_calculator_service import ROICalculatorService

        period = request.args.get("period", "all")

        service = ROICalculatorService()
        stats = service.get_aggregate_stats(period=period)

        return jsonify({"success": True, **stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/roi-calculator/export", methods=["GET"])
@require_staff()
def api_roi_calculator_export():
    """Export calculations as CSV"""
    try:
        import csv
        from io import StringIO

        from services.roi_calculator_service import ROICalculatorService

        period = request.args.get("period", "all")
        client_ids = request.args.get("client_ids")

        if client_ids:
            client_ids = [int(x) for x in client_ids.split(",")]

        service = ROICalculatorService()
        data = service.export_calculations(client_ids=client_ids, period=period)

        if not data:
            return jsonify({"success": False, "error": "No data to export"}), 404

        # Create CSV
        output = StringIO()
        writer = csv.DictWriter(output, fieldnames=data[0].keys())
        writer.writeheader()
        writer.writerows(data)

        response = make_response(output.getvalue())
        response.headers["Content-Type"] = "text/csv"
        response.headers["Content-Disposition"] = (
            f"attachment; filename=roi_calculations_{period}.csv"
        )

        return response
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/dashboard/roi-calculator", methods=["GET"])
@require_staff()
def dashboard_roi_calculator():
    """ROI Calculator dashboard page"""
    return render_template("roi_calculator.html")


# =============================================================================
# PAYMENT PLANS ENDPOINTS
# =============================================================================


@app.route("/api/payment-plans", methods=["GET"])
@require_staff()
def api_payment_plans_list():
    """List payment plans with filtering"""
    try:
        from services.payment_plan_service import PaymentPlanService

        status = request.args.get("status")
        client_id = request.args.get("client_id", type=int)
        limit = request.args.get("limit", 50, type=int)
        offset = request.args.get("offset", 0, type=int)

        service = PaymentPlanService()
        result = service.list_plans(
            status=status, client_id=client_id, limit=limit, offset=offset
        )

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans", methods=["POST"])
@require_staff()
def api_payment_plans_create():
    """Create a new payment plan"""
    try:
        from services.payment_plan_service import PaymentPlanService

        data = request.get_json() or {}

        required = ["client_id", "total_amount"]
        for field in required:
            if field not in data:
                return jsonify({"success": False, "error": f"Missing {field}"}), 400

        service = PaymentPlanService()
        result = service.create_plan(
            client_id=data["client_id"],
            total_amount=data["total_amount"],
            num_installments=data.get("num_installments", 3),
            down_payment=data.get("down_payment", 0),
            start_date=data.get("start_date"),
            frequency=data.get("frequency", "monthly"),
            plan_name=data.get("plan_name"),
            plan_type=data.get("plan_type", "custom"),
            payment_method=data.get("payment_method"),
            auto_charge=data.get("auto_charge", False),
            grace_period_days=data.get("grace_period_days", 5),
            late_fee_amount=data.get("late_fee_amount", 0),
            late_fee_percent=data.get("late_fee_percent", 0),
            notes=data.get("notes"),
            staff_id=session.get("staff_id"),
        )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/<int:plan_id>", methods=["GET"])
@require_staff()
def api_payment_plans_get(plan_id):
    """Get a payment plan with installments"""
    try:
        from services.payment_plan_service import PaymentPlanService

        service = PaymentPlanService()
        result = service.get_plan(plan_id)

        if result:
            return jsonify({"success": True, **result})
        return jsonify({"success": False, "error": "Plan not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/<int:plan_id>", methods=["PUT"])
@require_staff()
def api_payment_plans_update(plan_id):
    """Update a payment plan"""
    try:
        from services.payment_plan_service import PaymentPlanService

        data = request.get_json() or {}

        service = PaymentPlanService()
        result = service.update_plan(plan_id, data)

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/<int:plan_id>/payment", methods=["POST"])
@require_staff()
def api_payment_plans_record_payment(plan_id):
    """Record a payment against a plan"""
    try:
        from services.payment_plan_service import PaymentPlanService

        data = request.get_json() or {}

        if "amount" not in data:
            return jsonify({"success": False, "error": "Amount is required"}), 400

        service = PaymentPlanService()
        result = service.record_payment(
            plan_id=plan_id,
            amount=data["amount"],
            payment_method=data.get("payment_method", "manual"),
            installment_id=data.get("installment_id"),
            reference_number=data.get("reference_number"),
            stripe_payment_intent_id=data.get("stripe_payment_intent_id"),
            staff_id=session.get("staff_id"),
            notes=data.get("notes"),
        )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/<int:plan_id>/pause", methods=["POST"])
@require_staff()
def api_payment_plans_pause(plan_id):
    """Pause a payment plan"""
    try:
        from services.payment_plan_service import PaymentPlanService

        data = request.get_json() or {}

        service = PaymentPlanService()
        result = service.pause_plan(plan_id, reason=data.get("reason"))

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/<int:plan_id>/resume", methods=["POST"])
@require_staff()
def api_payment_plans_resume(plan_id):
    """Resume a paused payment plan"""
    try:
        from services.payment_plan_service import PaymentPlanService

        service = PaymentPlanService()
        result = service.resume_plan(plan_id)

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/<int:plan_id>/cancel", methods=["POST"])
@require_staff()
def api_payment_plans_cancel(plan_id):
    """Cancel a payment plan"""
    try:
        from services.payment_plan_service import PaymentPlanService

        data = request.get_json() or {}

        service = PaymentPlanService()
        result = service.cancel_plan(plan_id, reason=data.get("reason"))

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/<int:plan_id>/default", methods=["POST"])
@require_staff()
def api_payment_plans_default(plan_id):
    """Mark a payment plan as defaulted"""
    try:
        from services.payment_plan_service import PaymentPlanService

        data = request.get_json() or {}

        service = PaymentPlanService()
        result = service.mark_defaulted(plan_id, reason=data.get("reason"))

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route(
    "/api/payment-plans/installments/<int:installment_id>/waive", methods=["POST"]
)
@require_staff()
def api_payment_plans_waive_installment(installment_id):
    """Waive an installment"""
    try:
        from services.payment_plan_service import PaymentPlanService

        data = request.get_json() or {}

        service = PaymentPlanService()
        result = service.waive_installment(installment_id, reason=data.get("reason"))

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/dashboard", methods=["GET"])
@require_staff()
def api_payment_plans_dashboard():
    """Get payment plans dashboard summary"""
    try:
        from services.payment_plan_service import PaymentPlanService

        service = PaymentPlanService()
        summary = service.get_dashboard_summary()

        return jsonify({"success": True, **summary})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/due-soon", methods=["GET"])
@require_staff()
def api_payment_plans_due_soon():
    """Get installments due soon"""
    try:
        from services.payment_plan_service import PaymentPlanService

        days = request.args.get("days", 7, type=int)

        service = PaymentPlanService()
        result = service.get_due_soon(days=days)

        return jsonify({"success": True, "installments": result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/overdue", methods=["GET"])
@require_staff()
def api_payment_plans_overdue():
    """Get overdue installments"""
    try:
        from services.payment_plan_service import PaymentPlanService

        service = PaymentPlanService()
        result = service.get_overdue()

        return jsonify({"success": True, "installments": result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/check-late", methods=["POST"])
@require_staff()
def api_payment_plans_check_late():
    """Check for late payments and apply late fees"""
    try:
        from services.payment_plan_service import PaymentPlanService

        service = PaymentPlanService()
        result = service.check_late_payments()

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/payment-plans/export", methods=["GET"])
@require_staff()
def api_payment_plans_export():
    """Export payment plans as CSV"""
    try:
        import csv
        from io import StringIO

        from services.payment_plan_service import PaymentPlanService

        status = request.args.get("status")

        service = PaymentPlanService()
        data = service.export_plans(status=status)

        if not data:
            return jsonify({"success": False, "error": "No data to export"}), 404

        # Create CSV
        output = StringIO()
        writer = csv.DictWriter(output, fieldnames=data[0].keys())
        writer.writeheader()
        writer.writerows(data)

        response = make_response(output.getvalue())
        response.headers["Content-Type"] = "text/csv"
        response.headers["Content-Disposition"] = (
            "attachment; filename=payment_plans.csv"
        )

        return response
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/clients/<int:client_id>/payment-plans", methods=["GET"])
@require_staff()
def api_client_payment_plans(client_id):
    """Get payment plans for a specific client"""
    try:
        from services.payment_plan_service import PaymentPlanService

        service = PaymentPlanService()
        plans = service.get_client_plans(client_id)

        return jsonify({"success": True, "plans": plans})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/dashboard/payment-plans", methods=["GET"])
@require_staff()
def dashboard_payment_plans():
    """Payment Plans management dashboard"""
    return render_template("payment_plans.html")


# ==============================================================================
# BUREAU RESPONSE TRACKING ENDPOINTS (P24)
# ==============================================================================


@app.route("/api/bureau-tracking/dashboard", methods=["GET"])
@require_staff()
def api_bureau_tracking_dashboard():
    """Get bureau response tracking dashboard summary"""
    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()
    summary = service.get_dashboard_summary()

    return jsonify(summary)


@app.route("/api/bureau-tracking", methods=["GET"])
@require_staff()
def api_bureau_tracking_list():
    """List all bureau dispute tracking records"""
    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()
    bureau = request.args.get("bureau")
    status = request.args.get("status")
    client_id = request.args.get("client_id", type=int)

    if client_id:
        disputes = service.get_client_disputes(client_id, bureau=bureau, status=status)
    else:
        disputes = service.get_all_pending(bureau=bureau)

    return jsonify({"success": True, "disputes": disputes})


@app.route("/api/bureau-tracking", methods=["POST"])
@require_staff()
def api_bureau_tracking_create():
    """Track a new dispute sent to a bureau"""
    from datetime import datetime

    from services.bureau_response_service import BureauResponseService

    data = request.get_json()
    service = BureauResponseService()

    # Parse sent_date
    sent_date_str = data.get("sent_date")
    if sent_date_str:
        sent_date = datetime.strptime(sent_date_str, "%Y-%m-%d").date()
    else:
        sent_date = datetime.now().date()

    result = service.track_dispute_sent(
        client_id=data.get("client_id"),
        bureau=data.get("bureau"),
        sent_date=sent_date,
        dispute_round=data.get("dispute_round", 1),
        item_ids=data.get("item_ids"),
        sent_method=data.get("sent_method", "certified_mail"),
        tracking_number=data.get("tracking_number"),
        letter_id=data.get("letter_id"),
        certified_mail_id=data.get("certified_mail_id"),
        case_id=data.get("case_id"),
        is_complex=data.get("is_complex", False),
        sent_by_staff_id=session.get("staff_id"),
        notes=data.get("notes"),
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/bureau-tracking/<int:tracking_id>", methods=["GET"])
@require_staff()
def api_bureau_tracking_get(tracking_id):
    """Get a specific tracking record"""
    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()
    tracking = service.get_tracking(tracking_id)

    if tracking:
        return jsonify({"success": True, "tracking": tracking})
    return jsonify({"success": False, "error": "Tracking record not found"}), 404


@app.route("/api/bureau-tracking/<int:tracking_id>/delivery", methods=["POST"])
@require_staff()
def api_bureau_tracking_confirm_delivery(tracking_id):
    """Confirm delivery of dispute letter"""
    from datetime import datetime

    from services.bureau_response_service import BureauResponseService

    data = request.get_json() or {}
    service = BureauResponseService()

    delivery_date = None
    if data.get("delivery_date"):
        delivery_date = datetime.strptime(data["delivery_date"], "%Y-%m-%d").date()

    result = service.confirm_delivery(
        tracking_id=tracking_id,
        delivery_date=delivery_date,
        recalculate_deadline=data.get("recalculate_deadline", True),
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/bureau-tracking/<int:tracking_id>/response", methods=["POST"])
@require_staff()
def api_bureau_tracking_record_response(tracking_id):
    """Record a response received from bureau"""
    from datetime import datetime

    from services.bureau_response_service import BureauResponseService

    data = request.get_json()
    service = BureauResponseService()

    response_date_str = data.get("response_date")
    if response_date_str:
        response_date = datetime.strptime(response_date_str, "%Y-%m-%d").date()
    else:
        response_date = datetime.now().date()

    result = service.record_response(
        tracking_id=tracking_id,
        response_date=response_date,
        response_type=data.get("response_type"),
        items_deleted=data.get("items_deleted", 0),
        items_updated=data.get("items_updated", 0),
        items_verified=data.get("items_verified", 0),
        items_investigating=data.get("items_investigating", 0),
        response_document_id=data.get("response_document_id"),
        follow_up_required=data.get("follow_up_required", False),
        follow_up_type=data.get("follow_up_type"),
        notes=data.get("notes"),
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/bureau-tracking/<int:tracking_id>/link-response", methods=["POST"])
@require_staff()
def api_bureau_tracking_link_response(tracking_id):
    """Link a CRA response document to tracking record"""
    from services.bureau_response_service import BureauResponseService

    data = request.get_json()
    service = BureauResponseService()

    result = service.link_cra_response(
        tracking_id=tracking_id, cra_response_id=data.get("cra_response_id")
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/bureau-tracking/<int:tracking_id>/close", methods=["POST"])
@require_staff()
def api_bureau_tracking_close(tracking_id):
    """Close a tracking record"""
    from services.bureau_response_service import BureauResponseService

    data = request.get_json() or {}
    service = BureauResponseService()

    result = service.close_dispute(tracking_id=tracking_id, notes=data.get("notes"))

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/bureau-tracking/<int:tracking_id>/follow-up", methods=["POST"])
@require_staff()
def api_bureau_tracking_complete_followup(tracking_id):
    """Mark follow-up as completed"""
    from services.bureau_response_service import BureauResponseService

    data = request.get_json() or {}
    service = BureauResponseService()

    result = service.complete_follow_up(
        tracking_id=tracking_id, notes=data.get("notes")
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/bureau-tracking/check-overdue", methods=["POST"])
@require_staff()
def api_bureau_tracking_check_overdue():
    """Check for overdue disputes and update status"""
    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()
    result = service.check_overdue_disputes()

    return jsonify(result)


@app.route("/api/bureau-tracking/due-soon", methods=["GET"])
@require_staff()
def api_bureau_tracking_due_soon():
    """Get disputes due within N days"""
    from services.bureau_response_service import BureauResponseService

    days = request.args.get("days", 7, type=int)
    service = BureauResponseService()
    disputes = service.get_due_soon(days=days)

    return jsonify({"success": True, "disputes": disputes})


@app.route("/api/bureau-tracking/overdue", methods=["GET"])
@require_staff()
def api_bureau_tracking_overdue():
    """Get all overdue disputes"""
    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()
    disputes = service.get_overdue()

    return jsonify({"success": True, "disputes": disputes})


@app.route("/api/bureau-tracking/bureau-breakdown", methods=["GET"])
@require_staff()
def api_bureau_tracking_breakdown():
    """Get breakdown by bureau"""
    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()
    breakdown = service.get_bureau_breakdown()

    return jsonify({"success": True, "breakdown": breakdown})


@app.route("/api/bureau-tracking/export", methods=["GET"])
@require_staff()
def api_bureau_tracking_export():
    """Export tracking data as CSV"""
    import csv
    import io
    from datetime import datetime

    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()

    client_id = request.args.get("client_id", type=int)
    status = request.args.get("status")
    bureau = request.args.get("bureau")

    data = service.export_data(client_id=client_id, status=status, bureau=bureau)

    # Create CSV
    output = io.StringIO()
    if data:
        writer = csv.DictWriter(output, fieldnames=data[0].keys())
        writer.writeheader()
        writer.writerows(data)

    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = (
        f"attachment; filename=bureau_tracking_{datetime.now().strftime('%Y%m%d')}.csv"
    )
    response.headers["Content-Type"] = "text/csv"

    return response


@app.route("/api/clients/<int:client_id>/bureau-tracking", methods=["GET"])
@require_staff()
def api_client_bureau_tracking(client_id):
    """Get bureau tracking for a specific client"""
    from services.bureau_response_service import BureauResponseService

    service = BureauResponseService()
    bureau = request.args.get("bureau")
    dispute_round = request.args.get("round", type=int)

    disputes = service.get_client_disputes(
        client_id=client_id, bureau=bureau, dispute_round=dispute_round
    )

    return jsonify({"success": True, "disputes": disputes})


@app.route("/dashboard/bureau-tracking", methods=["GET"])
@require_staff()
def dashboard_bureau_tracking():
    """Bureau Response Tracking dashboard"""
    from services.bureau_response_service import BureauResponseService

    db = get_db()
    try:
        # Get dashboard summary stats
        stats = BureauResponseService.get_dashboard_summary(db)

        # Get bureau breakdown
        bureau_stats = BureauResponseService.get_bureau_breakdown(db)

        # Get all pending disputes for the table
        disputes = BureauResponseService.get_pending(db)

        # Get due soon (within 7 days)
        due_soon = BureauResponseService.get_due_soon(db, days=7)

        # Get overdue disputes
        overdue = BureauResponseService.get_overdue(db)

        # Get response type breakdown
        response_types = BureauResponseService.get_response_type_breakdown(db)

        # Get client list for the tracking modal
        clients = (
            db.query(Client)
            .filter(Client.dispute_status.notin_(["lead", "cancelled"]))
            .order_by(Client.name)
            .all()
        )

        return render_template(
            "bureau_tracking.html",
            active_page="bureau-tracking",
            stats=stats,
            bureau_stats=bureau_stats,
            disputes=disputes,
            due_soon=due_soon,
            overdue=overdue,
            response_types=response_types,
            clients=clients,
        )
    finally:
        db.close()


# =============================================================================
# LETTER TEMPLATE BUILDER ENDPOINTS (P26)
# =============================================================================


@app.route("/api/letter-templates", methods=["GET"])
@require_staff()
def api_letter_templates_list():
    """List letter templates with filtering"""
    from services.letter_template_service import LetterTemplateService

    category = request.args.get("category")
    dispute_round = request.args.get("dispute_round", type=int)
    target_type = request.args.get("target_type")
    is_active = request.args.get("is_active", "true").lower() == "true"
    search = request.args.get("search")
    limit = request.args.get("limit", 100, type=int)
    offset = request.args.get("offset", 0, type=int)

    service = LetterTemplateService()
    templates = service.list_templates(
        category=category,
        dispute_round=dispute_round,
        target_type=target_type,
        is_active=is_active,
        search=search,
        limit=limit,
        offset=offset,
    )

    return jsonify(
        {
            "success": True,
            "templates": templates,
            "count": len(templates),
        }
    )


@app.route("/api/letter-templates", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_letter_templates_create():
    """Create a new letter template"""
    from services.letter_template_service import LetterTemplateService

    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    required = ["name", "code", "category", "content"]
    for field in required:
        if not data.get(field):
            return (
                jsonify(
                    {"success": False, "error": f"Missing required field: {field}"}
                ),
                400,
            )

    service = LetterTemplateService()
    result = service.create_template(
        name=data["name"],
        code=data["code"],
        category=data["category"],
        content=data["content"],
        dispute_round=data.get("dispute_round"),
        target_type=data.get("target_type", "bureau"),
        subject=data.get("subject"),
        footer=data.get("footer"),
        variables=data.get("variables"),
        required_attachments=data.get("required_attachments"),
        recommended_for=data.get("recommended_for"),
        description=data.get("description"),
        instructions=data.get("instructions"),
        legal_basis=data.get("legal_basis"),
        is_system=False,
        created_by_staff_id=session.get("staff_id"),
    )

    if result.get("success"):
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/letter-templates/<int:template_id>", methods=["GET"])
@require_staff()
def api_letter_templates_get(template_id):
    """Get a single letter template"""
    from services.letter_template_service import LetterTemplateService

    service = LetterTemplateService()
    template = service.get_template(template_id)

    if not template:
        return jsonify({"success": False, "error": "Template not found"}), 404

    return jsonify(
        {
            "success": True,
            "template": template,
        }
    )


@app.route("/api/letter-templates/<int:template_id>", methods=["PUT"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_letter_templates_update(template_id):
    """Update a letter template"""
    from services.letter_template_service import LetterTemplateService

    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    service = LetterTemplateService()
    result = service.update_template(
        template_id=template_id,
        updates=data,
        change_summary=data.get("change_summary"),
        staff_id=session.get("staff_id"),
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/letter-templates/<int:template_id>", methods=["DELETE"])
@require_staff(roles=["admin"])
def api_letter_templates_delete(template_id):
    """Delete a letter template"""
    from services.letter_template_service import LetterTemplateService

    service = LetterTemplateService()
    result = service.delete_template(template_id)

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/letter-templates/<int:template_id>/duplicate", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_letter_templates_duplicate(template_id):
    """Duplicate an existing template"""
    from services.letter_template_service import LetterTemplateService

    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    if not data.get("new_name") or not data.get("new_code"):
        return (
            jsonify({"success": False, "error": "new_name and new_code are required"}),
            400,
        )

    service = LetterTemplateService()
    result = service.duplicate_template(
        template_id=template_id,
        new_name=data["new_name"],
        new_code=data["new_code"],
        staff_id=session.get("staff_id"),
    )

    if result.get("success"):
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/letter-templates/<int:template_id>/versions", methods=["GET"])
@require_staff()
def api_letter_templates_versions(template_id):
    """Get version history for a template"""
    from services.letter_template_service import LetterTemplateService

    service = LetterTemplateService()
    versions = service.get_template_versions(template_id)

    return jsonify(
        {
            "success": True,
            "versions": versions,
            "count": len(versions),
        }
    )


@app.route(
    "/api/letter-templates/<int:template_id>/restore/<int:version_id>", methods=["POST"]
)
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_letter_templates_restore(template_id, version_id):
    """Restore a template to a previous version"""
    from services.letter_template_service import LetterTemplateService

    service = LetterTemplateService()
    result = service.restore_version(
        template_id=template_id,
        version_id=version_id,
        staff_id=session.get("staff_id"),
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/letter-templates/<int:template_id>/render", methods=["POST"])
@require_staff()
def api_letter_templates_render(template_id):
    """Render a template with variables"""
    from services.letter_template_service import LetterTemplateService

    data = request.get_json()
    variables = data.get("variables", {}) if data else {}

    service = LetterTemplateService()
    result = service.render_template(template_id, variables)

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/letter-templates/generate", methods=["POST"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_letter_templates_generate():
    """Generate a letter from a template for a client"""
    from services.letter_template_service import LetterTemplateService

    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "No data provided"}), 400

    required = ["template_id", "client_id", "target_type", "target_name"]
    for field in required:
        if not data.get(field):
            return (
                jsonify(
                    {"success": False, "error": f"Missing required field: {field}"}
                ),
                400,
            )

    service = LetterTemplateService()
    result = service.generate_letter(
        template_id=data["template_id"],
        client_id=data["client_id"],
        target_type=data["target_type"],
        target_name=data["target_name"],
        custom_variables=data.get("custom_variables"),
        staff_id=session.get("staff_id"),
        case_id=data.get("case_id"),
    )

    if result.get("success"):
        return jsonify(result), 201
    return jsonify(result), 400


@app.route("/api/letter-templates/generated", methods=["GET"])
@require_staff()
def api_letter_templates_generated_list():
    """List generated letters"""
    from services.letter_template_service import LetterTemplateService

    client_id = request.args.get("client_id", type=int)
    template_id = request.args.get("template_id", type=int)
    status = request.args.get("status")
    limit = request.args.get("limit", 50, type=int)
    offset = request.args.get("offset", 0, type=int)

    service = LetterTemplateService()
    letters = service.list_generated_letters(
        client_id=client_id,
        template_id=template_id,
        status=status,
        limit=limit,
        offset=offset,
    )

    return jsonify(
        {
            "success": True,
            "letters": letters,
            "count": len(letters),
        }
    )


@app.route("/api/letter-templates/generated/<int:letter_id>", methods=["GET"])
@require_staff()
def api_letter_templates_generated_get(letter_id):
    """Get a generated letter"""
    from services.letter_template_service import LetterTemplateService

    service = LetterTemplateService()
    letter = service.get_generated_letter(letter_id)

    if not letter:
        return jsonify({"success": False, "error": "Letter not found"}), 404

    return jsonify(
        {
            "success": True,
            "letter": letter,
        }
    )


@app.route("/api/letter-templates/generated/<int:letter_id>/status", methods=["PUT"])
@require_staff(roles=["admin", "attorney", "paralegal"])
def api_letter_templates_generated_status(letter_id):
    """Update generated letter status"""
    from services.letter_template_service import LetterTemplateService

    data = request.get_json()
    if not data or not data.get("status"):
        return jsonify({"success": False, "error": "Status is required"}), 400

    service = LetterTemplateService()
    result = service.update_letter_status(
        letter_id=letter_id,
        status=data["status"],
        sent_method=data.get("sent_method"),
        tracking_number=data.get("tracking_number"),
        staff_id=session.get("staff_id"),
    )

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/api/letter-templates/dashboard", methods=["GET"])
@require_staff()
def api_letter_templates_dashboard():
    """Get dashboard summary for letter templates"""
    from services.letter_template_service import LetterTemplateService

    service = LetterTemplateService()
    summary = service.get_dashboard_summary()

    return jsonify(
        {
            "success": True,
            **summary,
        }
    )


@app.route("/api/letter-templates/categories", methods=["GET"])
@require_staff()
def api_letter_templates_categories():
    """Get available template categories"""
    from services.letter_template_service import LetterTemplateService

    return jsonify(
        {
            "success": True,
            "categories": LetterTemplateService.get_categories(),
        }
    )


@app.route("/api/letter-templates/target-types", methods=["GET"])
@require_staff()
def api_letter_templates_target_types():
    """Get available target types"""
    from services.letter_template_service import LetterTemplateService

    return jsonify(
        {
            "success": True,
            "target_types": LetterTemplateService.get_target_types(),
        }
    )


@app.route("/api/letter-templates/variables", methods=["GET"])
@require_staff()
def api_letter_templates_variables():
    """Get common template variables"""
    from services.letter_template_service import LetterTemplateService

    return jsonify(
        {
            "success": True,
            "variables": LetterTemplateService.get_common_variables(),
        }
    )


@app.route("/api/letter-templates/client-variables/<int:client_id>", methods=["GET"])
@require_staff()
def api_letter_templates_client_variables(client_id):
    """Get variable values for a specific client"""
    from services.letter_template_service import LetterTemplateService

    bureau = request.args.get("bureau")

    service = LetterTemplateService()
    variables = service.get_client_variables(client_id, bureau)

    return jsonify(
        {
            "success": True,
            "variables": variables,
        }
    )


@app.route("/api/letter-templates/seed", methods=["POST"])
@require_staff(roles=["admin"])
def api_letter_templates_seed():
    """Seed default letter templates"""
    from services.letter_template_service import LetterTemplateService

    service = LetterTemplateService()
    result = service.seed_default_templates()

    if result.get("success"):
        return jsonify(result)
    return jsonify(result), 400


@app.route("/dashboard/letter-templates", methods=["GET"])
@require_staff()
def dashboard_letter_templates():
    """Letter Template Builder dashboard page"""
    from services.letter_template_service import (
        CATEGORIES,
        TARGET_TYPES,
        LetterTemplateService,
    )

    service = LetterTemplateService()
    summary = service.get_dashboard_summary()
    templates = service.list_templates(is_active=True)

    db = get_db()
    try:
        clients = (
            db.query(Client)
            .filter(Client.dispute_status.notin_(["lead", "cancelled"]))
            .order_by(Client.name)
            .all()
        )

        return render_template(
            "letter_templates.html",
            active_page="letter-templates",
            stats=summary,
            templates=templates,
            categories=CATEGORIES,
            target_types=TARGET_TYPES,
            clients=clients,
        )
    finally:
        db.close()


# ==================== VOICEMAIL DROP ENDPOINTS ====================


@app.route("/api/voicemail/recordings", methods=["GET"])
@require_staff()
def api_voicemail_recordings_list():
    """List all voicemail recordings"""
    from services.voicemail_drop_service import (
        VOICEMAIL_CATEGORIES,
        get_voicemail_drop_service,
    )

    service = get_voicemail_drop_service()
    try:
        category = request.args.get("category")
        active_only = request.args.get("active", "true").lower() == "true"

        recordings = service.get_recordings(category=category, active_only=active_only)
        return jsonify(
            {
                "success": True,
                "recordings": [r.to_dict() for r in recordings],
                "categories": VOICEMAIL_CATEGORIES,
            }
        )
    finally:
        service.db.close()


@app.route("/api/voicemail/recordings", methods=["POST"])
@require_staff()
def api_voicemail_recordings_create():
    """Create a new voicemail recording"""
    import os

    from werkzeug.utils import secure_filename

    from services.voicemail_drop_service import get_voicemail_drop_service

    # Check for file upload
    if "file" not in request.files:
        return jsonify({"success": False, "error": "No file uploaded"}), 400

    file = request.files["file"]
    if file.filename == "":
        return jsonify({"success": False, "error": "No file selected"}), 400

    # Validate file type
    allowed_extensions = {"mp3", "wav", "m4a"}
    ext = file.filename.rsplit(".", 1)[-1].lower() if "." in file.filename else ""
    if ext not in allowed_extensions:
        return (
            jsonify(
                {
                    "success": False,
                    "error": f'Invalid file type. Allowed: {", ".join(allowed_extensions)}',
                }
            ),
            400,
        )

    # Save file
    filename = secure_filename(file.filename)
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    filename = f"{timestamp}_{filename}"

    upload_dir = os.path.join("static", "voicemail")
    os.makedirs(upload_dir, exist_ok=True)
    file_path = os.path.join(upload_dir, filename)
    file.save(file_path)

    # Get file size
    file_size = os.path.getsize(file_path)

    service = get_voicemail_drop_service()
    try:
        recording = service.create_recording(
            name=request.form.get("name", filename),
            description=request.form.get("description"),
            category=request.form.get("category", "custom"),
            file_path=f"/static/voicemail/{filename}",
            file_name=filename,
            file_size_bytes=file_size,
            duration_seconds=int(request.form.get("duration", 0)) or None,
            format=ext,
            staff_id=session.get("staff_id"),
        )

        return jsonify({"success": True, "recording": recording.to_dict()}), 201
    finally:
        service.db.close()


@app.route("/api/voicemail/recordings/<int:recording_id>", methods=["GET"])
@require_staff()
def api_voicemail_recording_get(recording_id):
    """Get a specific recording"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        recording = service.get_recording(recording_id)
        if not recording:
            return jsonify({"success": False, "error": "Recording not found"}), 404

        return jsonify({"success": True, "recording": recording.to_dict()})
    finally:
        service.db.close()


@app.route("/api/voicemail/recordings/<int:recording_id>", methods=["PUT"])
@require_staff()
def api_voicemail_recording_update(recording_id):
    """Update a recording"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    data = request.get_json() or {}
    service = get_voicemail_drop_service()
    try:
        recording = service.update_recording(
            recording_id,
            name=data.get("name"),
            description=data.get("description"),
            category=data.get("category"),
            is_active=data.get("is_active"),
        )

        if not recording:
            return jsonify({"success": False, "error": "Recording not found"}), 404

        return jsonify({"success": True, "recording": recording.to_dict()})
    finally:
        service.db.close()


@app.route("/api/voicemail/recordings/<int:recording_id>", methods=["DELETE"])
@require_staff()
def api_voicemail_recording_delete(recording_id):
    """Delete (deactivate) a recording"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        result = service.delete_recording(recording_id)
        status = 200 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/drops", methods=["GET"])
@require_staff()
def api_voicemail_drops_list():
    """List voicemail drops with filters"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        drops = service.get_drops(
            client_id=request.args.get("client_id", type=int),
            recording_id=request.args.get("recording_id", type=int),
            status=request.args.get("status"),
            provider=request.args.get("provider"),
            limit=request.args.get("limit", 100, type=int),
            offset=request.args.get("offset", 0, type=int),
        )

        return jsonify({"success": True, "drops": [d.to_dict() for d in drops]})
    finally:
        service.db.close()


@app.route("/api/voicemail/drops", methods=["POST"])
@require_staff()
def api_voicemail_drops_send():
    """Send a voicemail drop"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "Request body required"}), 400

    if not data.get("recording_id") or not data.get("client_id"):
        return (
            jsonify({"success": False, "error": "recording_id and client_id required"}),
            400,
        )

    # Parse scheduled time if provided
    scheduled_at = None
    if data.get("scheduled_at"):
        try:
            scheduled_at = datetime.fromisoformat(
                data["scheduled_at"].replace("Z", "+00:00")
            )
        except ValueError:
            return (
                jsonify({"success": False, "error": "Invalid scheduled_at format"}),
                400,
            )

    service = get_voicemail_drop_service()
    try:
        result = service.send_drop(
            recording_id=data["recording_id"],
            client_id=data["client_id"],
            phone_number=data.get("phone_number"),
            trigger_type=data.get("trigger_type", "manual"),
            trigger_event=data.get("trigger_event"),
            scheduled_at=scheduled_at,
            staff_id=session.get("staff_id"),
            provider=data.get("provider"),
        )

        status = 201 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/drops/<int:drop_id>", methods=["GET"])
@require_staff()
def api_voicemail_drop_get(drop_id):
    """Get a specific drop"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        drop = service.get_drop(drop_id)
        if not drop:
            return jsonify({"success": False, "error": "Drop not found"}), 404

        return jsonify({"success": True, "drop": drop.to_dict()})
    finally:
        service.db.close()


@app.route("/api/voicemail/drops/<int:drop_id>/retry", methods=["POST"])
@require_staff()
def api_voicemail_drop_retry(drop_id):
    """Retry a failed drop"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        result = service.retry_drop(drop_id)
        status = 200 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/drops/<int:drop_id>/cancel", methods=["POST"])
@require_staff()
def api_voicemail_drop_cancel(drop_id):
    """Cancel a pending drop"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        result = service.cancel_drop(drop_id)
        status = 200 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/clients/<int:client_id>/history", methods=["GET"])
@require_staff()
def api_voicemail_client_history(client_id):
    """Get voicemail drop history for a client"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        history = service.get_client_drop_history(
            client_id, limit=request.args.get("limit", 20, type=int)
        )
        return jsonify({"success": True, "history": history})
    finally:
        service.db.close()


@app.route("/api/voicemail/campaigns", methods=["GET"])
@require_staff()
def api_voicemail_campaigns_list():
    """List all campaigns"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        campaigns = service.get_campaigns(status=request.args.get("status"))
        return jsonify({"success": True, "campaigns": [c.to_dict() for c in campaigns]})
    finally:
        service.db.close()


@app.route("/api/voicemail/campaigns", methods=["POST"])
@require_staff()
def api_voicemail_campaigns_create():
    """Create a new campaign"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    data = request.get_json()
    if not data:
        return jsonify({"success": False, "error": "Request body required"}), 400

    if not data.get("name") or not data.get("recording_id"):
        return (
            jsonify({"success": False, "error": "name and recording_id required"}),
            400,
        )

    # Parse scheduled time if provided
    scheduled_at = None
    if data.get("scheduled_at"):
        try:
            scheduled_at = datetime.fromisoformat(
                data["scheduled_at"].replace("Z", "+00:00")
            )
        except ValueError:
            return (
                jsonify({"success": False, "error": "Invalid scheduled_at format"}),
                400,
            )

    service = get_voicemail_drop_service()
    try:
        campaign = service.create_campaign(
            name=data["name"],
            recording_id=data["recording_id"],
            description=data.get("description"),
            target_type=data.get("target_type", "manual"),
            target_filters=data.get("target_filters"),
            scheduled_at=scheduled_at,
            send_window_start=data.get("send_window_start"),
            send_window_end=data.get("send_window_end"),
            send_days=data.get("send_days"),
            staff_id=session.get("staff_id"),
        )

        return jsonify({"success": True, "campaign": campaign.to_dict()}), 201
    finally:
        service.db.close()


@app.route("/api/voicemail/campaigns/<int:campaign_id>", methods=["GET"])
@require_staff()
def api_voicemail_campaign_get(campaign_id):
    """Get a specific campaign"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        campaign = service.get_campaign(campaign_id)
        if not campaign:
            return jsonify({"success": False, "error": "Campaign not found"}), 404

        return jsonify({"success": True, "campaign": campaign.to_dict()})
    finally:
        service.db.close()


@app.route("/api/voicemail/campaigns/<int:campaign_id>/targets", methods=["POST"])
@require_staff()
def api_voicemail_campaign_add_targets(campaign_id):
    """Add targets to a campaign"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    data = request.get_json()
    if not data or not data.get("client_ids"):
        return jsonify({"success": False, "error": "client_ids array required"}), 400

    service = get_voicemail_drop_service()
    try:
        result = service.add_targets_to_campaign(campaign_id, data["client_ids"])
        status = 200 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/campaigns/<int:campaign_id>/start", methods=["POST"])
@require_staff()
def api_voicemail_campaign_start(campaign_id):
    """Start a campaign"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        result = service.start_campaign(campaign_id)
        status = 200 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/campaigns/<int:campaign_id>/pause", methods=["POST"])
@require_staff()
def api_voicemail_campaign_pause(campaign_id):
    """Pause a campaign"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        result = service.pause_campaign(campaign_id)
        status = 200 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/campaigns/<int:campaign_id>/cancel", methods=["POST"])
@require_staff()
def api_voicemail_campaign_cancel(campaign_id):
    """Cancel a campaign"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        result = service.cancel_campaign(campaign_id)
        status = 200 if result["success"] else 400
        return jsonify(result), status
    finally:
        service.db.close()


@app.route("/api/voicemail/stats", methods=["GET"])
@require_staff()
def api_voicemail_stats():
    """Get voicemail drop statistics"""
    from services.voicemail_drop_service import get_voicemail_drop_service

    service = get_voicemail_drop_service()
    try:
        stats = service.get_stats()
        return jsonify({"success": True, "stats": stats})
    finally:
        service.db.close()


@app.route("/dashboard/voicemail", methods=["GET"])
@require_staff()
def dashboard_voicemail():
    """Voicemail Drops dashboard page"""
    from services.voicemail_drop_service import (
        VOICEMAIL_CATEGORIES,
        get_voicemail_drop_service,
    )

    service = get_voicemail_drop_service()
    try:
        stats = service.get_stats()
        recordings = service.get_recordings(active_only=True, limit=50)
        recent_drops = service.get_drops(limit=20)
        campaigns = service.get_campaigns(limit=10)

        db = get_db()
        try:
            clients = (
                db.query(Client)
                .filter(
                    Client.phone.isnot(None),
                    Client.dispute_status.notin_(["lead", "cancelled"]),
                )
                .order_by(Client.name)
                .all()
            )

            return render_template(
                "voicemail_drops.html",
                active_page="voicemail",
                stats=stats,
                recordings=recordings,
                recent_drops=recent_drops,
                campaigns=campaigns,
                categories=VOICEMAIL_CATEGORIES,
                clients=clients,
            )
        finally:
            db.close()
    finally:
        service.db.close()


# ===========================================================================
# UNIFIED INBOX API (P32)
# ===========================================================================


@app.route("/dashboard/unified-inbox")
@require_staff()
def dashboard_unified_inbox():
    """Unified Inbox dashboard page"""
    from database import Client, Staff
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    db = get_db()

    try:
        # Get current staff
        staff_id = session.get("staff_id")

        # Get dashboard stats
        stats = service.get_dashboard_stats(staff_id=staff_id)

        # Get unread counts
        unread = service.get_unread_counts(staff_id=staff_id)

        # Get clients for filter dropdown
        client_query = (
            db.query(Client)
            .filter(Client.dispute_status.notin_(["lead", "cancelled"]))
            .order_by(Client.name)
        )

        if staff_id:
            client_query = client_query.filter(Client.assigned_to == staff_id)

        clients = client_query.limit(100).all()

        return render_template(
            "unified_inbox.html",
            active_page="unified-inbox",
            stats=stats,
            unread=unread,
            clients=clients,
        )
    finally:
        db.close()


@app.route("/api/inbox", methods=["GET"])
@require_staff()
def api_inbox_list():
    """Get inbox messages with filters"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        staff_id = session.get("staff_id")

        # Parse filters
        channels = request.args.getlist("channel") or None
        is_read = request.args.get("is_read")
        if is_read is not None:
            is_read = is_read.lower() == "true"
        search = request.args.get("search")
        limit = int(request.args.get("limit", 50))
        offset = int(request.args.get("offset", 0))

        result = service.get_staff_inbox(
            staff_id=staff_id,
            channels=channels,
            is_read=is_read,
            search_query=search,
            limit=limit,
            offset=offset,
        )

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/client/<int:client_id>", methods=["GET"])
@require_staff()
def api_inbox_client(client_id):
    """Get inbox messages for a specific client"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        channels = request.args.getlist("channel") or None
        direction = request.args.get("direction")
        is_read = request.args.get("is_read")
        if is_read is not None:
            is_read = is_read.lower() == "true"
        search = request.args.get("search")
        limit = int(request.args.get("limit", 50))
        offset = int(request.args.get("offset", 0))

        result = service.get_client_inbox(
            client_id=client_id,
            channels=channels,
            direction=direction,
            is_read=is_read,
            search_query=search,
            limit=limit,
            offset=offset,
        )

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/client/<int:client_id>/thread", methods=["GET"])
@require_staff()
def api_inbox_client_thread(client_id):
    """Get conversation thread for a client"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        channels = request.args.getlist("channel") or None
        limit = int(request.args.get("limit", 100))

        result = service.get_conversation_thread(
            client_id=client_id, include_channels=channels, limit=limit
        )

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/search", methods=["GET"])
@require_staff()
def api_inbox_search():
    """Search messages across all channels"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        query = request.args.get("q", "")
        client_id = request.args.get("client_id", type=int)
        channels = request.args.getlist("channel") or None
        limit = int(request.args.get("limit", 50))

        messages = service.search_messages(
            query=query, client_id=client_id, channels=channels, limit=limit
        )

        return jsonify(
            {
                "success": True,
                "messages": messages,
                "total": len(messages),
                "query": query,
            }
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/unread", methods=["GET"])
@require_staff()
def api_inbox_unread():
    """Get unread message counts by channel"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        staff_id = session.get("staff_id")
        client_id = request.args.get("client_id", type=int)

        counts = service.get_unread_counts(
            client_id=client_id, staff_id=staff_id if not client_id else None
        )

        return jsonify({"success": True, "counts": counts})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/stats", methods=["GET"])
@require_staff()
def api_inbox_stats():
    """Get inbox dashboard statistics"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        staff_id = session.get("staff_id")
        days = int(request.args.get("days", 7))

        stats = service.get_dashboard_stats(staff_id=staff_id, days=days)

        return jsonify({"success": True, "stats": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/<int:message_id>/read", methods=["PUT"])
@require_staff()
def api_inbox_mark_read(message_id):
    """Mark a message as read"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        staff_id = session.get("staff_id")
        channel = request.json.get("channel", "portal")

        success = service.mark_read(
            channel=channel, message_id=message_id, read_by_staff_id=staff_id
        )

        return jsonify({"success": success})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/client/<int:client_id>/read-all", methods=["PUT"])
@require_staff()
def api_inbox_mark_all_read(client_id):
    """Mark all messages from a client as read"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        staff_id = session.get("staff_id")
        channel = request.json.get("channel") if request.json else None

        count = service.mark_client_messages_read(
            client_id=client_id, channel=channel, read_by_staff_id=staff_id
        )

        return jsonify({"success": True, "marked_read": count})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/inbox/reply", methods=["POST"])
@require_staff()
def api_inbox_reply():
    """Send a reply to a client through specified channel"""
    from services.unified_inbox_service import get_unified_inbox_service

    service = get_unified_inbox_service()
    try:
        staff_id = session.get("staff_id")
        data = request.json

        client_id = data.get("client_id")
        channel = data.get("channel", "portal")
        content = data.get("content", "")
        subject = data.get("subject")

        if not client_id:
            return jsonify({"success": False, "error": "client_id is required"}), 400
        if not content:
            return jsonify({"success": False, "error": "content is required"}), 400

        result = service.send_reply(
            client_id=client_id,
            channel=channel,
            content=content,
            staff_id=staff_id,
            subject=subject,
        )

        return jsonify(result)
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# END UNIFIED INBOX API
# ===========================================================================


# ===========================================================================
# CALL LOGGING API (P34)
# ===========================================================================


@app.route("/api/call-logs", methods=["GET"])
@require_staff()
def api_get_call_logs():
    """Get call logs with filtering"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)

        # Parse query parameters
        client_id = request.args.get("client_id", type=int)
        staff_id = request.args.get("staff_id", type=int)
        direction = request.args.get("direction")
        status = request.args.get("status")
        outcome = request.args.get("outcome")
        follow_up = request.args.get("follow_up_required")
        follow_up_required = follow_up.lower() == "true" if follow_up else None
        date_from = request.args.get("date_from")
        date_to = request.args.get("date_to")
        search = request.args.get("search")
        limit = request.args.get("limit", 50, type=int)
        offset = request.args.get("offset", 0, type=int)

        # Parse dates
        from datetime import date as date_type

        date_from_parsed = date_type.fromisoformat(date_from) if date_from else None
        date_to_parsed = date_type.fromisoformat(date_to) if date_to else None

        result = service.get_call_logs(
            client_id=client_id,
            staff_id=staff_id,
            direction=direction,
            status=status,
            outcome=outcome,
            follow_up_required=follow_up_required,
            date_from=date_from_parsed,
            date_to=date_to_parsed,
            search=search,
            limit=limit,
            offset=offset,
        )

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs", methods=["POST"])
@require_staff()
def api_create_call_log():
    """Create a new call log"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)
        data = request.json

        # Get staff ID from session
        staff_id = data.get("staff_id") or session.get("staff_id")
        if not staff_id:
            return jsonify({"success": False, "error": "Staff ID required"}), 400

        # Parse datetime
        call_started_at = (
            datetime.fromisoformat(data.get("call_started_at"))
            if data.get("call_started_at")
            else datetime.now()
        )
        call_ended_at = (
            datetime.fromisoformat(data.get("call_ended_at"))
            if data.get("call_ended_at")
            else None
        )

        # Parse follow-up date
        from datetime import date as date_type

        follow_up_date = (
            date_type.fromisoformat(data.get("follow_up_date"))
            if data.get("follow_up_date")
            else None
        )

        result = service.create_call_log(
            staff_id=staff_id,
            direction=data.get("direction", "outbound"),
            call_started_at=call_started_at,
            client_id=data.get("client_id"),
            phone_number=data.get("phone_number"),
            call_ended_at=call_ended_at,
            duration_seconds=data.get("duration_seconds"),
            status=data.get("status", "completed"),
            outcome=data.get("outcome"),
            subject=data.get("subject"),
            notes=data.get("notes"),
            follow_up_required=data.get("follow_up_required", False),
            follow_up_date=follow_up_date,
            follow_up_notes=data.get("follow_up_notes"),
            recording_url=data.get("recording_url"),
            recording_duration=data.get("recording_duration"),
        )

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/<int:call_log_id>", methods=["GET"])
@require_staff()
def api_get_call_log(call_log_id):
    """Get a single call log"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)
        call_log = service.get_call_log(call_log_id)

        if not call_log:
            return jsonify({"success": False, "error": "Call log not found"}), 404

        return jsonify({"success": True, "call_log": call_log})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/<int:call_log_id>", methods=["PUT"])
@require_staff()
def api_update_call_log(call_log_id):
    """Update a call log"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)
        data = request.json

        # Parse datetime fields if present
        if data.get("call_ended_at"):
            data["call_ended_at"] = datetime.fromisoformat(data["call_ended_at"])

        # Parse follow-up date if present
        if data.get("follow_up_date"):
            from datetime import date as date_type

            data["follow_up_date"] = date_type.fromisoformat(data["follow_up_date"])

        result = service.update_call_log(call_log_id, **data)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/<int:call_log_id>", methods=["DELETE"])
@require_staff()
def api_delete_call_log(call_log_id):
    """Delete a call log"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)
        result = service.delete_call_log(call_log_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/<int:call_log_id>/complete-follow-up", methods=["POST"])
@require_staff()
def api_complete_call_follow_up(call_log_id):
    """Mark a call follow-up as complete"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)
        result = service.mark_follow_up_complete(call_log_id)

        if result.get("success"):
            return jsonify(result)
        return jsonify(result), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/pending-follow-ups", methods=["GET"])
@require_staff()
def api_get_pending_follow_ups():
    """Get all pending follow-ups"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)

        staff_id = request.args.get("staff_id", type=int)
        include_overdue = request.args.get("include_overdue", "true").lower() == "true"

        follow_ups = service.get_pending_follow_ups(
            staff_id=staff_id, include_overdue=include_overdue
        )

        return jsonify(
            {"success": True, "follow_ups": follow_ups, "total": len(follow_ups)}
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/statistics", methods=["GET"])
@require_staff()
def api_get_call_statistics():
    """Get call statistics"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)

        date_from = request.args.get("date_from")
        date_to = request.args.get("date_to")

        from datetime import date as date_type

        date_from_parsed = date_type.fromisoformat(date_from) if date_from else None
        date_to_parsed = date_type.fromisoformat(date_to) if date_to else None

        stats = service.get_call_statistics(
            date_from=date_from_parsed, date_to=date_to_parsed
        )

        return jsonify({"success": True, **stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/staff/<int:staff_id>/activity", methods=["GET"])
@require_staff()
def api_get_staff_call_activity(staff_id):
    """Get call activity for a specific staff member"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)

        date_from = request.args.get("date_from")
        date_to = request.args.get("date_to")

        from datetime import date as date_type

        date_from_parsed = date_type.fromisoformat(date_from) if date_from else None
        date_to_parsed = date_type.fromisoformat(date_to) if date_to else None

        activity = service.get_staff_call_activity(
            staff_id=staff_id, date_from=date_from_parsed, date_to=date_to_parsed
        )

        return jsonify({"success": True, **activity})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/clients/<int:client_id>/call-history", methods=["GET"])
@require_staff()
def api_get_client_call_history(client_id):
    """Get call history for a specific client"""
    from services.call_log_service import get_call_log_service

    db = get_db()
    try:
        service = get_call_log_service(db)
        limit = request.args.get("limit", 20, type=int)

        call_logs = service.get_client_call_history(client_id, limit=limit)

        return jsonify(
            {"success": True, "call_logs": call_logs, "total": len(call_logs)}
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        db.close()


@app.route("/api/call-logs/options", methods=["GET"])
@require_staff()
def api_get_call_log_options():
    """Get available options for call log dropdowns"""
    from services.call_log_service import CallLogService

    return jsonify(
        {
            "success": True,
            "directions": CallLogService.DIRECTIONS,
            "statuses": CallLogService.STATUSES,
            "outcomes": CallLogService.OUTCOMES,
        }
    )


@app.route("/dashboard/call-logs")
@require_staff()
def dashboard_call_logs():
    """Call logs dashboard page"""
    return render_template("call_logs.html")


# END CALL LOGGING API
# ===========================================================================


# ===========================================================================
# STAFF TASK ASSIGNMENT API
# ===========================================================================
from services.task_service import TaskService


@app.route("/api/staff-tasks", methods=["GET"])
@require_staff()
def api_get_staff_tasks():
    """Get paginated list of staff tasks with filtering"""
    try:
        # Get filter parameters
        status = request.args.get("status")
        priority = request.args.get("priority")
        category = request.args.get("category")
        assigned_to_id = request.args.get("assigned_to_id", type=int)
        client_id = request.args.get("client_id", type=int)
        created_by_id = request.args.get("created_by_id", type=int)
        search = request.args.get("search")
        overdue_only = request.args.get("overdue_only", "false").lower() == "true"
        page = request.args.get("page", 1, type=int)
        per_page = request.args.get("per_page", 20, type=int)

        result = TaskService.get_tasks(
            status=status,
            priority=priority,
            category=category,
            assigned_to_id=assigned_to_id,
            client_id=client_id,
            created_by_id=created_by_id,
            search=search,
            overdue_only=overdue_only,
            page=page,
            per_page=per_page,
        )

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks", methods=["POST"])
@require_staff()
def api_create_staff_task():
    """Create a new staff task"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        # Validate required fields
        if not data.get("title"):
            return jsonify({"success": False, "error": "Title is required"}), 400

        # Get current staff ID
        staff = get_current_staff()
        if not staff:
            return (
                jsonify({"success": False, "error": "Staff authentication required"}),
                401,
            )

        task = TaskService.create_task(
            title=data.get("title"),
            description=data.get("description"),
            category=data.get("category", "general"),
            priority=data.get("priority", "medium"),
            assigned_to_id=data.get("assigned_to_id"),
            client_id=data.get("client_id"),
            created_by_id=staff.id,
            due_date=data.get("due_date"),
            is_recurring=data.get("is_recurring", False),
            recurrence_pattern=data.get("recurrence_pattern"),
            tags=data.get("tags"),
        )

        return jsonify({"success": True, "task": task})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>", methods=["GET"])
@require_staff()
def api_get_staff_task(task_id):
    """Get a single staff task by ID"""
    try:
        task = TaskService.get_task(task_id)
        if not task:
            return jsonify({"success": False, "error": "Task not found"}), 404

        return jsonify({"success": True, "task": task})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>", methods=["PUT"])
@require_staff()
def api_update_staff_task(task_id):
    """Update a staff task"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        task = TaskService.update_task(task_id, data)
        if not task:
            return jsonify({"success": False, "error": "Task not found"}), 404

        return jsonify({"success": True, "task": task})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>", methods=["DELETE"])
@require_staff()
def api_delete_staff_task(task_id):
    """Delete a staff task"""
    try:
        success = TaskService.delete_task(task_id)
        if not success:
            return jsonify({"success": False, "error": "Task not found"}), 404

        return jsonify({"success": True, "message": "Task deleted successfully"})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>/complete", methods=["POST"])
@require_staff()
def api_complete_staff_task(task_id):
    """Mark a staff task as completed"""
    try:
        staff = get_current_staff()
        if not staff:
            return (
                jsonify({"success": False, "error": "Staff authentication required"}),
                401,
            )

        task = TaskService.complete_task(task_id, staff.id)
        if not task:
            return jsonify({"success": False, "error": "Task not found"}), 404

        return jsonify({"success": True, "task": task})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>/reopen", methods=["POST"])
@require_staff()
def api_reopen_staff_task(task_id):
    """Reopen a completed/cancelled staff task"""
    try:
        task = TaskService.reopen_task(task_id)
        if not task:
            return jsonify({"success": False, "error": "Task not found"}), 404

        return jsonify({"success": True, "task": task})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>/assign", methods=["POST"])
@require_staff()
def api_assign_staff_task(task_id):
    """Assign a staff task to a staff member"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        assigned_to_id = data.get("assigned_to_id")
        if not assigned_to_id:
            return (
                jsonify({"success": False, "error": "assigned_to_id is required"}),
                400,
            )

        task = TaskService.assign_task(task_id, assigned_to_id)
        if not task:
            return jsonify({"success": False, "error": "Task not found"}), 404

        return jsonify({"success": True, "task": task})
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 400
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/my-tasks", methods=["GET"])
@require_staff()
def api_get_my_staff_tasks():
    """Get current user's assigned staff tasks"""
    try:
        staff = get_current_staff()
        if not staff:
            return (
                jsonify({"success": False, "error": "Staff authentication required"}),
                401,
            )

        include_completed = (
            request.args.get("include_completed", "false").lower() == "true"
        )

        result = TaskService.get_my_tasks(staff.id, include_completed=include_completed)

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/team-workload", methods=["GET"])
@require_staff()
def api_get_staff_team_workload():
    """Get team workload statistics"""
    try:
        result = TaskService.get_team_workload()

        return jsonify({"success": True, "workload": result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>/comments", methods=["GET"])
@require_staff()
def api_get_staff_task_comments(task_id):
    """Get comments for a staff task"""
    try:
        comments = TaskService.get_task_comments(task_id)

        return jsonify({"success": True, "comments": comments})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/<int:task_id>/comments", methods=["POST"])
@require_staff()
def api_add_staff_task_comment(task_id):
    """Add a comment to a staff task"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "error": "No data provided"}), 400

        content = data.get("content")
        if not content:
            return (
                jsonify({"success": False, "error": "Comment content is required"}),
                400,
            )

        staff = get_current_staff()
        if not staff:
            return (
                jsonify({"success": False, "error": "Staff authentication required"}),
                401,
            )

        comment = TaskService.add_comment(task_id, staff.id, content)
        if not comment:
            return jsonify({"success": False, "error": "Task not found"}), 404

        return jsonify({"success": True, "comment": comment})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/statistics", methods=["GET"])
@require_staff()
def api_get_staff_task_statistics():
    """Get staff task statistics"""
    try:
        staff_id = request.args.get("staff_id", type=int)
        days = request.args.get("days", 30, type=int)

        stats = TaskService.get_task_statistics(staff_id=staff_id, days=days)

        return jsonify({"success": True, "statistics": stats})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/overdue", methods=["GET"])
@require_staff()
def api_get_overdue_staff_tasks():
    """Get all overdue staff tasks"""
    try:
        tasks = TaskService.get_overdue_tasks()

        return jsonify({"success": True, "tasks": tasks})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/due-today", methods=["GET"])
@require_staff()
def api_get_staff_tasks_due_today():
    """Get all staff tasks due today"""
    try:
        tasks = TaskService.get_tasks_due_today()

        return jsonify({"success": True, "tasks": tasks})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/recurring/process", methods=["POST"])
@require_staff()
def api_process_recurring_staff_tasks():
    """Process recurring staff tasks and create new instances"""
    try:
        result = TaskService.process_recurring_tasks()

        return jsonify({"success": True, **result})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/clients/<int:client_id>/staff-tasks", methods=["GET"])
@require_staff()
def api_get_client_staff_tasks(client_id):
    """Get all staff tasks for a specific client"""
    try:
        tasks = TaskService.get_client_tasks(client_id)

        return jsonify({"success": True, "tasks": tasks})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route("/api/staff-tasks/options", methods=["GET"])
@require_staff()
def api_get_staff_task_options():
    """Get dropdown options for staff task forms"""
    return jsonify(
        {
            "success": True,
            "categories": TaskService.CATEGORIES,
            "priorities": TaskService.PRIORITIES,
            "statuses": TaskService.STATUSES,
            "recurrence_patterns": TaskService.RECURRENCE_PATTERNS,
        }
    )


@app.route("/dashboard/tasks")
@require_staff()
def dashboard_staff_tasks():
    """Staff task management dashboard page"""
    return render_template("tasks.html")


# END STAFF TASK ASSIGNMENT API
# ===========================================================================


@app.errorhandler(404)
def handle_404_error(error):
    """Handle 404 errors and return JSON"""
    return jsonify({"success": False, "error": "Endpoint not found"}), 404


if __name__ == "__main__":
    port = config.PORT
    print("\n" + "üöÄ" * 30)
    print("FCRA AUTOMATION SERVER STARTING")
    print("üöÄ" * 30)
    print(f"\nüì° Listening on port {port}")
    print("‚úÖ Ready to receive credit reports!\n")
    app.run(host="0.0.0.0", port=port, debug=False, threaded=True)
